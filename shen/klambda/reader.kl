
"                                                   The License
 
 The user is free to produce commercial applications with the software, to distribute these applications in source or binary  form, and to charge monies for them as he sees fit and in concordance with the laws of the land subject to the following  license.
 
 1. The license applies to all the software and all derived software and must appear on such.
 2. It is illegal to distribute the software without this license attached to it and use of the software implies agreement 
    with the license as such. It is illegal for anyone who is not the copyright holder to tamper with or change the license.
 3. Neither the names of Lambda Associates or the copyright holder may be used to endorse or promote products built using
     the software without specific prior written permission from the copyright holder.
 4. That possession of this license does not confer on the copyright holder any special contractual obligation towards the    user. That in no event shall the copyright holder be liable for any direct, indirect, incidental, special, exemplary or   consequential damages (including but not limited to procurement of substitute goods or services, loss of use, data, or    profits; or business interruption), however caused and on any theory of liability, whether in contract, strict liability   or tort (including negligence) arising in any way out of the use of the software, even if advised of the possibility of   such damage. 
5. It is permitted for the user to change the software, for the purpose of improving performance, correcting an error, or    porting to a new platform, and distribute the modified version of Shen (hereafter the modified version) provided the     resulting program conforms in all respects to the Shen standard and is issued under that title. The user must make it clear   with his distribution that he/she is the author of the changes and what these changes are and why. 
6. Derived versions of this software in whatever form are subject to the same restrictions. In particular it is not          permitted to make derived copies of this software which do not conform to the Shen standard or appear under a different title.
7. It is permitted to distribute versions of Shen which incorporate libraries, graphics or other facilities which are not    part of the Shen standard.

For an explication of this license see http://www.lambdassociates.org/News/june11/license.htm which explains this license in full."

(set shen-*symbolcodes* (vector 128))

(address-> (value shen-*symbolcodes*) 126 "~")

(address-> (value shen-*symbolcodes*) 122 "z")

(address-> (value shen-*symbolcodes*) 121 "y")

(address-> (value shen-*symbolcodes*) 120 "x")

(address-> (value shen-*symbolcodes*) 119 "w")

(address-> (value shen-*symbolcodes*) 118 "v")

(address-> (value shen-*symbolcodes*) 117 "u")

(address-> (value shen-*symbolcodes*) 116 "t")

(address-> (value shen-*symbolcodes*) 115 "s")

(address-> (value shen-*symbolcodes*) 114 "r")

(address-> (value shen-*symbolcodes*) 113 "q")

(address-> (value shen-*symbolcodes*) 112 "p")

(address-> (value shen-*symbolcodes*) 111 "o")

(address-> (value shen-*symbolcodes*) 110 "n")

(address-> (value shen-*symbolcodes*) 109 "m")

(address-> (value shen-*symbolcodes*) 108 "l")

(address-> (value shen-*symbolcodes*) 107 "k")

(address-> (value shen-*symbolcodes*) 106 "j")

(address-> (value shen-*symbolcodes*) 105 "i")

(address-> (value shen-*symbolcodes*) 104 "h")

(address-> (value shen-*symbolcodes*) 103 "g")

(address-> (value shen-*symbolcodes*) 102 "f")

(address-> (value shen-*symbolcodes*) 101 "e")

(address-> (value shen-*symbolcodes*) 100 "d")

(address-> (value shen-*symbolcodes*) 99 "c")

(address-> (value shen-*symbolcodes*) 98 "b")

(address-> (value shen-*symbolcodes*) 97 "a")

(address-> (value shen-*symbolcodes*) 96 "`")

(address-> (value shen-*symbolcodes*) 95 "_")

(address-> (value shen-*symbolcodes*) 90 "Z")

(address-> (value shen-*symbolcodes*) 89 "Y")

(address-> (value shen-*symbolcodes*) 88 "X")

(address-> (value shen-*symbolcodes*) 87 "W")

(address-> (value shen-*symbolcodes*) 86 "V")

(address-> (value shen-*symbolcodes*) 85 "U")

(address-> (value shen-*symbolcodes*) 84 "T")

(address-> (value shen-*symbolcodes*) 83 "S")

(address-> (value shen-*symbolcodes*) 82 "R")

(address-> (value shen-*symbolcodes*) 81 "Q")

(address-> (value shen-*symbolcodes*) 80 "P")

(address-> (value shen-*symbolcodes*) 79 "O")

(address-> (value shen-*symbolcodes*) 78 "N")

(address-> (value shen-*symbolcodes*) 77 "M")

(address-> (value shen-*symbolcodes*) 76 "L")

(address-> (value shen-*symbolcodes*) 75 "K")

(address-> (value shen-*symbolcodes*) 74 "J")

(address-> (value shen-*symbolcodes*) 73 "I")

(address-> (value shen-*symbolcodes*) 72 "H")

(address-> (value shen-*symbolcodes*) 71 "G")

(address-> (value shen-*symbolcodes*) 70 "F")

(address-> (value shen-*symbolcodes*) 69 "E")

(address-> (value shen-*symbolcodes*) 68 "D")

(address-> (value shen-*symbolcodes*) 67 "C")

(address-> (value shen-*symbolcodes*) 66 "B")

(address-> (value shen-*symbolcodes*) 65 "A")

(address-> (value shen-*symbolcodes*) 64 "@")

(address-> (value shen-*symbolcodes*) 63 "?")

(address-> (value shen-*symbolcodes*) 62 ">")

(address-> (value shen-*symbolcodes*) 61 "=")

(address-> (value shen-*symbolcodes*) 60 "<")

(address-> (value shen-*symbolcodes*) 57 "9")

(address-> (value shen-*symbolcodes*) 56 "8")

(address-> (value shen-*symbolcodes*) 55 "7")

(address-> (value shen-*symbolcodes*) 54 "6")

(address-> (value shen-*symbolcodes*) 53 "5")

(address-> (value shen-*symbolcodes*) 52 "4")

(address-> (value shen-*symbolcodes*) 51 "3")

(address-> (value shen-*symbolcodes*) 50 "2")

(address-> (value shen-*symbolcodes*) 49 "1")

(address-> (value shen-*symbolcodes*) 48 "0")

(address-> (value shen-*symbolcodes*) 47 "/")

(address-> (value shen-*symbolcodes*) 46 ".")

(address-> (value shen-*symbolcodes*) 45 "-")

(address-> (value shen-*symbolcodes*) 43 "+")

(address-> (value shen-*symbolcodes*) 42 "*")

(address-> (value shen-*symbolcodes*) 39 "'")

(address-> (value shen-*symbolcodes*) 38 "&")

(address-> (value shen-*symbolcodes*) 37 "%")

(address-> (value shen-*symbolcodes*) 36 "$")

(address-> (value shen-*symbolcodes*) 35 "#")

(address-> (value shen-*symbolcodes*) 33 "!")

(defun lineread () (shen-lineread-loop (read-byte (stinput 0)) ()))

(defun shen-lineread-loop (V960 V961)
 (cond ((= V960 (shen-hat)) (interror "line read aborted" ()))
  ((element? V960 (cons (shen-newline) (cons (shen-carriage-return) ())))
   (let Line (compile (lambda V962 (shen-<st_input> V962)) V961 ())
    (if (or (= Line (fail)) (empty? Line))
     (shen-lineread-loop (read-byte (stinput 0)) (append V961 (cons V960 ())))
     Line)))
  (true
   (shen-lineread-loop (read-byte (stinput 0))
    (append V961 (cons V960 ()))))))

(defun read-file (V963)
 (let Bytelist (read-file-as-bytelist V963)
  (compile (lambda V964 (shen-<st_input> V964)) Bytelist
   (lambda V965 (shen-read-error V965)))))

(defun shen-read-error (V966)
 (interror "read error here:~%~% ~A~%" (@p (shen-compress-50 50 V966) ())))

(defun shen-compress-50 (V971 V972)
 (cond ((= () V972) "") ((= 0 V971) "")
  ((cons? V972)
   (cn (n->string (hd V972)) (shen-compress-50 (- V971 1) (tl V972))))
  (true (shen-sys-error shen-compress-50))))

(defun shen-<st_input> (V973)
 (let Result
  (let Parse_<lsb> (shen-<lsb> V973)
   (if (not (= (fail) Parse_<lsb>))
    (let Parse_<st_input1> (shen-<st_input1> Parse_<lsb>)
     (if (not (= (fail) Parse_<st_input1>))
      (let Parse_<rsb> (shen-<rsb> Parse_<st_input1>)
       (if (not (= (fail) Parse_<rsb>))
        (let Parse_<st_input2> (shen-<st_input2> Parse_<rsb>)
         (if (not (= (fail) Parse_<st_input2>))
          (shen-reassemble (fst Parse_<st_input2>)
           (cons (macroexpand (shen-cons_form (snd Parse_<st_input1>)))
            (snd Parse_<st_input2>)))
          (fail)))
        (fail)))
      (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<lrb> (shen-<lrb> V973)
     (if (not (= (fail) Parse_<lrb>))
      (let Parse_<st_input1> (shen-<st_input1> Parse_<lrb>)
       (if (not (= (fail) Parse_<st_input1>))
        (let Parse_<rrb> (shen-<rrb> Parse_<st_input1>)
         (if (not (= (fail) Parse_<rrb>))
          (let Parse_<st_input2> (shen-<st_input2> Parse_<rrb>)
           (if (not (= (fail) Parse_<st_input2>))
            (shen-reassemble (fst Parse_<st_input2>)
             (shen-package-macro (macroexpand (snd Parse_<st_input1>))
              (snd Parse_<st_input2>)))
            (fail)))
          (fail)))
        (fail)))
      (fail)))
    (if (= Result (fail))
     (let Result
      (let Parse_<lcurly> (shen-<lcurly> V973)
       (if (not (= (fail) Parse_<lcurly>))
        (let Parse_<st_input> (shen-<st_input> Parse_<lcurly>)
         (if (not (= (fail) Parse_<st_input>))
          (shen-reassemble (fst Parse_<st_input>)
           (cons { (snd Parse_<st_input>)))
          (fail)))
        (fail)))
      (if (= Result (fail))
       (let Result
        (let Parse_<rcurly> (shen-<rcurly> V973)
         (if (not (= (fail) Parse_<rcurly>))
          (let Parse_<st_input> (shen-<st_input> Parse_<rcurly>)
           (if (not (= (fail) Parse_<st_input>))
            (shen-reassemble (fst Parse_<st_input>)
             (cons } (snd Parse_<st_input>)))
            (fail)))
          (fail)))
        (if (= Result (fail))
         (let Result
          (let Parse_<bar> (shen-<bar> V973)
           (if (not (= (fail) Parse_<bar>))
            (let Parse_<st_input> (shen-<st_input> Parse_<bar>)
             (if (not (= (fail) Parse_<st_input>))
              (shen-reassemble (fst Parse_<st_input>)
               (cons bar! (snd Parse_<st_input>)))
              (fail)))
            (fail)))
          (if (= Result (fail))
           (let Result
            (let Parse_<semicolon> (shen-<semicolon> V973)
             (if (not (= (fail) Parse_<semicolon>))
              (let Parse_<st_input> (shen-<st_input> Parse_<semicolon>)
               (if (not (= (fail) Parse_<st_input>))
                (shen-reassemble (fst Parse_<st_input>)
                 (cons ; (snd Parse_<st_input>)))
                (fail)))
              (fail)))
            (if (= Result (fail))
             (let Result
              (let Parse_<colon> (shen-<colon> V973)
               (if (not (= (fail) Parse_<colon>))
                (let Parse_<equal> (shen-<equal> Parse_<colon>)
                 (if (not (= (fail) Parse_<equal>))
                  (let Parse_<st_input> (shen-<st_input> Parse_<equal>)
                   (if (not (= (fail) Parse_<st_input>))
                    (shen-reassemble (fst Parse_<st_input>)
                     (cons := (snd Parse_<st_input>)))
                    (fail)))
                  (fail)))
                (fail)))
              (if (= Result (fail))
               (let Result
                (let Parse_<colon> (shen-<colon> V973)
                 (if (not (= (fail) Parse_<colon>))
                  (let Parse_<minus> (shen-<minus> Parse_<colon>)
                   (if (not (= (fail) Parse_<minus>))
                    (let Parse_<st_input> (shen-<st_input> Parse_<minus>)
                     (if (not (= (fail) Parse_<st_input>))
                      (shen-reassemble (fst Parse_<st_input>)
                       (cons :- (snd Parse_<st_input>)))
                      (fail)))
                    (fail)))
                  (fail)))
                (if (= Result (fail))
                 (let Result
                  (let Parse_<colon> (shen-<colon> V973)
                   (if (not (= (fail) Parse_<colon>))
                    (let Parse_<st_input> (shen-<st_input> Parse_<colon>)
                     (if (not (= (fail) Parse_<st_input>))
                      (shen-reassemble (fst Parse_<st_input>)
                       (cons : (snd Parse_<st_input>)))
                      (fail)))
                    (fail)))
                  (if (= Result (fail))
                   (let Result
                    (let Parse_<comma> (shen-<comma> V973)
                     (if (not (= (fail) Parse_<comma>))
                      (let Parse_<st_input> (shen-<st_input> Parse_<comma>)
                       (if (not (= (fail) Parse_<st_input>))
                        (shen-reassemble (fst Parse_<st_input>)
                         (cons shen- (snd Parse_<st_input>)))
                        (fail)))
                      (fail)))
                    (if (= Result (fail))
                     (let Result
                      (let Parse_<comment> (shen-<comment> V973)
                       (if (not (= (fail) Parse_<comment>))
                        (let Parse_<st_input> (shen-<st_input> Parse_<comment>)
                         (if (not (= (fail) Parse_<st_input>))
                          (shen-reassemble (fst Parse_<st_input>)
                           (snd Parse_<st_input>))
                          (fail)))
                        (fail)))
                      (if (= Result (fail))
                       (let Result
                        (let Parse_<atom> (shen-<atom> V973)
                         (if (not (= (fail) Parse_<atom>))
                          (let Parse_<st_input> (shen-<st_input> Parse_<atom>)
                           (if (not (= (fail) Parse_<st_input>))
                            (shen-reassemble (fst Parse_<st_input>)
                             (cons (macroexpand (snd Parse_<atom>))
                              (snd Parse_<st_input>)))
                            (fail)))
                          (fail)))
                        (if (= Result (fail))
                         (let Result
                          (let Parse_<whitespaces> (shen-<whitespaces> V973)
                           (if (not (= (fail) Parse_<whitespaces>))
                            (let Parse_<st_input>
                             (shen-<st_input> Parse_<whitespaces>)
                             (if (not (= (fail) Parse_<st_input>))
                              (shen-reassemble (fst Parse_<st_input>)
                               (snd Parse_<st_input>))
                              (fail)))
                            (fail)))
                          (if (= Result (fail))
                           (let Result
                            (let Parse_<e> (<e> V973)
                             (if (not (= (fail) Parse_<e>))
                              (shen-reassemble (fst Parse_<e>) ()) (fail)))
                            (if (= Result (fail)) (fail) Result))
                           Result))
                         Result))
                       Result))
                     Result))
                   Result))
                 Result))
               Result))
             Result))
           Result))
         Result))
       Result))
     Result))
   Result)))

(defun shen-<lsb> (V974)
 (let Result
  (if (cons? (fst V974))
   (shen-reassemble (fst (shen-reassemble (tl (fst V974)) (snd V974)))
    (if (= (hd (fst V974)) 91) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<rsb> (V975)
 (let Result
  (if (cons? (fst V975))
   (shen-reassemble (fst (shen-reassemble (tl (fst V975)) (snd V975)))
    (if (= (hd (fst V975)) 93) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<lcurly> (V976)
 (let Result
  (if (cons? (fst V976))
   (shen-reassemble (fst (shen-reassemble (tl (fst V976)) (snd V976)))
    (if (= (hd (fst V976)) 123) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<rcurly> (V977)
 (let Result
  (if (cons? (fst V977))
   (shen-reassemble (fst (shen-reassemble (tl (fst V977)) (snd V977)))
    (if (= (hd (fst V977)) 125) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<bar> (V978)
 (let Result
  (if (cons? (fst V978))
   (shen-reassemble (fst (shen-reassemble (tl (fst V978)) (snd V978)))
    (if (= (hd (fst V978)) 124) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<semicolon> (V979)
 (let Result
  (if (cons? (fst V979))
   (shen-reassemble (fst (shen-reassemble (tl (fst V979)) (snd V979)))
    (if (= (hd (fst V979)) 59) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<colon> (V980)
 (let Result
  (if (cons? (fst V980))
   (shen-reassemble (fst (shen-reassemble (tl (fst V980)) (snd V980)))
    (if (= (hd (fst V980)) 58) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<comma> (V981)
 (let Result
  (if (cons? (fst V981))
   (shen-reassemble (fst (shen-reassemble (tl (fst V981)) (snd V981)))
    (if (= (hd (fst V981)) 44) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<equal> (V982)
 (let Result
  (if (cons? (fst V982))
   (shen-reassemble (fst (shen-reassemble (tl (fst V982)) (snd V982)))
    (if (= (hd (fst V982)) 61) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<minus> (V983)
 (let Result
  (if (cons? (fst V983))
   (shen-reassemble (fst (shen-reassemble (tl (fst V983)) (snd V983)))
    (if (= (hd (fst V983)) 45) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<lrb> (V984)
 (let Result
  (if (cons? (fst V984))
   (shen-reassemble (fst (shen-reassemble (tl (fst V984)) (snd V984)))
    (if (= (hd (fst V984)) 40) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<rrb> (V985)
 (let Result
  (if (cons? (fst V985))
   (shen-reassemble (fst (shen-reassemble (tl (fst V985)) (snd V985)))
    (if (= (hd (fst V985)) 41) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<atom> (V986)
 (let Result
  (let Parse_<str> (shen-<str> V986)
   (if (not (= (fail) Parse_<str>))
    (shen-reassemble (fst Parse_<str>) (shen-control-chars (snd Parse_<str>)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<number> (shen-<number> V986)
     (if (not (= (fail) Parse_<number>))
      (shen-reassemble (fst Parse_<number>) (snd Parse_<number>)) (fail)))
    (if (= Result (fail))
     (let Result
      (let Parse_<sym> (shen-<sym> V986)
       (if (not (= (fail) Parse_<sym>))
        (shen-reassemble (fst Parse_<sym>) (snd Parse_<sym>)) (fail)))
      (if (= Result (fail)) (fail) Result))
     Result))
   Result)))

(defun shen-control-chars (V987)
 (cond ((= () V987) "")
  ((and (cons? V987)
    (and (= "c" (hd V987))
     (and (cons? (tl V987)) (= "#" (hd (tl V987))))))
   (let CodePoint (shen-code-point (tl (tl V987)))
    (let AfterCodePoint (shen-after-codepoint (tl (tl V987)))
     (@s (n->string (shen-decimalise CodePoint))
      (shen-control-chars AfterCodePoint)))))
  ((cons? V987) (@s (hd V987) (shen-control-chars (tl V987))))
  (true (shen-sys-error shen-control-chars))))

(defun shen-code-point (V990)
 (cond ((and (cons? V990) (= ";" (hd V990))) "")
  ((and (cons? V990)
    (element? (hd V990)
     (cons "0"
      (cons "1"
       (cons "2"
        (cons "3"
         (cons "4"
          (cons "5"
           (cons "6" (cons "7" (cons "8" (cons "9" (cons "0" ())))))))))))))
   (cons (hd V990) (shen-code-point (tl V990))))
  (true (interror "code point parse error ~A~%" (@p V990 ())))))

(defun shen-after-codepoint (V995)
 (cond ((= () V995) ())
  ((and (cons? V995) (= ";" (hd V995))) (tl V995))
  ((cons? V995) (shen-after-codepoint (tl V995)))
  (true (shen-sys-error shen-after-codepoint))))

(defun shen-decimalise (V996)
 (shen-pre (reverse (shen-digits->integers V996)) 0))

(defun shen-digits->integers (V1001)
 (cond
  ((and (cons? V1001) (= "0" (hd V1001)))
   (cons 0 (shen-digits->integers (tl V1001))))
  ((and (cons? V1001) (= "1" (hd V1001)))
   (cons 1 (shen-digits->integers (tl V1001))))
  ((and (cons? V1001) (= "2" (hd V1001)))
   (cons 2 (shen-digits->integers (tl V1001))))
  ((and (cons? V1001) (= "3" (hd V1001)))
   (cons 3 (shen-digits->integers (tl V1001))))
  ((and (cons? V1001) (= "4" (hd V1001)))
   (cons 4 (shen-digits->integers (tl V1001))))
  ((and (cons? V1001) (= "5" (hd V1001)))
   (cons 5 (shen-digits->integers (tl V1001))))
  ((and (cons? V1001) (= "6" (hd V1001)))
   (cons 6 (shen-digits->integers (tl V1001))))
  ((and (cons? V1001) (= "7" (hd V1001)))
   (cons 7 (shen-digits->integers (tl V1001))))
  ((and (cons? V1001) (= "8" (hd V1001)))
   (cons 8 (shen-digits->integers (tl V1001))))
  ((and (cons? V1001) (= "9" (hd V1001)))
   (cons 9 (shen-digits->integers (tl V1001))))
  (true ())))

(defun shen-<sym> (V1002)
 (let Result
  (let Parse_<alpha> (shen-<alpha> V1002)
   (if (not (= (fail) Parse_<alpha>))
    (let Parse_<symchars> (shen-<symchars> Parse_<alpha>)
     (if (not (= (fail) Parse_<symchars>))
      (shen-reassemble (fst Parse_<symchars>)
       (intern (cn (snd Parse_<alpha>) (snd Parse_<symchars>))))
      (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<alpha> (shen-<alpha> V1002)
     (if (not (= (fail) Parse_<alpha>))
      (shen-reassemble (fst Parse_<alpha>) (intern (snd Parse_<alpha>)))
      (fail)))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<symchars> (V1003)
 (let Result
  (let Parse_<symchar> (shen-<symchar> V1003)
   (if (not (= (fail) Parse_<symchar>))
    (let Parse_<symchars> (shen-<symchars> Parse_<symchar>)
     (if (not (= (fail) Parse_<symchars>))
      (shen-reassemble (fst Parse_<symchars>)
       (cn (snd Parse_<symchar>) (snd Parse_<symchars>)))
      (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<symchar> (shen-<symchar> V1003)
     (if (not (= (fail) Parse_<symchar>))
      (shen-reassemble (fst Parse_<symchar>) (snd Parse_<symchar>)) (fail)))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<symchar> (V1004)
 (let Result
  (let Parse_<alpha> (shen-<alpha> V1004)
   (if (not (= (fail) Parse_<alpha>))
    (shen-reassemble (fst Parse_<alpha>) (snd Parse_<alpha>)) (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<digit->string> (shen-<digit->string> V1004)
     (if (not (= (fail) Parse_<digit->string>))
      (shen-reassemble (fst Parse_<digit->string>) (snd Parse_<digit->string>))
      (fail)))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<digit->string> (V1005)
 (let Result
  (if (cons? (fst V1005))
   (shen-reassemble (fst (shen-reassemble (tl (fst V1005)) (snd V1005)))
    (if (shen-digit-byte? (hd (fst V1005))) (n->string (hd (fst V1005)))
     (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-digit-byte? (V1010)
 (cond ((= 48 V1010) true) ((= 49 V1010) true) ((= 50 V1010) true)
  ((= 51 V1010) true) ((= 52 V1010) true) ((= 53 V1010) true)
  ((= 54 V1010) true) ((= 55 V1010) true) ((= 56 V1010) true)
  ((= 57 V1010) true) (true false)))

(defun shen-<alpha> (V1011)
 (let Result
  (if (cons? (fst V1011))
   (shen-reassemble (fst (shen-reassemble (tl (fst V1011)) (snd V1011)))
    (let S (shen-symbol-byte->string (hd (fst V1011)))
     (if (= S (fail)) (fail) S)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-symbol-byte->string (V1012)
 (<-address (value shen-*symbolcodes*) V1012))

(defun shen-<str> (V1013)
 (let Result
  (let Parse_<dbq> (shen-<dbq> V1013)
   (if (not (= (fail) Parse_<dbq>))
    (let Parse_<strcontents> (shen-<strcontents> Parse_<dbq>)
     (if (not (= (fail) Parse_<strcontents>))
      (let Parse_<dbq> (shen-<dbq> Parse_<strcontents>)
       (if (not (= (fail) Parse_<dbq>))
        (shen-reassemble (fst Parse_<dbq>) (snd Parse_<strcontents>)) (fail)))
      (fail)))
    (fail)))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<dbq> (V1014)
 (let Result
  (if (cons? (fst V1014))
   (shen-reassemble (fst (shen-reassemble (tl (fst V1014)) (snd V1014)))
    (if (= (hd (fst V1014)) 34) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<strcontents> (V1015)
 (let Result
  (let Parse_<strc> (shen-<strc> V1015)
   (if (not (= (fail) Parse_<strc>))
    (let Parse_<strcontents> (shen-<strcontents> Parse_<strc>)
     (if (not (= (fail) Parse_<strcontents>))
      (shen-reassemble (fst Parse_<strcontents>)
       (cons (snd Parse_<strc>) (snd Parse_<strcontents>)))
      (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<e> (<e> V1015)
     (if (not (= (fail) Parse_<e>)) (shen-reassemble (fst Parse_<e>) ())
      (fail)))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<byte> (V1016)
 (let Result
  (if (cons? (fst V1016))
   (shen-reassemble (fst (shen-reassemble (tl (fst V1016)) (snd V1016)))
    (n->string (hd (fst V1016))))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<strc> (V1017)
 (let Result
  (if (cons? (fst V1017))
   (shen-reassemble (fst (shen-reassemble (tl (fst V1017)) (snd V1017)))
    (if (= (hd (fst V1017)) 34) (fail) (n->string (hd (fst V1017)))))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<backslash> (V1018)
 (let Result
  (if (cons? (fst V1018))
   (shen-reassemble (fst (shen-reassemble (tl (fst V1018)) (snd V1018)))
    (if (= (hd (fst V1018)) 92) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<number> (V1019)
 (let Result
  (let Parse_<minus> (shen-<minus> V1019)
   (if (not (= (fail) Parse_<minus>))
    (let Parse_<number> (shen-<number> Parse_<minus>)
     (if (not (= (fail) Parse_<number>))
      (shen-reassemble (fst Parse_<number>) (- 0 (snd Parse_<number>)))
      (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<plus> (shen-<plus> V1019)
     (if (not (= (fail) Parse_<plus>))
      (let Parse_<number> (shen-<number> Parse_<plus>)
       (if (not (= (fail) Parse_<number>))
        (shen-reassemble (fst Parse_<number>) (snd Parse_<number>)) (fail)))
      (fail)))
    (if (= Result (fail))
     (let Result
      (let Parse_<predigits> (shen-<predigits> V1019)
       (if (not (= (fail) Parse_<predigits>))
        (let Parse_<stop> (shen-<stop> Parse_<predigits>)
         (if (not (= (fail) Parse_<stop>))
          (let Parse_<postdigits> (shen-<postdigits> Parse_<stop>)
           (if (not (= (fail) Parse_<postdigits>))
            (let Parse_<E> (shen-<E> Parse_<postdigits>)
             (if (not (= (fail) Parse_<E>))
              (let Parse_<log10> (shen-<log10> Parse_<E>)
               (if (not (= (fail) Parse_<log10>))
                (shen-reassemble (fst Parse_<log10>)
                 (* (shen-expt 10 (snd Parse_<log10>))
                  (+ (shen-pre (reverse (snd Parse_<predigits>)) 0)
                   (shen-post (snd Parse_<postdigits>) 1))))
                (fail)))
              (fail)))
            (fail)))
          (fail)))
        (fail)))
      (if (= Result (fail))
       (let Result
        (let Parse_<digits> (shen-<digits> V1019)
         (if (not (= (fail) Parse_<digits>))
          (let Parse_<E> (shen-<E> Parse_<digits>)
           (if (not (= (fail) Parse_<E>))
            (let Parse_<log10> (shen-<log10> Parse_<E>)
             (if (not (= (fail) Parse_<log10>))
              (shen-reassemble (fst Parse_<log10>)
               (* (shen-expt 10 (snd Parse_<log10>))
                (shen-pre (reverse (snd Parse_<digits>)) 0)))
              (fail)))
            (fail)))
          (fail)))
        (if (= Result (fail))
         (let Result
          (let Parse_<predigits> (shen-<predigits> V1019)
           (if (not (= (fail) Parse_<predigits>))
            (let Parse_<stop> (shen-<stop> Parse_<predigits>)
             (if (not (= (fail) Parse_<stop>))
              (let Parse_<postdigits> (shen-<postdigits> Parse_<stop>)
               (if (not (= (fail) Parse_<postdigits>))
                (shen-reassemble (fst Parse_<postdigits>)
                 (+ (shen-pre (reverse (snd Parse_<predigits>)) 0)
                  (shen-post (snd Parse_<postdigits>) 1)))
                (fail)))
              (fail)))
            (fail)))
          (if (= Result (fail))
           (let Result
            (let Parse_<digits> (shen-<digits> V1019)
             (if (not (= (fail) Parse_<digits>))
              (shen-reassemble (fst Parse_<digits>)
               (shen-pre (reverse (snd Parse_<digits>)) 0))
              (fail)))
            (if (= Result (fail)) (fail) Result))
           Result))
         Result))
       Result))
     Result))
   Result)))

(defun shen-<E> (V1020)
 (let Result
  (if (and (cons? (fst V1020)) (= 101 (hd (fst V1020))))
   (shen-reassemble (fst (shen-reassemble (tl (fst V1020)) (snd V1020)))
    (cons 101 ()))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<log10> (V1021)
 (let Result
  (let Parse_<minus> (shen-<minus> V1021)
   (if (not (= (fail) Parse_<minus>))
    (let Parse_<digits> (shen-<digits> Parse_<minus>)
     (if (not (= (fail) Parse_<digits>))
      (shen-reassemble (fst Parse_<digits>)
       (- 0 (shen-pre (reverse (snd Parse_<digits>)) 0)))
      (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<digits> (shen-<digits> V1021)
     (if (not (= (fail) Parse_<digits>))
      (shen-reassemble (fst Parse_<digits>)
       (shen-pre (reverse (snd Parse_<digits>)) 0))
      (fail)))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<plus> (V1022)
 (let Result
  (if (cons? (fst V1022))
   (shen-reassemble (fst (shen-reassemble (tl (fst V1022)) (snd V1022)))
    (if (= (hd (fst V1022)) 43) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<stop> (V1023)
 (let Result
  (if (cons? (fst V1023))
   (shen-reassemble (fst (shen-reassemble (tl (fst V1023)) (snd V1023)))
    (if (= (hd (fst V1023)) 46) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<predigits> (V1024)
 (let Result
  (let Parse_<digits> (shen-<digits> V1024)
   (if (not (= (fail) Parse_<digits>))
    (shen-reassemble (fst Parse_<digits>) (snd Parse_<digits>)) (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<e> (<e> V1024)
     (if (not (= (fail) Parse_<e>)) (shen-reassemble (fst Parse_<e>) ())
      (fail)))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<postdigits> (V1025)
 (let Result
  (let Parse_<digits> (shen-<digits> V1025)
   (if (not (= (fail) Parse_<digits>))
    (shen-reassemble (fst Parse_<digits>) (snd Parse_<digits>)) (fail)))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<digits> (V1026)
 (let Result
  (let Parse_<digit> (shen-<digit> V1026)
   (if (not (= (fail) Parse_<digit>))
    (let Parse_<digits> (shen-<digits> Parse_<digit>)
     (if (not (= (fail) Parse_<digits>))
      (shen-reassemble (fst Parse_<digits>)
       (cons (snd Parse_<digit>) (snd Parse_<digits>)))
      (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<digit> (shen-<digit> V1026)
     (if (not (= (fail) Parse_<digit>))
      (shen-reassemble (fst Parse_<digit>) (cons (snd Parse_<digit>) ()))
      (fail)))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<digit> (V1027)
 (let Result
  (if (cons? (fst V1027))
   (shen-reassemble (fst (shen-reassemble (tl (fst V1027)) (snd V1027)))
    (if (shen-digit-byte? (hd (fst V1027))) (shen-byte->digit (hd (fst V1027)))
     (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-byte->digit (V1028)
 (cond ((= 48 V1028) 0) ((= 49 V1028) 1) ((= 50 V1028) 2)
  ((= 51 V1028) 3) ((= 52 V1028) 4) ((= 53 V1028) 5)
  ((= 54 V1028) 6) ((= 55 V1028) 7) ((= 56 V1028) 8)
  ((= 57 V1028) 9) (true (shen-sys-error shen-byte->digit))))

(defun shen-pre (V1031 V1032)
 (cond ((= () V1031) 0)
  ((cons? V1031)
   (+ (* (shen-expt 10 V1032) (hd V1031)) (shen-pre (tl V1031) (+ V1032 1))))
  (true (shen-sys-error shen-pre))))

(defun shen-post (V1035 V1036)
 (cond ((= () V1035) 0)
  ((cons? V1035)
   (+ (* (shen-expt 10 (- 0 V1036)) (hd V1035))
    (shen-post (tl V1035) (+ V1036 1))))
  (true (shen-sys-error shen-post))))

(defun shen-expt (V1039 V1040)
 (cond ((= 0 V1040) 1)
  ((> V1040 0) (* V1039 (shen-expt V1039 (- V1040 1))))
  (true (* 1.0 (/ (shen-expt V1039 (+ V1040 1)) V1039)))))

(defun shen-<st_input1> (V1041)
 (let Result
  (let Parse_<st_input> (shen-<st_input> V1041)
   (if (not (= (fail) Parse_<st_input>))
    (shen-reassemble (fst Parse_<st_input>) (snd Parse_<st_input>)) (fail)))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<st_input2> (V1042)
 (let Result
  (let Parse_<st_input> (shen-<st_input> V1042)
   (if (not (= (fail) Parse_<st_input>))
    (shen-reassemble (fst Parse_<st_input>) (snd Parse_<st_input>)) (fail)))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<comment> (V1043)
 (let Result
  (let Parse_<backslash> (shen-<backslash> V1043)
   (if (not (= (fail) Parse_<backslash>))
    (let Parse_<times> (shen-<times> Parse_<backslash>)
     (if (not (= (fail) Parse_<times>))
      (let Parse_<any> (shen-<any> Parse_<times>)
       (if (not (= (fail) Parse_<any>))
        (let Parse_<times> (shen-<times> Parse_<any>)
         (if (not (= (fail) Parse_<times>))
          (let Parse_<backslash> (shen-<backslash> Parse_<times>)
           (if (not (= (fail) Parse_<backslash>))
            (shen-reassemble (fst Parse_<backslash>) shen-skip) (fail)))
          (fail)))
        (fail)))
      (fail)))
    (fail)))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<times> (V1044)
 (let Result
  (if (cons? (fst V1044))
   (shen-reassemble (fst (shen-reassemble (tl (fst V1044)) (snd V1044)))
    (if (= (hd (fst V1044)) 42) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<any> (V1045)
 (let Result
  (let Parse_<comment> (shen-<comment> V1045)
   (if (not (= (fail) Parse_<comment>))
    (let Parse_<any> (shen-<any> Parse_<comment>)
     (if (not (= (fail) Parse_<any>))
      (shen-reassemble (fst Parse_<any>) shen-skip) (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<blah> (shen-<blah> V1045)
     (if (not (= (fail) Parse_<blah>))
      (let Parse_<any> (shen-<any> Parse_<blah>)
       (if (not (= (fail) Parse_<any>))
        (shen-reassemble (fst Parse_<any>) shen-skip) (fail)))
      (fail)))
    (if (= Result (fail))
     (let Result
      (let Parse_<e> (<e> V1045)
       (if (not (= (fail) Parse_<e>))
        (shen-reassemble (fst Parse_<e>) shen-skip) (fail)))
      (if (= Result (fail)) (fail) Result))
     Result))
   Result)))

(defun shen-<blah> (V1046)
 (let Result
  (if (cons? (fst V1046))
   (shen-reassemble (fst (shen-reassemble (tl (fst V1046)) (snd V1046)))
    (if (shen-end-of-comment? (fst V1046)) (fail) shen-skip))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-end-of-comment? (V1053)
 (cond
  ((and (cons? V1053)
    (and (= 42 (hd V1053))
     (and (cons? (tl V1053)) (= 92 (hd (tl V1053))))))
   true)
  (true false)))

(defun shen-<whitespaces> (V1054)
 (let Result
  (let Parse_<whitespace> (shen-<whitespace> V1054)
   (if (not (= (fail) Parse_<whitespace>))
    (let Parse_<whitespaces> (shen-<whitespaces> Parse_<whitespace>)
     (if (not (= (fail) Parse_<whitespaces>))
      (shen-reassemble (fst Parse_<whitespaces>) shen-skip) (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<whitespace> (shen-<whitespace> V1054)
     (if (not (= (fail) Parse_<whitespace>))
      (shen-reassemble (fst Parse_<whitespace>) shen-skip) (fail)))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<whitespace> (V1055)
 (let Result
  (if (cons? (fst V1055))
   (shen-reassemble (fst (shen-reassemble (tl (fst V1055)) (snd V1055)))
    (let Case (hd (fst V1055))
     (if (= Case 32) shen-skip
      (if (= Case 13) shen-skip
       (if (= Case 10) shen-skip (if (= Case 9) shen-skip (fail)))))))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-cons_form (V1056)
 (cond ((= () V1056) ())
  ((and (cons? V1056)
    (and (cons? (tl V1056))
     (and (= bar! (hd (tl V1056)))
      (and (cons? (tl (tl V1056))) (= () (tl (tl (tl V1056))))))))
   (cons cons (cons (hd V1056) (tl (tl V1056)))))
  ((cons? V1056)
   (cons cons (cons (hd V1056) (cons (shen-cons_form (tl V1056)) ()))))
  (true (shen-sys-error shen-cons_form))))

(defun shen-package-macro (V1059 V1060)
 (cond
  ((and (cons? V1059)
    (and (= $ (hd V1059))
     (and (cons? (tl V1059)) (= () (tl (tl V1059))))))
   (append (explode (hd (tl V1059))) V1060))
  ((and (cons? V1059)
    (and (= package (hd V1059))
     (and (cons? (tl V1059))
      (and (= null (hd (tl V1059))) (cons? (tl (tl V1059)))))))
   (append (tl (tl (tl V1059))) V1060))
  ((and (cons? V1059)
    (and (= package (hd V1059))
     (and (cons? (tl V1059)) (cons? (tl (tl V1059))))))
   (let ListofExceptions (shen-eval-without-macros (hd (tl (tl V1059))))
    (let Record (shen-record-exceptions ListofExceptions (hd (tl V1059)))
     (append
      (shen-packageh (hd (tl V1059)) ListofExceptions (tl (tl (tl V1059))))
      V1060))))
  (true (cons V1059 V1060))))

(defun shen-record-exceptions (V1061 V1062)
 (let CurrExceptions
  (trap-error (get V1062 shen-external-symbols (value shen-*property-vector*))
   (lambda E ()))
  (let AllExceptions (union V1061 CurrExceptions)
   (put V1062 shen-external-symbols AllExceptions
    (value shen-*property-vector*)))))

(defun shen-packageh (V1071 V1072 V1073)
 (cond
  ((cons? V1073)
   (cons (shen-packageh V1071 V1072 (hd V1073))
    (shen-packageh V1071 V1072 (tl V1073))))
  ((or (shen-sysfunc? V1073)
    (or (variable? V1073)
     (or (element? V1073 V1072)
      (or (shen-doubleunderline? V1073) (shen-singleunderline? V1073)))))
   V1073)
  ((and (symbol? V1073)
    (not
     (shen-prefix? (cons "s" (cons "h" (cons "e" (cons "n" (cons "-" ())))))
      (explode V1073))))
   (concat V1071 V1073))
  (true V1073)))

