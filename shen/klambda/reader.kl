
"                                                   The License
 
 The user is free to produce commercial applications with the software, to distribute these applications in source or binary  form, and to charge monies for them as he sees fit and in concordance with the laws of the land subject to the following  license.
 
 1. The license applies to all the software and all derived software and must appear on such.
 2. It is illegal to distribute the software without this license attached to it and use of the software implies agreement 
    with the license as such. It is illegal for anyone who is not the copyright holder to tamper with or change the license.
 3. Neither the names of Lambda Associates or the copyright holder may be used to endorse or promote products built using
     the software without specific prior written permission from the copyright holder.
 4. That possession of this license does not confer on the copyright holder any special contractual obligation towards the    user. That in no event shall the copyright holder be liable for any direct, indirect, incidental, special, exemplary or   consequential damages (including but not limited to procurement of substitute goods or services, loss of use, data, or    profits; or business interruption), however caused and on any theory of liability, whether in contract, strict liability   or tort (including negligence) arising in any way out of the use of the software, even if advised of the possibility of   such damage. 
5. It is permitted for the user to change the software, for the purpose of improving performance, correcting an error, or    porting to a new platform, and distribute the modified version of Shen (hereafter the modified version) provided the     resulting program conforms in all respects to the Shen standard and is issued under that title. The user must make it clear   with his distribution that he/she is the author of the changes and what these changes are and why. 
6. Derived versions of this software in whatever form are subject to the same restrictions. In particular it is not          permitted to make derived copies of this software which do not conform to the Shen standard or appear under a different title.
7. It is permitted to distribute versions of Shen which incorporate libraries, graphics or other facilities which are not    part of the Shen standard.

For an explication of this license see http://www.lambdassociates.org/News/june11/license.htm which explains this license in full."

(set shen-*symbolcodes* (vector 128))

(address-> (value shen-*symbolcodes*) 126 "~")

(address-> (value shen-*symbolcodes*) 122 "z")

(address-> (value shen-*symbolcodes*) 121 "y")

(address-> (value shen-*symbolcodes*) 120 "x")

(address-> (value shen-*symbolcodes*) 119 "w")

(address-> (value shen-*symbolcodes*) 118 "v")

(address-> (value shen-*symbolcodes*) 117 "u")

(address-> (value shen-*symbolcodes*) 116 "t")

(address-> (value shen-*symbolcodes*) 115 "s")

(address-> (value shen-*symbolcodes*) 114 "r")

(address-> (value shen-*symbolcodes*) 113 "q")

(address-> (value shen-*symbolcodes*) 112 "p")

(address-> (value shen-*symbolcodes*) 111 "o")

(address-> (value shen-*symbolcodes*) 110 "n")

(address-> (value shen-*symbolcodes*) 109 "m")

(address-> (value shen-*symbolcodes*) 108 "l")

(address-> (value shen-*symbolcodes*) 107 "k")

(address-> (value shen-*symbolcodes*) 106 "j")

(address-> (value shen-*symbolcodes*) 105 "i")

(address-> (value shen-*symbolcodes*) 104 "h")

(address-> (value shen-*symbolcodes*) 103 "g")

(address-> (value shen-*symbolcodes*) 102 "f")

(address-> (value shen-*symbolcodes*) 101 "e")

(address-> (value shen-*symbolcodes*) 100 "d")

(address-> (value shen-*symbolcodes*) 99 "c")

(address-> (value shen-*symbolcodes*) 98 "b")

(address-> (value shen-*symbolcodes*) 97 "a")

(address-> (value shen-*symbolcodes*) 96 "`")

(address-> (value shen-*symbolcodes*) 95 "_")

(address-> (value shen-*symbolcodes*) 90 "Z")

(address-> (value shen-*symbolcodes*) 89 "Y")

(address-> (value shen-*symbolcodes*) 88 "X")

(address-> (value shen-*symbolcodes*) 87 "W")

(address-> (value shen-*symbolcodes*) 86 "V")

(address-> (value shen-*symbolcodes*) 85 "U")

(address-> (value shen-*symbolcodes*) 84 "T")

(address-> (value shen-*symbolcodes*) 83 "S")

(address-> (value shen-*symbolcodes*) 82 "R")

(address-> (value shen-*symbolcodes*) 81 "Q")

(address-> (value shen-*symbolcodes*) 80 "P")

(address-> (value shen-*symbolcodes*) 79 "O")

(address-> (value shen-*symbolcodes*) 78 "N")

(address-> (value shen-*symbolcodes*) 77 "M")

(address-> (value shen-*symbolcodes*) 76 "L")

(address-> (value shen-*symbolcodes*) 75 "K")

(address-> (value shen-*symbolcodes*) 74 "J")

(address-> (value shen-*symbolcodes*) 73 "I")

(address-> (value shen-*symbolcodes*) 72 "H")

(address-> (value shen-*symbolcodes*) 71 "G")

(address-> (value shen-*symbolcodes*) 70 "F")

(address-> (value shen-*symbolcodes*) 69 "E")

(address-> (value shen-*symbolcodes*) 68 "D")

(address-> (value shen-*symbolcodes*) 67 "C")

(address-> (value shen-*symbolcodes*) 66 "B")

(address-> (value shen-*symbolcodes*) 65 "A")

(address-> (value shen-*symbolcodes*) 64 "@")

(address-> (value shen-*symbolcodes*) 63 "?")

(address-> (value shen-*symbolcodes*) 62 ">")

(address-> (value shen-*symbolcodes*) 61 "=")

(address-> (value shen-*symbolcodes*) 60 "<")

(address-> (value shen-*symbolcodes*) 57 "9")

(address-> (value shen-*symbolcodes*) 56 "8")

(address-> (value shen-*symbolcodes*) 55 "7")

(address-> (value shen-*symbolcodes*) 54 "6")

(address-> (value shen-*symbolcodes*) 53 "5")

(address-> (value shen-*symbolcodes*) 52 "4")

(address-> (value shen-*symbolcodes*) 51 "3")

(address-> (value shen-*symbolcodes*) 50 "2")

(address-> (value shen-*symbolcodes*) 49 "1")

(address-> (value shen-*symbolcodes*) 48 "0")

(address-> (value shen-*symbolcodes*) 47 "/")

(address-> (value shen-*symbolcodes*) 46 ".")

(address-> (value shen-*symbolcodes*) 45 "-")

(address-> (value shen-*symbolcodes*) 43 "+")

(address-> (value shen-*symbolcodes*) 42 "*")

(address-> (value shen-*symbolcodes*) 39 "'")

(address-> (value shen-*symbolcodes*) 38 "&")

(address-> (value shen-*symbolcodes*) 37 "%")

(address-> (value shen-*symbolcodes*) 36 "$")

(address-> (value shen-*symbolcodes*) 35 "#")

(address-> (value shen-*symbolcodes*) 33 "!")

(defun lineread () (shen-lineread-loop (read-byte (stinput 0)) ()))

(defun shen-lineread-loop (V4601 V4602)
 (cond ((= V4601 (shen-hat)) (interror "line read aborted" ()))
  ((element? V4601 (cons (shen-newline) (cons (shen-carriage-return) ())))
   (let Line (compile (lambda V4603 (shen-<st_input> V4603)) V4602 ())
    (if (or (= Line (fail)) (empty? Line))
     (shen-lineread-loop (read-byte (stinput 0))
      (append V4602 (cons V4601 ())))
     Line)))
  (true
   (shen-lineread-loop (read-byte (stinput 0))
    (append V4602 (cons V4601 ()))))))

(defun read-file (V4604)
 (let Bytelist (read-file-as-bytelist V4604)
  (compile (lambda V4605 (shen-<st_input> V4605)) Bytelist
   (lambda V4606 (shen-read-error V4606)))))

(defun shen-read-error (V4607)
 (interror "read error here:~%~% ~A~%" (@p (shen-compress-50 50 V4607) ())))

(defun shen-compress-50 (V4612 V4613)
 (cond ((= () V4613) "") ((= 0 V4612) "")
  ((cons? V4613)
   (cn (n->string (hd V4613)) (shen-compress-50 (- V4612 1) (tl V4613))))
  (true (shen-sys-error shen-compress-50))))

(defun shen-<st_input> (V4614)
 (let Result
  (let Parse_<lsb> (shen-<lsb> V4614)
   (if (not (= (fail) Parse_<lsb>))
    (let Parse_<st_input1> (shen-<st_input1> Parse_<lsb>)
     (if (not (= (fail) Parse_<st_input1>))
      (let Parse_<rsb> (shen-<rsb> Parse_<st_input1>)
       (if (not (= (fail) Parse_<rsb>))
        (let Parse_<st_input2> (shen-<st_input2> Parse_<rsb>)
         (if (not (= (fail) Parse_<st_input2>))
          (shen-reassemble (fst Parse_<st_input2>)
           (cons (macroexpand (shen-cons_form (snd Parse_<st_input1>)))
            (snd Parse_<st_input2>)))
          (fail)))
        (fail)))
      (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<lrb> (shen-<lrb> V4614)
     (if (not (= (fail) Parse_<lrb>))
      (let Parse_<st_input1> (shen-<st_input1> Parse_<lrb>)
       (if (not (= (fail) Parse_<st_input1>))
        (let Parse_<rrb> (shen-<rrb> Parse_<st_input1>)
         (if (not (= (fail) Parse_<rrb>))
          (let Parse_<st_input2> (shen-<st_input2> Parse_<rrb>)
           (if (not (= (fail) Parse_<st_input2>))
            (shen-reassemble (fst Parse_<st_input2>)
             (shen-package-macro (macroexpand (snd Parse_<st_input1>))
              (snd Parse_<st_input2>)))
            (fail)))
          (fail)))
        (fail)))
      (fail)))
    (if (= Result (fail))
     (let Result
      (let Parse_<lcurly> (shen-<lcurly> V4614)
       (if (not (= (fail) Parse_<lcurly>))
        (let Parse_<st_input> (shen-<st_input> Parse_<lcurly>)
         (if (not (= (fail) Parse_<st_input>))
          (shen-reassemble (fst Parse_<st_input>)
           (cons { (snd Parse_<st_input>)))
          (fail)))
        (fail)))
      (if (= Result (fail))
       (let Result
        (let Parse_<rcurly> (shen-<rcurly> V4614)
         (if (not (= (fail) Parse_<rcurly>))
          (let Parse_<st_input> (shen-<st_input> Parse_<rcurly>)
           (if (not (= (fail) Parse_<st_input>))
            (shen-reassemble (fst Parse_<st_input>)
             (cons } (snd Parse_<st_input>)))
            (fail)))
          (fail)))
        (if (= Result (fail))
         (let Result
          (let Parse_<bar> (shen-<bar> V4614)
           (if (not (= (fail) Parse_<bar>))
            (let Parse_<st_input> (shen-<st_input> Parse_<bar>)
             (if (not (= (fail) Parse_<st_input>))
              (shen-reassemble (fst Parse_<st_input>)
               (cons bar! (snd Parse_<st_input>)))
              (fail)))
            (fail)))
          (if (= Result (fail))
           (let Result
            (let Parse_<semicolon> (shen-<semicolon> V4614)
             (if (not (= (fail) Parse_<semicolon>))
              (let Parse_<st_input> (shen-<st_input> Parse_<semicolon>)
               (if (not (= (fail) Parse_<st_input>))
                (shen-reassemble (fst Parse_<st_input>)
                 (cons ; (snd Parse_<st_input>)))
                (fail)))
              (fail)))
            (if (= Result (fail))
             (let Result
              (let Parse_<colon> (shen-<colon> V4614)
               (if (not (= (fail) Parse_<colon>))
                (let Parse_<equal> (shen-<equal> Parse_<colon>)
                 (if (not (= (fail) Parse_<equal>))
                  (let Parse_<st_input> (shen-<st_input> Parse_<equal>)
                   (if (not (= (fail) Parse_<st_input>))
                    (shen-reassemble (fst Parse_<st_input>)
                     (cons := (snd Parse_<st_input>)))
                    (fail)))
                  (fail)))
                (fail)))
              (if (= Result (fail))
               (let Result
                (let Parse_<colon> (shen-<colon> V4614)
                 (if (not (= (fail) Parse_<colon>))
                  (let Parse_<minus> (shen-<minus> Parse_<colon>)
                   (if (not (= (fail) Parse_<minus>))
                    (let Parse_<st_input> (shen-<st_input> Parse_<minus>)
                     (if (not (= (fail) Parse_<st_input>))
                      (shen-reassemble (fst Parse_<st_input>)
                       (cons :- (snd Parse_<st_input>)))
                      (fail)))
                    (fail)))
                  (fail)))
                (if (= Result (fail))
                 (let Result
                  (let Parse_<colon> (shen-<colon> V4614)
                   (if (not (= (fail) Parse_<colon>))
                    (let Parse_<st_input> (shen-<st_input> Parse_<colon>)
                     (if (not (= (fail) Parse_<st_input>))
                      (shen-reassemble (fst Parse_<st_input>)
                       (cons : (snd Parse_<st_input>)))
                      (fail)))
                    (fail)))
                  (if (= Result (fail))
                   (let Result
                    (let Parse_<comma> (shen-<comma> V4614)
                     (if (not (= (fail) Parse_<comma>))
                      (let Parse_<st_input> (shen-<st_input> Parse_<comma>)
                       (if (not (= (fail) Parse_<st_input>))
                        (shen-reassemble (fst Parse_<st_input>)
                         (cons shen- (snd Parse_<st_input>)))
                        (fail)))
                      (fail)))
                    (if (= Result (fail))
                     (let Result
                      (let Parse_<comment> (shen-<comment> V4614)
                       (if (not (= (fail) Parse_<comment>))
                        (let Parse_<st_input> (shen-<st_input> Parse_<comment>)
                         (if (not (= (fail) Parse_<st_input>))
                          (shen-reassemble (fst Parse_<st_input>)
                           (snd Parse_<st_input>))
                          (fail)))
                        (fail)))
                      (if (= Result (fail))
                       (let Result
                        (let Parse_<atom> (shen-<atom> V4614)
                         (if (not (= (fail) Parse_<atom>))
                          (let Parse_<st_input> (shen-<st_input> Parse_<atom>)
                           (if (not (= (fail) Parse_<st_input>))
                            (shen-reassemble (fst Parse_<st_input>)
                             (cons (macroexpand (snd Parse_<atom>))
                              (snd Parse_<st_input>)))
                            (fail)))
                          (fail)))
                        (if (= Result (fail))
                         (let Result
                          (let Parse_<whitespaces> (shen-<whitespaces> V4614)
                           (if (not (= (fail) Parse_<whitespaces>))
                            (let Parse_<st_input>
                             (shen-<st_input> Parse_<whitespaces>)
                             (if (not (= (fail) Parse_<st_input>))
                              (shen-reassemble (fst Parse_<st_input>)
                               (snd Parse_<st_input>))
                              (fail)))
                            (fail)))
                          (if (= Result (fail))
                           (let Result
                            (let Parse_<e> (<e> V4614)
                             (if (not (= (fail) Parse_<e>))
                              (shen-reassemble (fst Parse_<e>) ()) (fail)))
                            (if (= Result (fail)) (fail) Result))
                           Result))
                         Result))
                       Result))
                     Result))
                   Result))
                 Result))
               Result))
             Result))
           Result))
         Result))
       Result))
     Result))
   Result)))

(defun shen-<lsb> (V4615)
 (let Result
  (if (cons? (fst V4615))
   (shen-reassemble (fst (shen-reassemble (tl (fst V4615)) (snd V4615)))
    (if (= (hd (fst V4615)) 91) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<rsb> (V4616)
 (let Result
  (if (cons? (fst V4616))
   (shen-reassemble (fst (shen-reassemble (tl (fst V4616)) (snd V4616)))
    (if (= (hd (fst V4616)) 93) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<lcurly> (V4617)
 (let Result
  (if (cons? (fst V4617))
   (shen-reassemble (fst (shen-reassemble (tl (fst V4617)) (snd V4617)))
    (if (= (hd (fst V4617)) 123) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<rcurly> (V4618)
 (let Result
  (if (cons? (fst V4618))
   (shen-reassemble (fst (shen-reassemble (tl (fst V4618)) (snd V4618)))
    (if (= (hd (fst V4618)) 125) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<bar> (V4619)
 (let Result
  (if (cons? (fst V4619))
   (shen-reassemble (fst (shen-reassemble (tl (fst V4619)) (snd V4619)))
    (if (= (hd (fst V4619)) 124) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<semicolon> (V4620)
 (let Result
  (if (cons? (fst V4620))
   (shen-reassemble (fst (shen-reassemble (tl (fst V4620)) (snd V4620)))
    (if (= (hd (fst V4620)) 59) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<colon> (V4621)
 (let Result
  (if (cons? (fst V4621))
   (shen-reassemble (fst (shen-reassemble (tl (fst V4621)) (snd V4621)))
    (if (= (hd (fst V4621)) 58) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<comma> (V4622)
 (let Result
  (if (cons? (fst V4622))
   (shen-reassemble (fst (shen-reassemble (tl (fst V4622)) (snd V4622)))
    (if (= (hd (fst V4622)) 44) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<equal> (V4623)
 (let Result
  (if (cons? (fst V4623))
   (shen-reassemble (fst (shen-reassemble (tl (fst V4623)) (snd V4623)))
    (if (= (hd (fst V4623)) 61) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<minus> (V4624)
 (let Result
  (if (cons? (fst V4624))
   (shen-reassemble (fst (shen-reassemble (tl (fst V4624)) (snd V4624)))
    (if (= (hd (fst V4624)) 45) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<lrb> (V4625)
 (let Result
  (if (cons? (fst V4625))
   (shen-reassemble (fst (shen-reassemble (tl (fst V4625)) (snd V4625)))
    (if (= (hd (fst V4625)) 40) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<rrb> (V4626)
 (let Result
  (if (cons? (fst V4626))
   (shen-reassemble (fst (shen-reassemble (tl (fst V4626)) (snd V4626)))
    (if (= (hd (fst V4626)) 41) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<atom> (V4627)
 (let Result
  (let Parse_<str> (shen-<str> V4627)
   (if (not (= (fail) Parse_<str>))
    (shen-reassemble (fst Parse_<str>) (shen-control-chars (snd Parse_<str>)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<number> (shen-<number> V4627)
     (if (not (= (fail) Parse_<number>))
      (shen-reassemble (fst Parse_<number>) (snd Parse_<number>)) (fail)))
    (if (= Result (fail))
     (let Result
      (let Parse_<sym> (shen-<sym> V4627)
       (if (not (= (fail) Parse_<sym>))
        (shen-reassemble (fst Parse_<sym>) (snd Parse_<sym>)) (fail)))
      (if (= Result (fail)) (fail) Result))
     Result))
   Result)))

(defun shen-control-chars (V4628)
 (cond ((= () V4628) "")
  ((and (cons? V4628)
    (and (= "c" (hd V4628))
     (and (cons? (tl V4628)) (= "#" (hd (tl V4628))))))
   (let CodePoint (shen-code-point (tl (tl V4628)))
    (let AfterCodePoint (shen-after-codepoint (tl (tl V4628)))
     (@s (n->string (shen-decimalise CodePoint))
      (shen-control-chars AfterCodePoint)))))
  ((cons? V4628) (@s (hd V4628) (shen-control-chars (tl V4628))))
  (true (shen-sys-error shen-control-chars))))

(defun shen-code-point (V4631)
 (cond ((and (cons? V4631) (= ";" (hd V4631))) "")
  ((and (cons? V4631)
    (element? (hd V4631)
     (cons "0"
      (cons "1"
       (cons "2"
        (cons "3"
         (cons "4"
          (cons "5"
           (cons "6" (cons "7" (cons "8" (cons "9" (cons "0" ())))))))))))))
   (cons (hd V4631) (shen-code-point (tl V4631))))
  (true (interror "code point parse error ~A~%" (@p V4631 ())))))

(defun shen-after-codepoint (V4636)
 (cond ((= () V4636) ())
  ((and (cons? V4636) (= ";" (hd V4636))) (tl V4636))
  ((cons? V4636) (shen-after-codepoint (tl V4636)))
  (true (shen-sys-error shen-after-codepoint))))

(defun shen-decimalise (V4637)
 (shen-pre (reverse (shen-digits->integers V4637)) 0))

(defun shen-digits->integers (V4642)
 (cond
  ((and (cons? V4642) (= "0" (hd V4642)))
   (cons 0 (shen-digits->integers (tl V4642))))
  ((and (cons? V4642) (= "1" (hd V4642)))
   (cons 1 (shen-digits->integers (tl V4642))))
  ((and (cons? V4642) (= "2" (hd V4642)))
   (cons 2 (shen-digits->integers (tl V4642))))
  ((and (cons? V4642) (= "3" (hd V4642)))
   (cons 3 (shen-digits->integers (tl V4642))))
  ((and (cons? V4642) (= "4" (hd V4642)))
   (cons 4 (shen-digits->integers (tl V4642))))
  ((and (cons? V4642) (= "5" (hd V4642)))
   (cons 5 (shen-digits->integers (tl V4642))))
  ((and (cons? V4642) (= "6" (hd V4642)))
   (cons 6 (shen-digits->integers (tl V4642))))
  ((and (cons? V4642) (= "7" (hd V4642)))
   (cons 7 (shen-digits->integers (tl V4642))))
  ((and (cons? V4642) (= "8" (hd V4642)))
   (cons 8 (shen-digits->integers (tl V4642))))
  ((and (cons? V4642) (= "9" (hd V4642)))
   (cons 9 (shen-digits->integers (tl V4642))))
  (true ())))

(defun shen-<sym> (V4643)
 (let Result
  (let Parse_<alpha> (shen-<alpha> V4643)
   (if (not (= (fail) Parse_<alpha>))
    (let Parse_<symchars> (shen-<symchars> Parse_<alpha>)
     (if (not (= (fail) Parse_<symchars>))
      (shen-reassemble (fst Parse_<symchars>)
       (intern (cn (snd Parse_<alpha>) (snd Parse_<symchars>))))
      (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<alpha> (shen-<alpha> V4643)
     (if (not (= (fail) Parse_<alpha>))
      (shen-reassemble (fst Parse_<alpha>) (intern (snd Parse_<alpha>)))
      (fail)))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<symchars> (V4644)
 (let Result
  (let Parse_<symchar> (shen-<symchar> V4644)
   (if (not (= (fail) Parse_<symchar>))
    (let Parse_<symchars> (shen-<symchars> Parse_<symchar>)
     (if (not (= (fail) Parse_<symchars>))
      (shen-reassemble (fst Parse_<symchars>)
       (cn (snd Parse_<symchar>) (snd Parse_<symchars>)))
      (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<symchar> (shen-<symchar> V4644)
     (if (not (= (fail) Parse_<symchar>))
      (shen-reassemble (fst Parse_<symchar>) (snd Parse_<symchar>)) (fail)))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<symchar> (V4645)
 (let Result
  (let Parse_<alpha> (shen-<alpha> V4645)
   (if (not (= (fail) Parse_<alpha>))
    (shen-reassemble (fst Parse_<alpha>) (snd Parse_<alpha>)) (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<digit->string> (shen-<digit->string> V4645)
     (if (not (= (fail) Parse_<digit->string>))
      (shen-reassemble (fst Parse_<digit->string>) (snd Parse_<digit->string>))
      (fail)))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<digit->string> (V4646)
 (let Result
  (if (cons? (fst V4646))
   (shen-reassemble (fst (shen-reassemble (tl (fst V4646)) (snd V4646)))
    (if (shen-digit-byte? (hd (fst V4646))) (n->string (hd (fst V4646)))
     (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-digit-byte? (V4651)
 (cond ((= 48 V4651) true) ((= 49 V4651) true) ((= 50 V4651) true)
  ((= 51 V4651) true) ((= 52 V4651) true) ((= 53 V4651) true)
  ((= 54 V4651) true) ((= 55 V4651) true) ((= 56 V4651) true)
  ((= 57 V4651) true) (true false)))

(defun shen-<alpha> (V4652)
 (let Result
  (if (cons? (fst V4652))
   (shen-reassemble (fst (shen-reassemble (tl (fst V4652)) (snd V4652)))
    (let S (shen-symbol-byte->string (hd (fst V4652)))
     (if (= S (fail)) (fail) S)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-symbol-byte->string (V4653)
 (<-address (value shen-*symbolcodes*) V4653))

(defun shen-<str> (V4654)
 (let Result
  (let Parse_<dbq> (shen-<dbq> V4654)
   (if (not (= (fail) Parse_<dbq>))
    (let Parse_<strcontents> (shen-<strcontents> Parse_<dbq>)
     (if (not (= (fail) Parse_<strcontents>))
      (let Parse_<dbq> (shen-<dbq> Parse_<strcontents>)
       (if (not (= (fail) Parse_<dbq>))
        (shen-reassemble (fst Parse_<dbq>) (snd Parse_<strcontents>)) (fail)))
      (fail)))
    (fail)))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<dbq> (V4655)
 (let Result
  (if (cons? (fst V4655))
   (shen-reassemble (fst (shen-reassemble (tl (fst V4655)) (snd V4655)))
    (if (= (hd (fst V4655)) 34) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<strcontents> (V4656)
 (let Result
  (let Parse_<strc> (shen-<strc> V4656)
   (if (not (= (fail) Parse_<strc>))
    (let Parse_<strcontents> (shen-<strcontents> Parse_<strc>)
     (if (not (= (fail) Parse_<strcontents>))
      (shen-reassemble (fst Parse_<strcontents>)
       (cons (snd Parse_<strc>) (snd Parse_<strcontents>)))
      (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<e> (<e> V4656)
     (if (not (= (fail) Parse_<e>)) (shen-reassemble (fst Parse_<e>) ())
      (fail)))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<byte> (V4657)
 (let Result
  (if (cons? (fst V4657))
   (shen-reassemble (fst (shen-reassemble (tl (fst V4657)) (snd V4657)))
    (n->string (hd (fst V4657))))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<strc> (V4658)
 (let Result
  (if (cons? (fst V4658))
   (shen-reassemble (fst (shen-reassemble (tl (fst V4658)) (snd V4658)))
    (if (= (hd (fst V4658)) 34) (fail) (n->string (hd (fst V4658)))))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<backslash> (V4659)
 (let Result
  (if (cons? (fst V4659))
   (shen-reassemble (fst (shen-reassemble (tl (fst V4659)) (snd V4659)))
    (if (= (hd (fst V4659)) 92) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<number> (V4660)
 (let Result
  (let Parse_<minus> (shen-<minus> V4660)
   (if (not (= (fail) Parse_<minus>))
    (let Parse_<number> (shen-<number> Parse_<minus>)
     (if (not (= (fail) Parse_<number>))
      (shen-reassemble (fst Parse_<number>) (- 0 (snd Parse_<number>)))
      (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<plus> (shen-<plus> V4660)
     (if (not (= (fail) Parse_<plus>))
      (let Parse_<number> (shen-<number> Parse_<plus>)
       (if (not (= (fail) Parse_<number>))
        (shen-reassemble (fst Parse_<number>) (snd Parse_<number>)) (fail)))
      (fail)))
    (if (= Result (fail))
     (let Result
      (let Parse_<predigits> (shen-<predigits> V4660)
       (if (not (= (fail) Parse_<predigits>))
        (let Parse_<stop> (shen-<stop> Parse_<predigits>)
         (if (not (= (fail) Parse_<stop>))
          (let Parse_<postdigits> (shen-<postdigits> Parse_<stop>)
           (if (not (= (fail) Parse_<postdigits>))
            (let Parse_<E> (shen-<E> Parse_<postdigits>)
             (if (not (= (fail) Parse_<E>))
              (let Parse_<log10> (shen-<log10> Parse_<E>)
               (if (not (= (fail) Parse_<log10>))
                (shen-reassemble (fst Parse_<log10>)
                 (* (shen-expt 10 (snd Parse_<log10>))
                  (+ (shen-pre (reverse (snd Parse_<predigits>)) 0)
                   (shen-post (snd Parse_<postdigits>) 1))))
                (fail)))
              (fail)))
            (fail)))
          (fail)))
        (fail)))
      (if (= Result (fail))
       (let Result
        (let Parse_<digits> (shen-<digits> V4660)
         (if (not (= (fail) Parse_<digits>))
          (let Parse_<E> (shen-<E> Parse_<digits>)
           (if (not (= (fail) Parse_<E>))
            (let Parse_<log10> (shen-<log10> Parse_<E>)
             (if (not (= (fail) Parse_<log10>))
              (shen-reassemble (fst Parse_<log10>)
               (* (shen-expt 10 (snd Parse_<log10>))
                (shen-pre (reverse (snd Parse_<digits>)) 0)))
              (fail)))
            (fail)))
          (fail)))
        (if (= Result (fail))
         (let Result
          (let Parse_<predigits> (shen-<predigits> V4660)
           (if (not (= (fail) Parse_<predigits>))
            (let Parse_<stop> (shen-<stop> Parse_<predigits>)
             (if (not (= (fail) Parse_<stop>))
              (let Parse_<postdigits> (shen-<postdigits> Parse_<stop>)
               (if (not (= (fail) Parse_<postdigits>))
                (shen-reassemble (fst Parse_<postdigits>)
                 (+ (shen-pre (reverse (snd Parse_<predigits>)) 0)
                  (shen-post (snd Parse_<postdigits>) 1)))
                (fail)))
              (fail)))
            (fail)))
          (if (= Result (fail))
           (let Result
            (let Parse_<digits> (shen-<digits> V4660)
             (if (not (= (fail) Parse_<digits>))
              (shen-reassemble (fst Parse_<digits>)
               (shen-pre (reverse (snd Parse_<digits>)) 0))
              (fail)))
            (if (= Result (fail)) (fail) Result))
           Result))
         Result))
       Result))
     Result))
   Result)))

(defun shen-<E> (V4661)
 (let Result
  (if (and (cons? (fst V4661)) (= 101 (hd (fst V4661))))
   (shen-reassemble (fst (shen-reassemble (tl (fst V4661)) (snd V4661)))
    (cons 101 ()))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<log10> (V4662)
 (let Result
  (let Parse_<minus> (shen-<minus> V4662)
   (if (not (= (fail) Parse_<minus>))
    (let Parse_<digits> (shen-<digits> Parse_<minus>)
     (if (not (= (fail) Parse_<digits>))
      (shen-reassemble (fst Parse_<digits>)
       (- 0 (shen-pre (reverse (snd Parse_<digits>)) 0)))
      (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<digits> (shen-<digits> V4662)
     (if (not (= (fail) Parse_<digits>))
      (shen-reassemble (fst Parse_<digits>)
       (shen-pre (reverse (snd Parse_<digits>)) 0))
      (fail)))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<plus> (V4663)
 (let Result
  (if (cons? (fst V4663))
   (shen-reassemble (fst (shen-reassemble (tl (fst V4663)) (snd V4663)))
    (if (= (hd (fst V4663)) 43) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<stop> (V4664)
 (let Result
  (if (cons? (fst V4664))
   (shen-reassemble (fst (shen-reassemble (tl (fst V4664)) (snd V4664)))
    (if (= (hd (fst V4664)) 46) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<predigits> (V4665)
 (let Result
  (let Parse_<digits> (shen-<digits> V4665)
   (if (not (= (fail) Parse_<digits>))
    (shen-reassemble (fst Parse_<digits>) (snd Parse_<digits>)) (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<e> (<e> V4665)
     (if (not (= (fail) Parse_<e>)) (shen-reassemble (fst Parse_<e>) ())
      (fail)))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<postdigits> (V4666)
 (let Result
  (let Parse_<digits> (shen-<digits> V4666)
   (if (not (= (fail) Parse_<digits>))
    (shen-reassemble (fst Parse_<digits>) (snd Parse_<digits>)) (fail)))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<digits> (V4667)
 (let Result
  (let Parse_<digit> (shen-<digit> V4667)
   (if (not (= (fail) Parse_<digit>))
    (let Parse_<digits> (shen-<digits> Parse_<digit>)
     (if (not (= (fail) Parse_<digits>))
      (shen-reassemble (fst Parse_<digits>)
       (cons (snd Parse_<digit>) (snd Parse_<digits>)))
      (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<digit> (shen-<digit> V4667)
     (if (not (= (fail) Parse_<digit>))
      (shen-reassemble (fst Parse_<digit>) (cons (snd Parse_<digit>) ()))
      (fail)))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<digit> (V4668)
 (let Result
  (if (cons? (fst V4668))
   (shen-reassemble (fst (shen-reassemble (tl (fst V4668)) (snd V4668)))
    (if (shen-digit-byte? (hd (fst V4668))) (shen-byte->digit (hd (fst V4668)))
     (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-byte->digit (V4669)
 (cond ((= 48 V4669) 0) ((= 49 V4669) 1) ((= 50 V4669) 2)
  ((= 51 V4669) 3) ((= 52 V4669) 4) ((= 53 V4669) 5)
  ((= 54 V4669) 6) ((= 55 V4669) 7) ((= 56 V4669) 8)
  ((= 57 V4669) 9) (true (shen-sys-error shen-byte->digit))))

(defun shen-pre (V4672 V4673)
 (cond ((= () V4672) 0)
  ((cons? V4672)
   (+ (* (shen-expt 10 V4673) (hd V4672)) (shen-pre (tl V4672) (+ V4673 1))))
  (true (shen-sys-error shen-pre))))

(defun shen-post (V4676 V4677)
 (cond ((= () V4676) 0)
  ((cons? V4676)
   (+ (* (shen-expt 10 (- 0 V4677)) (hd V4676))
    (shen-post (tl V4676) (+ V4677 1))))
  (true (shen-sys-error shen-post))))

(defun shen-expt (V4680 V4681)
 (cond ((= 0 V4681) 1)
  ((> V4681 0) (* V4680 (shen-expt V4680 (- V4681 1))))
  (true (* 1.0 (/ (shen-expt V4680 (+ V4681 1)) V4680)))))

(defun shen-<st_input1> (V4682)
 (let Result
  (let Parse_<st_input> (shen-<st_input> V4682)
   (if (not (= (fail) Parse_<st_input>))
    (shen-reassemble (fst Parse_<st_input>) (snd Parse_<st_input>)) (fail)))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<st_input2> (V4683)
 (let Result
  (let Parse_<st_input> (shen-<st_input> V4683)
   (if (not (= (fail) Parse_<st_input>))
    (shen-reassemble (fst Parse_<st_input>) (snd Parse_<st_input>)) (fail)))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<comment> (V4684)
 (let Result
  (let Parse_<backslash> (shen-<backslash> V4684)
   (if (not (= (fail) Parse_<backslash>))
    (let Parse_<times> (shen-<times> Parse_<backslash>)
     (if (not (= (fail) Parse_<times>))
      (let Parse_<any> (shen-<any> Parse_<times>)
       (if (not (= (fail) Parse_<any>))
        (let Parse_<times> (shen-<times> Parse_<any>)
         (if (not (= (fail) Parse_<times>))
          (let Parse_<backslash> (shen-<backslash> Parse_<times>)
           (if (not (= (fail) Parse_<backslash>))
            (shen-reassemble (fst Parse_<backslash>) shen-skip) (fail)))
          (fail)))
        (fail)))
      (fail)))
    (fail)))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<times> (V4685)
 (let Result
  (if (cons? (fst V4685))
   (shen-reassemble (fst (shen-reassemble (tl (fst V4685)) (snd V4685)))
    (if (= (hd (fst V4685)) 42) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<any> (V4686)
 (let Result
  (let Parse_<comment> (shen-<comment> V4686)
   (if (not (= (fail) Parse_<comment>))
    (let Parse_<any> (shen-<any> Parse_<comment>)
     (if (not (= (fail) Parse_<any>))
      (shen-reassemble (fst Parse_<any>) shen-skip) (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<blah> (shen-<blah> V4686)
     (if (not (= (fail) Parse_<blah>))
      (let Parse_<any> (shen-<any> Parse_<blah>)
       (if (not (= (fail) Parse_<any>))
        (shen-reassemble (fst Parse_<any>) shen-skip) (fail)))
      (fail)))
    (if (= Result (fail))
     (let Result
      (let Parse_<e> (<e> V4686)
       (if (not (= (fail) Parse_<e>))
        (shen-reassemble (fst Parse_<e>) shen-skip) (fail)))
      (if (= Result (fail)) (fail) Result))
     Result))
   Result)))

(defun shen-<blah> (V4687)
 (let Result
  (if (cons? (fst V4687))
   (shen-reassemble (fst (shen-reassemble (tl (fst V4687)) (snd V4687)))
    (if (shen-end-of-comment? (fst V4687)) (fail) shen-skip))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-end-of-comment? (V4694)
 (cond
  ((and (cons? V4694)
    (and (= 42 (hd V4694))
     (and (cons? (tl V4694)) (= 92 (hd (tl V4694))))))
   true)
  (true false)))

(defun shen-<whitespaces> (V4695)
 (let Result
  (let Parse_<whitespace> (shen-<whitespace> V4695)
   (if (not (= (fail) Parse_<whitespace>))
    (let Parse_<whitespaces> (shen-<whitespaces> Parse_<whitespace>)
     (if (not (= (fail) Parse_<whitespaces>))
      (shen-reassemble (fst Parse_<whitespaces>) shen-skip) (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<whitespace> (shen-<whitespace> V4695)
     (if (not (= (fail) Parse_<whitespace>))
      (shen-reassemble (fst Parse_<whitespace>) shen-skip) (fail)))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<whitespace> (V4696)
 (let Result
  (if (cons? (fst V4696))
   (shen-reassemble (fst (shen-reassemble (tl (fst V4696)) (snd V4696)))
    (let Case (hd (fst V4696))
     (if (= Case 32) shen-skip
      (if (= Case 13) shen-skip
       (if (= Case 10) shen-skip (if (= Case 9) shen-skip (fail)))))))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-cons_form (V4697)
 (cond ((= () V4697) ())
  ((and (cons? V4697)
    (and (cons? (tl V4697))
     (and (= bar! (hd (tl V4697)))
      (and (cons? (tl (tl V4697))) (= () (tl (tl (tl V4697))))))))
   (cons cons (cons (hd V4697) (tl (tl V4697)))))
  ((cons? V4697)
   (cons cons (cons (hd V4697) (cons (shen-cons_form (tl V4697)) ()))))
  (true (shen-sys-error shen-cons_form))))

(defun shen-package-macro (V4700 V4701)
 (cond
  ((and (cons? V4700)
    (and (= package (hd V4700))
     (and (cons? (tl V4700))
      (and (= null (hd (tl V4700))) (cons? (tl (tl V4700)))))))
   (append (tl (tl (tl V4700))) V4701))
  ((and (cons? V4700)
    (and (= package (hd V4700))
     (and (cons? (tl V4700)) (cons? (tl (tl V4700))))))
   (let ListofExceptions (shen-eval-without-macros (hd (tl (tl V4700))))
    (let Record (shen-record-exceptions ListofExceptions (hd (tl V4700)))
     (append
      (shen-packageh (hd (tl V4700)) ListofExceptions (tl (tl (tl V4700))))
      V4701))))
  (true (cons V4700 V4701))))

(defun shen-record-exceptions (V4702 V4703)
 (let CurrExceptions
  (trap-error (get V4703 shen-external-symbols (value shen-*property-vector*))
   (lambda E ()))
  (let AllExceptions (union V4702 CurrExceptions)
   (put V4703 shen-external-symbols AllExceptions
    (value shen-*property-vector*)))))

(defun shen-packageh (V4712 V4713 V4714)
 (cond
  ((cons? V4714)
   (cons (shen-packageh V4712 V4713 (hd V4714))
    (shen-packageh V4712 V4713 (tl V4714))))
  ((or (shen-sysfunc? V4714)
    (or (variable? V4714)
     (or (element? V4714 V4713)
      (or (shen-doubleunderline? V4714) (shen-singleunderline? V4714)))))
   V4714)
  ((and (symbol? V4714)
    (not
     (shen-prefix? (cons "s" (cons "h" (cons "e" (cons "n" (cons "-" ())))))
      (explode V4714))))
   (concat V4712 V4714))
  (true V4714)))

