
"                                                   The License
 
 The user is free to produce commercial applications with the software, to distribute these applications in source or binary  form, and to charge monies for them as he sees fit and in concordance with the laws of the land subject to the following  license.
 
 1. The license applies to all the software and all derived software and must appear on such.
 2. It is illegal to distribute the software without this license attached to it and use of the software implies agreement 
    with the license as such. It is illegal for anyone who is not the copyright holder to tamper with or change the license.
 3. Neither the names of Lambda Associates or the copyright holder may be used to endorse or promote products built using
     the software without specific prior written permission from the copyright holder.
 4. That possession of this license does not confer on the copyright holder any special contractual obligation towards the    user. That in no event shall the copyright holder be liable for any direct, indirect, incidental, special, exemplary or   consequential damages (including but not limited to procurement of substitute goods or services, loss of use, data, or    profits; or business interruption), however caused and on any theory of liability, whether in contract, strict liability   or tort (including negligence) arising in any way out of the use of the software, even if advised of the possibility of   such damage. 
5. It is permitted for the user to change the software, for the purpose of improving performance, correcting an error, or    porting to a new platform, and distribute the modified version of Shen (hereafter the modified version) provided the     resulting program conforms in all respects to the Shen standard and is issued under that title. The user must make it clear   with his distribution that he/she is the author of the changes and what these changes are and why. 
6. Derived versions of this software in whatever form are subject to the same restrictions. In particular it is not          permitted to make derived copies of this software which do not conform to the Shen standard or appear under a different title.
7. It is permitted to distribute versions of Shen which incorporate libraries, graphics or other facilities which are not    part of the Shen standard.

For an explication of this license see http://www.lambdassociates.org/News/june11/license.htm which explains this license in full."

(defun shen-<defprolog> (V1127)
 (let Result
  (let Parse_<predicate*> (shen-<predicate*> V1127)
   (if (not (= (fail) Parse_<predicate*>))
    (let Parse_<clauses*> (shen-<clauses*> Parse_<predicate*>)
     (if (not (= (fail) Parse_<clauses*>))
      (shen-reassemble (fst Parse_<clauses*>)
       (hd
        (shen-prolog->shen
         (map (lambda X (shen-insert-predicate (snd Parse_<predicate*>) X))
          (snd Parse_<clauses*>)))))
      (fail)))
    (fail)))
  (if (= Result (fail)) (fail) Result)))

(defun shen-prolog-error (V1128 V1129)
 (interror "prolog syntax error in ~A here:~%~% ~A~%"
  (@p V1128 (@p (shen-next-50 50 V1129) ()))))

(defun shen-next-50 (V1134 V1135)
 (cond ((= () V1135) "") ((= 0 V1134) "")
  ((cons? V1135)
   (cn (shen-decons-string (hd V1135)) (shen-next-50 (- V1134 1) (tl V1135))))
  (true (shen-sys-error shen-next-50))))

(defun shen-decons-string (V1136)
 (cond
  ((and (cons? V1136)
    (and (= cons (hd V1136))
     (and (cons? (tl V1136))
      (and (cons? (tl (tl V1136))) (= () (tl (tl (tl V1136))))))))
   (intmake-string "~S " (@p (shen-eval-cons V1136) ())))
  (true (intmake-string "~R " (@p V1136 ())))))

(defun shen-insert-predicate (V1137 V1138)
 (cond
  ((and (cons? V1138) (and (cons? (tl V1138)) (= () (tl (tl V1138)))))
   (cons (cons V1137 (hd V1138)) (cons :- (tl V1138))))
  (true (shen-sys-error shen-insert-predicate))))

(defun shen-<predicate*> (V1139)
 (let Result
  (if (cons? (fst V1139))
   (shen-reassemble (fst (shen-reassemble (tl (fst V1139)) (snd V1139)))
    (hd (fst V1139)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<clauses*> (V1140)
 (let Result
  (let Parse_<clause*> (shen-<clause*> V1140)
   (if (not (= (fail) Parse_<clause*>))
    (let Parse_<clauses*> (shen-<clauses*> Parse_<clause*>)
     (if (not (= (fail) Parse_<clauses*>))
      (shen-reassemble (fst Parse_<clauses*>)
       (cons (snd Parse_<clause*>) (snd Parse_<clauses*>)))
      (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<e> (<e> V1140)
     (if (not (= (fail) Parse_<e>))
      (shen-reassemble (fst Parse_<e>) (snd Parse_<e>)) (fail)))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<clause*> (V1141)
 (let Result
  (let Parse_<head*> (shen-<head*> V1141)
   (if (not (= (fail) Parse_<head*>))
    (if (and (cons? (fst Parse_<head*>)) (= <-- (hd (fst Parse_<head*>))))
     (let Parse_<body*>
      (shen-<body*>
       (shen-reassemble (tl (fst Parse_<head*>)) (snd Parse_<head*>)))
      (if (not (= (fail) Parse_<body*>))
       (let Parse_<end*> (shen-<end*> Parse_<body*>)
        (if (not (= (fail) Parse_<end*>))
         (shen-reassemble (fst Parse_<end*>)
          (cons (snd Parse_<head*>) (cons (snd Parse_<body*>) ())))
         (fail)))
       (fail)))
     (fail))
    (fail)))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<head*> (V1142)
 (let Result
  (let Parse_<term*> (shen-<term*> V1142)
   (if (not (= (fail) Parse_<term*>))
    (let Parse_<head*> (shen-<head*> Parse_<term*>)
     (if (not (= (fail) Parse_<head*>))
      (shen-reassemble (fst Parse_<head*>)
       (cons (snd Parse_<term*>) (snd Parse_<head*>)))
      (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<e> (<e> V1142)
     (if (not (= (fail) Parse_<e>))
      (shen-reassemble (fst Parse_<e>) (snd Parse_<e>)) (fail)))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<term*> (V1143)
 (let Result
  (if (cons? (fst V1143))
   (shen-reassemble (fst (shen-reassemble (tl (fst V1143)) (snd V1143)))
    (if
     (and (not (= <-- (hd (fst V1143))))
      (shen-legitimate-term? (hd (fst V1143))))
     (shen-eval-cons (hd (fst V1143))) (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-legitimate-term? (V1148)
 (cond
  ((and (cons? V1148)
    (and (= cons (hd V1148))
     (and (cons? (tl V1148))
      (and (cons? (tl (tl V1148))) (= () (tl (tl (tl V1148))))))))
   (and (shen-legitimate-term? (hd (tl V1148)))
    (shen-legitimate-term? (hd (tl (tl V1148))))))
  ((and (cons? V1148)
    (and (= mode (hd V1148))
     (and (cons? (tl V1148))
      (and (cons? (tl (tl V1148)))
       (and (= + (hd (tl (tl V1148)))) (= () (tl (tl (tl V1148)))))))))
   (shen-legitimate-term? (hd (tl V1148))))
  ((and (cons? V1148)
    (and (= mode (hd V1148))
     (and (cons? (tl V1148))
      (and (cons? (tl (tl V1148)))
       (and (= - (hd (tl (tl V1148)))) (= () (tl (tl (tl V1148)))))))))
   (shen-legitimate-term? (hd (tl V1148))))
  ((cons? V1148) false) (true true)))

(defun shen-eval-cons (V1149)
 (cond
  ((and (cons? V1149)
    (and (= cons (hd V1149))
     (and (cons? (tl V1149))
      (and (cons? (tl (tl V1149))) (= () (tl (tl (tl V1149))))))))
   (cons (shen-eval-cons (hd (tl V1149)))
    (shen-eval-cons (hd (tl (tl V1149))))))
  ((and (cons? V1149)
    (and (= mode (hd V1149))
     (and (cons? (tl V1149))
      (and (cons? (tl (tl V1149))) (= () (tl (tl (tl V1149))))))))
   (cons mode (cons (shen-eval-cons (hd (tl V1149))) (tl (tl V1149)))))
  (true V1149)))

(defun shen-<body*> (V1150)
 (let Result
  (let Parse_<literal*> (shen-<literal*> V1150)
   (if (not (= (fail) Parse_<literal*>))
    (let Parse_<body*> (shen-<body*> Parse_<literal*>)
     (if (not (= (fail) Parse_<body*>))
      (shen-reassemble (fst Parse_<body*>)
       (cons (snd Parse_<literal*>) (snd Parse_<body*>)))
      (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<e> (<e> V1150)
     (if (not (= (fail) Parse_<e>))
      (shen-reassemble (fst Parse_<e>) (snd Parse_<e>)) (fail)))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<literal*> (V1151)
 (let Result
  (if (and (cons? (fst V1151)) (= ! (hd (fst V1151))))
   (shen-reassemble (fst (shen-reassemble (tl (fst V1151)) (snd V1151)))
    (cons cut (cons Throwcontrol ())))
   (fail))
  (if (= Result (fail))
   (let Result
    (if (cons? (fst V1151))
     (shen-reassemble (fst (shen-reassemble (tl (fst V1151)) (snd V1151)))
      (if (cons? (hd (fst V1151))) (hd (fst V1151)) (fail)))
     (fail))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<end*> (V1152)
 (let Result
  (if (cons? (fst V1152))
   (shen-reassemble (fst (shen-reassemble (tl (fst V1152)) (snd V1152)))
    (if (= (hd (fst V1152)) ;) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun cut (V1153 V1154 V1155)
 (let Result (thaw V1155) (if (= Result false) V1153 Result)))

(defun shen-insert_modes (V1156)
 (cond
  ((and (cons? V1156)
    (and (= mode (hd V1156))
     (and (cons? (tl V1156))
      (and (cons? (tl (tl V1156))) (= () (tl (tl (tl V1156))))))))
   V1156)
  ((= () V1156) ())
  ((cons? V1156)
   (cons (cons mode (cons (hd V1156) (cons + ())))
    (cons mode (cons (shen-insert_modes (tl V1156)) (cons - ())))))
  (true V1156)))

(defun shen-s-prolog (V1157)
 (map (lambda V1158 (eval V1158)) (shen-prolog->shen V1157)))

(defun shen-prolog->shen (V1159)
 (map (lambda V1160 (shen-compile_prolog_procedure V1160))
  (shen-group_clauses
   (map (lambda V1161 (shen-s-prolog_clause V1161))
    (mapcan (lambda V1162 (shen-head_abstraction V1162)) V1159)))))

(defun shen-s-prolog_clause (V1163)
 (cond
  ((and (cons? V1163)
    (and (cons? (tl V1163))
     (and (= :- (hd (tl V1163)))
      (and (cons? (tl (tl V1163))) (= () (tl (tl (tl V1163))))))))
   (cons (hd V1163)
    (cons :-
     (cons
      (map (lambda V1164 (shen-s-prolog_literal V1164)) (hd (tl (tl V1163))))
      ()))))
  (true (shen-sys-error shen-s-prolog_clause))))

(defun shen-head_abstraction (V1165)
 (cond
  ((and (cons? V1165)
    (and (cons? (tl V1165))
     (and (= :- (hd (tl V1165)))
      (and (cons? (tl (tl V1165)))
       (and (= () (tl (tl (tl V1165))))
        (< (shen-complexity_head (hd V1165))
         (value shen-*maxcomplexity*)))))))
   (cons V1165 ()))
  ((and (cons? V1165)
    (and (cons? (hd V1165))
     (and (cons? (tl V1165))
      (and (= :- (hd (tl V1165)))
       (and (cons? (tl (tl V1165))) (= () (tl (tl (tl V1165)))))))))
   (let Terms (map (lambda Y (gensym V)) (tl (hd V1165)))
    (let XTerms (shen-rcons_form (shen-remove_modes (tl (hd V1165))))
     (let Literal (cons unify (cons (shen-cons_form Terms) (cons XTerms ())))
      (let Clause
       (cons (cons (hd (hd V1165)) Terms)
        (cons :- (cons (cons Literal (hd (tl (tl V1165)))) ())))
       (cons Clause ()))))))
  (true (shen-sys-error shen-head_abstraction))))

(defun shen-complexity_head (V1170)
 (cond
  ((cons? V1170)
   (shen-product (map (lambda V1171 (shen-complexity V1171)) (tl V1170))))
  (true (shen-sys-error shen-complexity_head))))

(defun shen-complexity (V1179)
 (cond
  ((and (cons? V1179)
    (and (= mode (hd V1179))
     (and (cons? (tl V1179))
      (and (cons? (hd (tl V1179)))
       (and (= mode (hd (hd (tl V1179))))
        (and (cons? (tl (hd (tl V1179))))
         (and (cons? (tl (tl (hd (tl V1179)))))
          (and (= () (tl (tl (tl (hd (tl V1179))))))
           (and (cons? (tl (tl V1179)))
            (= () (tl (tl (tl V1179)))))))))))))
   (shen-complexity (hd (tl V1179))))
  ((and (cons? V1179)
    (and (= mode (hd V1179))
     (and (cons? (tl V1179))
      (and (cons? (hd (tl V1179)))
       (and (cons? (tl (tl V1179)))
        (and (= + (hd (tl (tl V1179))))
         (= () (tl (tl (tl V1179))))))))))
   (* 2
    (*
     (shen-complexity (cons mode (cons (hd (hd (tl V1179))) (tl (tl V1179)))))
     (shen-complexity
      (cons mode (cons (tl (hd (tl V1179))) (tl (tl V1179))))))))
  ((and (cons? V1179)
    (and (= mode (hd V1179))
     (and (cons? (tl V1179))
      (and (cons? (hd (tl V1179)))
       (and (cons? (tl (tl V1179)))
        (and (= - (hd (tl (tl V1179))))
         (= () (tl (tl (tl V1179))))))))))
   (* (shen-complexity (cons mode (cons (hd (hd (tl V1179))) (tl (tl V1179)))))
    (shen-complexity (cons mode (cons (tl (hd (tl V1179))) (tl (tl V1179)))))))
  ((and (cons? V1179)
    (and (= mode (hd V1179))
     (and (cons? (tl V1179))
      (and (cons? (tl (tl V1179)))
       (and (= () (tl (tl (tl V1179)))) (variable? (hd (tl V1179))))))))
   1)
  ((and (cons? V1179)
    (and (= mode (hd V1179))
     (and (cons? (tl V1179))
      (and (cons? (tl (tl V1179)))
       (and (= + (hd (tl (tl V1179)))) (= () (tl (tl (tl V1179)))))))))
   2)
  ((and (cons? V1179)
    (and (= mode (hd V1179))
     (and (cons? (tl V1179))
      (and (cons? (tl (tl V1179)))
       (and (= - (hd (tl (tl V1179)))) (= () (tl (tl (tl V1179)))))))))
   1)
  (true (shen-complexity (cons mode (cons V1179 (cons + ())))))))

(defun shen-product (V1180)
 (cond ((= () V1180) 1)
  ((cons? V1180) (* (hd V1180) (shen-product (tl V1180))))
  (true (shen-sys-error shen-product))))

(defun shen-s-prolog_literal (V1181)
 (cond
  ((and (cons? V1181)
    (and (= is (hd V1181))
     (and (cons? (tl V1181))
      (and (cons? (tl (tl V1181))) (= () (tl (tl (tl V1181))))))))
   (cons bind
    (cons (hd (tl V1181))
     (cons (shen-insert_deref (hd (tl (tl V1181)))) ()))))
  ((and (cons? V1181)
    (and (= when (hd V1181))
     (and (cons? (tl V1181)) (= () (tl (tl V1181))))))
   (cons fwhen (cons (shen-insert_deref (hd (tl V1181))) ())))
  ((and (cons? V1181)
    (and (= bind (hd V1181))
     (and (cons? (tl V1181))
      (and (cons? (tl (tl V1181))) (= () (tl (tl (tl V1181))))))))
   (cons bind
    (cons (hd (tl V1181))
     (cons (shen-insert_lazyderef (hd (tl (tl V1181)))) ()))))
  ((and (cons? V1181)
    (and (= fwhen (hd V1181))
     (and (cons? (tl V1181)) (= () (tl (tl V1181))))))
   (cons fwhen (cons (shen-insert_lazyderef (hd (tl V1181))) ())))
  ((cons? V1181)
   (cons (shen-m_prolog_to_s-prolog_predicate (hd V1181)) (tl V1181)))
  (true (shen-sys-error shen-s-prolog_literal))))

(defun shen-insert_deref (V1182)
 (cond ((variable? V1182) (cons shen-deref (cons V1182 (cons ProcessN ()))))
  ((cons? V1182)
   (cons (shen-insert_deref (hd V1182)) (shen-insert_deref (tl V1182))))
  (true V1182)))

(defun shen-insert_lazyderef (V1183)
 (cond
  ((variable? V1183) (cons shen-lazyderef (cons V1183 (cons ProcessN ()))))
  ((cons? V1183)
   (cons (shen-insert_lazyderef (hd V1183))
    (shen-insert_lazyderef (tl V1183))))
  (true V1183)))

(defun shen-m_prolog_to_s-prolog_predicate (V1184)
 (cond ((= = V1184) unify) ((= =! V1184) unify!)
  ((= == V1184) identical) (true V1184)))

(defun shen-group_clauses (V1185)
 (cond ((= () V1185) ())
  ((cons? V1185)
   (let Group
    (shen-collect (lambda X (shen-same_predicate? (hd V1185) X)) V1185)
    (let Rest (difference V1185 Group)
     (cons Group (shen-group_clauses Rest)))))
  (true (shen-sys-error shen-group_clauses))))

(defun shen-collect (V1188 V1189)
 (cond ((= () V1189) ())
  ((cons? V1189)
   (if (V1188 (hd V1189)) (cons (hd V1189) (shen-collect V1188 (tl V1189)))
    (shen-collect V1188 (tl V1189))))
  (true (shen-sys-error shen-collect))))

(defun shen-same_predicate? (V1206 V1207)
 (cond
  ((and (cons? V1206)
    (and (cons? (hd V1206)) (and (cons? V1207) (cons? (hd V1207)))))
   (= (hd (hd V1206)) (hd (hd V1207))))
  (true (shen-sys-error shen-same_predicate?))))

(defun shen-compile_prolog_procedure (V1208)
 (let F (shen-procedure_name V1208)
  (let Shen (shen-clauses-to-shen F V1208) Shen)))

(defun shen-procedure_name (V1221)
 (cond
  ((and (cons? V1221) (and (cons? (hd V1221)) (cons? (hd (hd V1221)))))
   (hd (hd (hd V1221))))
  (true (shen-sys-error shen-procedure_name))))

(defun shen-clauses-to-shen (V1222 V1223)
 (let Linear (map (lambda V1224 (shen-linearise-clause V1224)) V1223)
  (let Arity
   (shen-prolog-aritycheck V1222 (map (lambda V1225 (head V1225)) V1223))
   (let Parameters (shen-parameters Arity)
    (let AUM_instructions (map (lambda X (shen-aum X Parameters)) Linear)
     (let Code
      (shen-catch-cut
       (shen-nest-disjunct
        (map (lambda V1226 (shen-aum_to_shen V1226)) AUM_instructions)))
      (let ShenDef
       (cons define
        (cons V1222
         (append Parameters
          (append (cons ProcessN (cons Continuation ()))
           (cons -> (cons Code ()))))))
       ShenDef)))))))

(defun shen-catch-cut (V1227)
 (cond ((not (shen-occurs? cut V1227)) V1227)
  (true
   (cons let
    (cons Throwcontrol
     (cons (cons shen-catchpoint ())
      (cons (cons shen-cutpoint (cons Throwcontrol (cons V1227 ())))
       ())))))))

(defun shen-catchpoint () (set shen-*catch* (+ 1 (value shen-*catch*))))

(defun shen-cutpoint (V1232 V1233)
 (cond ((= V1233 V1232) false) (true V1233)))

(defun shen-nest-disjunct (V1235)
 (cond ((and (cons? V1235) (= () (tl V1235))) (hd V1235))
  ((cons? V1235) (shen-lisp-or (hd V1235) (shen-nest-disjunct (tl V1235))))
  (true (shen-sys-error shen-nest-disjunct))))

(defun shen-lisp-or (V1236 V1237)
 (cons let
  (cons Case
   (cons V1236
    (cons
     (cons if
      (cons (cons = (cons Case (cons false ())))
       (cons V1237 (cons Case ()))))
     ())))))

(defun shen-prolog-aritycheck (V1240 V1241)
 (cond ((and (cons? V1241) (= () (tl V1241))) (- (length (hd V1241)) 1))
  ((and (cons? V1241) (cons? (tl V1241)))
   (if (= (length (hd V1241)) (length (hd (tl V1241))))
    (shen-prolog-aritycheck V1240 (tl V1241))
    (interror "arity error in prolog procedure ~A~%"
     (@p (cons V1240 ()) ()))))
  (true (shen-sys-error shen-prolog-aritycheck))))

(defun shen-linearise-clause (V1242)
 (cond
  ((and (cons? V1242)
    (and (cons? (tl V1242))
     (and (= :- (hd (tl V1242)))
      (and (cons? (tl (tl V1242))) (= () (tl (tl (tl V1242))))))))
   (let Linear (shen-linearise (cons (hd V1242) (tl (tl V1242))))
    (shen-clause_form Linear)))
  (true (shen-sys-error shen-linearise-clause))))

(defun shen-clause_form (V1243)
 (cond
  ((and (cons? V1243) (and (cons? (tl V1243)) (= () (tl (tl V1243)))))
   (cons (shen-explicit_modes (hd V1243))
    (cons :- (cons (shen-cf_help (hd (tl V1243))) ()))))
  (true (shen-sys-error shen-clause_form))))

(defun shen-explicit_modes (V1244)
 (cond
  ((cons? V1244)
   (cons (hd V1244) (map (lambda V1245 (shen-em_help V1245)) (tl V1244))))
  (true (shen-sys-error shen-explicit_modes))))

(defun shen-em_help (V1246)
 (cond
  ((and (cons? V1246)
    (and (= mode (hd V1246))
     (and (cons? (tl V1246))
      (and (cons? (tl (tl V1246))) (= () (tl (tl (tl V1246))))))))
   V1246)
  (true (cons mode (cons V1246 (cons + ()))))))

(defun shen-cf_help (V1247)
 (cond
  ((and (cons? V1247)
    (and (= where (hd V1247))
     (and (cons? (tl V1247))
      (and (cons? (hd (tl V1247)))
       (and (= = (hd (hd (tl V1247))))
        (and (cons? (tl (hd (tl V1247))))
         (and (cons? (tl (tl (hd (tl V1247)))))
          (and (= () (tl (tl (tl (hd (tl V1247))))))
           (and (cons? (tl (tl V1247)))
            (= () (tl (tl (tl V1247)))))))))))))
   (cons (cons (if (value shen-*occurs*) unify! unify) (tl (hd (tl V1247))))
    (shen-cf_help (hd (tl (tl V1247))))))
  (true V1247)))

(defun occurs-check (V1252)
 (cond ((= + V1252) (set shen-*occurs* true))
  ((= - V1252) (set shen-*occurs* false))
  (true (interror "occurs-check expects + or -~%" ()))))

(defun shen-aum (V1253 V1254)
 (cond
  ((and (cons? V1253)
    (and (cons? (hd V1253))
     (and (cons? (tl V1253))
      (and (= :- (hd (tl V1253)))
       (and (cons? (tl (tl V1253))) (= () (tl (tl (tl V1253)))))))))
   (let MuApplication
    (shen-make_mu_application
     (cons shen-mu
      (cons (tl (hd V1253))
       (cons (shen-continuation_call (tl (hd V1253)) (hd (tl (tl V1253))))
        ())))
     V1254)
    (shen-mu_reduction MuApplication +)))
  (true (shen-sys-error shen-aum))))

(defun shen-continuation_call (V1255 V1256)
 (let VTerms (cons ProcessN (shen-extract_vars V1255))
  (let VBody (shen-extract_vars V1256)
   (let Free (remove Throwcontrol (difference VBody VTerms))
    (shen-cc_help Free V1256)))))

(defun remove (V1259 V1260)
 (cond ((= () V1260) ())
  ((and (cons? V1260) (= (hd V1260) V1259)) (remove (hd V1260) (tl V1260)))
  ((cons? V1260) (cons (hd V1260) (remove V1259 (tl V1260))))
  (true (shen-sys-error remove))))

(defun shen-cc_help (V1262 V1263)
 (cond
  ((and (= () V1262) (= () V1263))
   (cons shen-pop (cons shen-the (cons shen-stack ()))))
  ((= () V1263)
   (cons shen-rename
    (cons shen-the
     (cons shen-variables
      (cons in
       (cons V1262
        (cons and
         (cons shen-then
          (cons (cons shen-pop (cons shen-the (cons shen-stack ())))
           ())))))))))
  ((= () V1262)
   (cons call (cons shen-the (cons shen-continuation (cons V1263 ())))))
  (true
   (cons shen-rename
    (cons shen-the
     (cons shen-variables
      (cons in
       (cons V1262
        (cons and
         (cons shen-then
          (cons
           (cons call
            (cons shen-the (cons shen-continuation (cons V1263 ()))))
           ())))))))))))

(defun shen-make_mu_application (V1264 V1265)
 (cond
  ((and (cons? V1264)
    (and (= shen-mu (hd V1264))
     (and (cons? (tl V1264))
      (and (= () (hd (tl V1264)))
       (and (cons? (tl (tl V1264)))
        (and (= () (tl (tl (tl V1264)))) (= () V1265)))))))
   (hd (tl (tl V1264))))
  ((and (cons? V1264)
    (and (= shen-mu (hd V1264))
     (and (cons? (tl V1264))
      (and (cons? (hd (tl V1264)))
       (and (cons? (tl (tl V1264)))
        (and (= () (tl (tl (tl V1264)))) (cons? V1265)))))))
   (cons
    (cons shen-mu
     (cons (hd (hd (tl V1264)))
      (cons
       (shen-make_mu_application
        (cons shen-mu (cons (tl (hd (tl V1264))) (tl (tl V1264)))) (tl V1265))
       ())))
    (cons (hd V1265) ())))
  (true (shen-sys-error shen-make_mu_application))))

(defun shen-mu_reduction (V1272 V1273)
 (cond
  ((and (cons? V1272)
    (and (cons? (hd V1272))
     (and (= shen-mu (hd (hd V1272)))
      (and (cons? (tl (hd V1272)))
       (and (cons? (hd (tl (hd V1272))))
        (and (= mode (hd (hd (tl (hd V1272)))))
         (and (cons? (tl (hd (tl (hd V1272)))))
          (and (cons? (tl (tl (hd (tl (hd V1272))))))
           (and (= () (tl (tl (tl (hd (tl (hd V1272)))))))
            (and (cons? (tl (tl (hd V1272))))
             (and (= () (tl (tl (tl (hd V1272)))))
              (and (cons? (tl V1272)) (= () (tl (tl V1272)))))))))))))))
   (shen-mu_reduction
    (cons
     (cons shen-mu (cons (hd (tl (hd (tl (hd V1272))))) (tl (tl (hd V1272)))))
     (tl V1272))
    (hd (tl (tl (hd (tl (hd V1272))))))))
  ((and (cons? V1272)
    (and (cons? (hd V1272))
     (and (= shen-mu (hd (hd V1272)))
      (and (cons? (tl (hd V1272)))
       (and (cons? (tl (tl (hd V1272))))
        (and (= () (tl (tl (tl (hd V1272)))))
         (and (cons? (tl V1272))
          (and (= () (tl (tl V1272))) (= _ (hd (tl (hd V1272))))))))))))
   (shen-mu_reduction (hd (tl (tl (hd V1272)))) V1273))
  ((and (cons? V1272)
    (and (cons? (hd V1272))
     (and (= shen-mu (hd (hd V1272)))
      (and (cons? (tl (hd V1272)))
       (and (cons? (tl (tl (hd V1272))))
        (and (= () (tl (tl (tl (hd V1272)))))
         (and (cons? (tl V1272))
          (and (= () (tl (tl V1272)))
           (shen-ephemeral_variable? (hd (tl (hd V1272)))
            (hd (tl V1272)))))))))))
   (subst (hd (tl V1272)) (hd (tl (hd V1272)))
    (shen-mu_reduction (hd (tl (tl (hd V1272)))) V1273)))
  ((and (cons? V1272)
    (and (cons? (hd V1272))
     (and (= shen-mu (hd (hd V1272)))
      (and (cons? (tl (hd V1272)))
       (and (cons? (tl (tl (hd V1272))))
        (and (= () (tl (tl (tl (hd V1272)))))
         (and (cons? (tl V1272))
          (and (= () (tl (tl V1272)))
           (variable? (hd (tl (hd V1272))))))))))))
   (cons let
    (cons (hd (tl (hd V1272)))
     (cons shen-be
      (cons (hd (tl V1272))
       (cons in
        (cons (shen-mu_reduction (hd (tl (tl (hd V1272)))) V1273) ())))))))
  ((and (cons? V1272)
    (and (cons? (hd V1272))
     (and (= shen-mu (hd (hd V1272)))
      (and (cons? (tl (hd V1272)))
       (and (cons? (tl (tl (hd V1272))))
        (and (= () (tl (tl (tl (hd V1272)))))
         (and (cons? (tl V1272))
          (and (= () (tl (tl V1272)))
           (and (= - V1273)
            (shen-prolog_constant? (hd (tl (hd V1272)))))))))))))
   (let Z (gensym V)
    (cons let
     (cons Z
      (cons shen-be
       (cons
        (cons shen-the
         (cons shen-result
          (cons shen-of (cons shen-dereferencing (tl V1272)))))
        (cons in
         (cons
          (cons if
           (cons
            (cons Z
             (cons is
              (cons identical (cons shen-to (cons (hd (tl (hd V1272))) ())))))
            (cons shen-then
             (cons (shen-mu_reduction (hd (tl (tl (hd V1272)))) -)
              (cons shen-else (cons fail! ()))))))
          ()))))))))
  ((and (cons? V1272)
    (and (cons? (hd V1272))
     (and (= shen-mu (hd (hd V1272)))
      (and (cons? (tl (hd V1272)))
       (and (cons? (tl (tl (hd V1272))))
        (and (= () (tl (tl (tl (hd V1272)))))
         (and (cons? (tl V1272))
          (and (= () (tl (tl V1272)))
           (and (= + V1273)
            (shen-prolog_constant? (hd (tl (hd V1272)))))))))))))
   (let Z (gensym V)
    (cons let
     (cons Z
      (cons shen-be
       (cons
        (cons shen-the
         (cons shen-result
          (cons shen-of (cons shen-dereferencing (tl V1272)))))
        (cons in
         (cons
          (cons if
           (cons
            (cons Z
             (cons is
              (cons identical (cons shen-to (cons (hd (tl (hd V1272))) ())))))
            (cons shen-then
             (cons (shen-mu_reduction (hd (tl (tl (hd V1272)))) +)
              (cons shen-else
               (cons
                (cons if
                 (cons
                  (cons Z (cons is (cons shen-a (cons shen-variable ()))))
                  (cons shen-then
                   (cons
                    (cons bind
                     (cons Z
                      (cons shen-to
                       (cons (hd (tl (hd V1272)))
                        (cons in
                         (cons (shen-mu_reduction (hd (tl (tl (hd V1272)))) +)
                          ()))))))
                    (cons shen-else (cons fail! ()))))))
                ()))))))
          ()))))))))
  ((and (cons? V1272)
    (and (cons? (hd V1272))
     (and (= shen-mu (hd (hd V1272)))
      (and (cons? (tl (hd V1272)))
       (and (cons? (hd (tl (hd V1272))))
        (and (cons? (tl (tl (hd V1272))))
         (and (= () (tl (tl (tl (hd V1272)))))
          (and (cons? (tl V1272))
           (and (= () (tl (tl V1272))) (= - V1273))))))))))
   (let Z (gensym V)
    (cons let
     (cons Z
      (cons shen-be
       (cons
        (cons shen-the
         (cons shen-result
          (cons shen-of (cons shen-dereferencing (tl V1272)))))
        (cons in
         (cons
          (cons if
           (cons
            (cons Z
             (cons is (cons shen-a (cons shen-non-empty (cons list ())))))
            (cons shen-then
             (cons
              (shen-mu_reduction
               (cons
                (cons shen-mu
                 (cons (hd (hd (tl (hd V1272))))
                  (cons
                   (cons
                    (cons shen-mu
                     (cons (tl (hd (tl (hd V1272)))) (tl (tl (hd V1272)))))
                    (cons
                     (cons shen-the (cons tail (cons shen-of (cons Z ()))))
                     ()))
                   ())))
                (cons (cons shen-the (cons head (cons shen-of (cons Z ()))))
                 ()))
               -)
              (cons shen-else (cons fail! ()))))))
          ()))))))))
  ((and (cons? V1272)
    (and (cons? (hd V1272))
     (and (= shen-mu (hd (hd V1272)))
      (and (cons? (tl (hd V1272)))
       (and (cons? (hd (tl (hd V1272))))
        (and (cons? (tl (tl (hd V1272))))
         (and (= () (tl (tl (tl (hd V1272)))))
          (and (cons? (tl V1272))
           (and (= () (tl (tl V1272))) (= + V1273))))))))))
   (let Z (gensym V)
    (cons let
     (cons Z
      (cons shen-be
       (cons
        (cons shen-the
         (cons shen-result
          (cons shen-of (cons shen-dereferencing (tl V1272)))))
        (cons in
         (cons
          (cons if
           (cons
            (cons Z
             (cons is (cons shen-a (cons shen-non-empty (cons list ())))))
            (cons shen-then
             (cons
              (shen-mu_reduction
               (cons
                (cons shen-mu
                 (cons (hd (hd (tl (hd V1272))))
                  (cons
                   (cons
                    (cons shen-mu
                     (cons (tl (hd (tl (hd V1272)))) (tl (tl (hd V1272)))))
                    (cons
                     (cons shen-the (cons tail (cons shen-of (cons Z ()))))
                     ()))
                   ())))
                (cons (cons shen-the (cons head (cons shen-of (cons Z ()))))
                 ()))
               +)
              (cons shen-else
               (cons
                (cons if
                 (cons
                  (cons Z (cons is (cons shen-a (cons shen-variable ()))))
                  (cons shen-then
                   (cons
                    (cons shen-rename
                     (cons shen-the
                      (cons shen-variables
                       (cons in
                        (cons (shen-extract_vars (hd (tl (hd V1272))))
                         (cons and
                          (cons shen-then
                           (cons
                            (cons bind
                             (cons Z
                              (cons shen-to
                               (cons
                                (shen-rcons_form
                                 (shen-remove_modes (hd (tl (hd V1272)))))
                                (cons in
                                 (cons
                                  (shen-mu_reduction (hd (tl (tl (hd V1272))))
                                   +)
                                  ()))))))
                            ()))))))))
                    (cons shen-else (cons fail! ()))))))
                ()))))))
          ()))))))))
  (true V1272)))

(defun shen-rcons_form (V1274)
 (cond
  ((cons? V1274)
   (cons cons
    (cons (shen-rcons_form (hd V1274))
     (cons (shen-rcons_form (tl V1274)) ()))))
  (true V1274)))

(defun shen-remove_modes (V1275)
 (cond
  ((and (cons? V1275)
    (and (= mode (hd V1275))
     (and (cons? (tl V1275))
      (and (cons? (tl (tl V1275)))
       (and (= + (hd (tl (tl V1275)))) (= () (tl (tl (tl V1275)))))))))
   (shen-remove_modes (hd (tl V1275))))
  ((and (cons? V1275)
    (and (= mode (hd V1275))
     (and (cons? (tl V1275))
      (and (cons? (tl (tl V1275)))
       (and (= - (hd (tl (tl V1275)))) (= () (tl (tl (tl V1275)))))))))
   (shen-remove_modes (hd (tl V1275))))
  ((cons? V1275)
   (cons (shen-remove_modes (hd V1275)) (shen-remove_modes (tl V1275))))
  (true V1275)))

(defun shen-ephemeral_variable? (V1276 V1277)
 (and (variable? V1276) (variable? V1277)))

(defun shen-prolog_constant? (V1286) (cond ((cons? V1286) false) (true true)))

(defun shen-aum_to_shen (V1287)
 (cond
  ((and (cons? V1287)
    (and (= let (hd V1287))
     (and (cons? (tl V1287))
      (and (cons? (tl (tl V1287)))
       (and (= shen-be (hd (tl (tl V1287))))
        (and (cons? (tl (tl (tl V1287))))
         (and (cons? (tl (tl (tl (tl V1287)))))
          (and (= in (hd (tl (tl (tl (tl V1287))))))
           (and (cons? (tl (tl (tl (tl (tl V1287))))))
            (= () (tl (tl (tl (tl (tl (tl V1287))))))))))))))))
   (cons let
    (cons (hd (tl V1287))
     (cons (shen-aum_to_shen (hd (tl (tl (tl V1287)))))
      (cons (shen-aum_to_shen (hd (tl (tl (tl (tl (tl V1287))))))) ())))))
  ((and (cons? V1287)
    (and (= shen-the (hd V1287))
     (and (cons? (tl V1287))
      (and (= shen-result (hd (tl V1287)))
       (and (cons? (tl (tl V1287)))
        (and (= shen-of (hd (tl (tl V1287))))
         (and (cons? (tl (tl (tl V1287))))
          (and (= shen-dereferencing (hd (tl (tl (tl V1287)))))
           (and (cons? (tl (tl (tl (tl V1287)))))
            (= () (tl (tl (tl (tl (tl V1287)))))))))))))))
   (cons shen-lazyderef
    (cons (shen-aum_to_shen (hd (tl (tl (tl (tl V1287))))))
     (cons ProcessN ()))))
  ((and (cons? V1287)
    (and (= if (hd V1287))
     (and (cons? (tl V1287))
      (and (cons? (tl (tl V1287)))
       (and (= shen-then (hd (tl (tl V1287))))
        (and (cons? (tl (tl (tl V1287))))
         (and (cons? (tl (tl (tl (tl V1287)))))
          (and (= shen-else (hd (tl (tl (tl (tl V1287))))))
           (and (cons? (tl (tl (tl (tl (tl V1287))))))
            (= () (tl (tl (tl (tl (tl (tl V1287))))))))))))))))
   (cons if
    (cons (shen-aum_to_shen (hd (tl V1287)))
     (cons (shen-aum_to_shen (hd (tl (tl (tl V1287)))))
      (cons (shen-aum_to_shen (hd (tl (tl (tl (tl (tl V1287))))))) ())))))
  ((and (cons? V1287)
    (and (cons? (tl V1287))
     (and (= is (hd (tl V1287)))
      (and (cons? (tl (tl V1287)))
       (and (= shen-a (hd (tl (tl V1287))))
        (and (cons? (tl (tl (tl V1287))))
         (and (= shen-variable (hd (tl (tl (tl V1287)))))
          (= () (tl (tl (tl (tl V1287))))))))))))
   (cons shen-pvar? (cons (hd V1287) ())))
  ((and (cons? V1287)
    (and (cons? (tl V1287))
     (and (= is (hd (tl V1287)))
      (and (cons? (tl (tl V1287)))
       (and (= shen-a (hd (tl (tl V1287))))
        (and (cons? (tl (tl (tl V1287))))
         (and (= shen-non-empty (hd (tl (tl (tl V1287)))))
          (and (cons? (tl (tl (tl (tl V1287)))))
           (and (= list (hd (tl (tl (tl (tl V1287))))))
            (= () (tl (tl (tl (tl (tl V1287)))))))))))))))
   (cons cons? (cons (hd V1287) ())))
  ((and (cons? V1287)
    (and (= shen-rename (hd V1287))
     (and (cons? (tl V1287))
      (and (= shen-the (hd (tl V1287)))
       (and (cons? (tl (tl V1287)))
        (and (= shen-variables (hd (tl (tl V1287))))
         (and (cons? (tl (tl (tl V1287))))
          (and (= in (hd (tl (tl (tl V1287)))))
           (and (cons? (tl (tl (tl (tl V1287)))))
            (and (= () (hd (tl (tl (tl (tl V1287))))))
             (and (cons? (tl (tl (tl (tl (tl V1287))))))
              (and (= and (hd (tl (tl (tl (tl (tl V1287)))))))
               (and (cons? (tl (tl (tl (tl (tl (tl V1287)))))))
                (and (= shen-then (hd (tl (tl (tl (tl (tl (tl V1287))))))))
                 (and (cons? (tl (tl (tl (tl (tl (tl (tl V1287))))))))
                  (= ()
                   (tl
                    (tl (tl (tl (tl (tl (tl (tl V1287))))))))))))))))))))))))
   (shen-aum_to_shen (hd (tl (tl (tl (tl (tl (tl (tl V1287))))))))))
  ((and (cons? V1287)
    (and (= shen-rename (hd V1287))
     (and (cons? (tl V1287))
      (and (= shen-the (hd (tl V1287)))
       (and (cons? (tl (tl V1287)))
        (and (= shen-variables (hd (tl (tl V1287))))
         (and (cons? (tl (tl (tl V1287))))
          (and (= in (hd (tl (tl (tl V1287)))))
           (and (cons? (tl (tl (tl (tl V1287)))))
            (and (cons? (hd (tl (tl (tl (tl V1287))))))
             (and (cons? (tl (tl (tl (tl (tl V1287))))))
              (and (= and (hd (tl (tl (tl (tl (tl V1287)))))))
               (and (cons? (tl (tl (tl (tl (tl (tl V1287)))))))
                (and (= shen-then (hd (tl (tl (tl (tl (tl (tl V1287))))))))
                 (and (cons? (tl (tl (tl (tl (tl (tl (tl V1287))))))))
                  (= ()
                   (tl
                    (tl (tl (tl (tl (tl (tl (tl V1287))))))))))))))))))))))))
   (cons let
    (cons (hd (hd (tl (tl (tl (tl V1287))))))
     (cons (cons shen-newpv (cons ProcessN ()))
      (cons
       (shen-aum_to_shen
        (cons shen-rename
         (cons shen-the
          (cons shen-variables
           (cons in
            (cons (tl (hd (tl (tl (tl (tl V1287))))))
             (tl (tl (tl (tl (tl V1287)))))))))))
       ())))))
  ((and (cons? V1287)
    (and (= bind (hd V1287))
     (and (cons? (tl V1287))
      (and (cons? (tl (tl V1287)))
       (and (= shen-to (hd (tl (tl V1287))))
        (and (cons? (tl (tl (tl V1287))))
         (and (cons? (tl (tl (tl (tl V1287)))))
          (and (= in (hd (tl (tl (tl (tl V1287))))))
           (and (cons? (tl (tl (tl (tl (tl V1287))))))
            (= () (tl (tl (tl (tl (tl (tl V1287))))))))))))))))
   (cons do
    (cons
     (cons shen-bindv
      (cons (hd (tl V1287))
       (cons (shen-chwild (hd (tl (tl (tl V1287))))) (cons ProcessN ()))))
     (cons
      (cons let
       (cons Result
        (cons (shen-aum_to_shen (hd (tl (tl (tl (tl (tl V1287)))))))
         (cons
          (cons do
           (cons (cons shen-unbindv (cons (hd (tl V1287)) (cons ProcessN ())))
            (cons Result ())))
          ()))))
      ()))))
  ((and (cons? V1287)
    (and (cons? (tl V1287))
     (and (= is (hd (tl V1287)))
      (and (cons? (tl (tl V1287)))
       (and (= identical (hd (tl (tl V1287))))
        (and (cons? (tl (tl (tl V1287))))
         (and (= shen-to (hd (tl (tl (tl V1287)))))
          (and (cons? (tl (tl (tl (tl V1287)))))
           (= () (tl (tl (tl (tl (tl V1287))))))))))))))
   (cons = (cons (hd (tl (tl (tl (tl V1287))))) (cons (hd V1287) ()))))
  ((= fail! V1287) false)
  ((and (cons? V1287)
    (and (= shen-the (hd V1287))
     (and (cons? (tl V1287))
      (and (= head (hd (tl V1287)))
       (and (cons? (tl (tl V1287)))
        (and (= shen-of (hd (tl (tl V1287))))
         (and (cons? (tl (tl (tl V1287))))
          (= () (tl (tl (tl (tl V1287))))))))))))
   (cons hd (tl (tl (tl V1287)))))
  ((and (cons? V1287)
    (and (= shen-the (hd V1287))
     (and (cons? (tl V1287))
      (and (= tail (hd (tl V1287)))
       (and (cons? (tl (tl V1287)))
        (and (= shen-of (hd (tl (tl V1287))))
         (and (cons? (tl (tl (tl V1287))))
          (= () (tl (tl (tl (tl V1287))))))))))))
   (cons tl (tl (tl (tl V1287)))))
  ((and (cons? V1287)
    (and (= shen-pop (hd V1287))
     (and (cons? (tl V1287))
      (and (= shen-the (hd (tl V1287)))
       (and (cons? (tl (tl V1287)))
        (and (= shen-stack (hd (tl (tl V1287))))
         (= () (tl (tl (tl V1287))))))))))
   (cons do
    (cons (cons shen-incinfs ())
     (cons (cons thaw (cons Continuation ())) ()))))
  ((and (cons? V1287)
    (and (= call (hd V1287))
     (and (cons? (tl V1287))
      (and (= shen-the (hd (tl V1287)))
       (and (cons? (tl (tl V1287)))
        (and (= shen-continuation (hd (tl (tl V1287))))
         (and (cons? (tl (tl (tl V1287))))
          (= () (tl (tl (tl (tl V1287))))))))))))
   (cons do
    (cons (cons shen-incinfs ())
     (cons
      (shen-call_the_continuation (shen-chwild (hd (tl (tl (tl V1287)))))
       ProcessN Continuation)
      ()))))
  (true V1287)))

(defun shen-chwild (V1288)
 (cond ((= V1288 _) (cons shen-newpv (cons ProcessN ())))
  ((cons? V1288) (map (lambda V1289 (shen-chwild V1289)) V1288)) (true V1288)))

(defun shen-newpv (V1290)
 (let Count+1 (+ (<-address (value shen-*varcounter*) V1290) 1)
  (let IncVar (address-> (value shen-*varcounter*) V1290 Count+1)
   (let Vector (<-address (value shen-*prologvectors*) V1290)
    (let ResizeVectorIfNeeded
     (if (= Count+1 (limit Vector)) (shen-resizeprocessvector V1290 Count+1)
      shen-skip)
     (shen-mk-pvar Count+1))))))

(defun shen-resizeprocessvector (V1291 V1292)
 (let Vector (<-address (value shen-*prologvectors*) V1291)
  (let BigVector (shen-resize-vector Vector (+ V1292 V1292) shen--null-)
   (address-> (value shen-*prologvectors*) V1291 BigVector))))

(defun shen-resize-vector (V1293 V1294 V1295)
 (let BigVector (address-> (absvector (+ 1 V1294)) 0 V1294)
  (shen-copy-vector V1293 BigVector (limit V1293) V1294 V1295)))

(defun shen-copy-vector (V1296 V1297 V1298 V1299 V1300)
 (shen-copy-vector-stage-2 (+ 1 V1298) (+ V1299 1) V1300
  (shen-copy-vector-stage-1 1 V1296 V1297 (+ 1 V1298))))

(defun shen-copy-vector-stage-1 (V1303 V1304 V1305 V1306)
 (cond ((= V1306 V1303) V1305)
  (true
   (shen-copy-vector-stage-1 (+ 1 V1303) V1304
    (address-> V1305 V1303 (<-address V1304 V1303)) V1306))))

(defun shen-copy-vector-stage-2 (V1310 V1311 V1312 V1313)
 (cond ((= V1311 V1310) V1313)
  (true
   (shen-copy-vector-stage-2 (+ V1310 1) V1311 V1312
    (address-> V1313 V1310 V1312)))))

(defun shen-mk-pvar (V1315)
 (address-> (address-> (absvector 2) 0 shen-pvar) 1 V1315))

(defun shen-pvar? (V1316)
 (and (absvector? V1316) (= (<-address V1316 0) shen-pvar)))

(defun shen-bindv (V1317 V1318 V1319)
 (let Vector (<-address (value shen-*prologvectors*) V1319)
  (address-> Vector (<-address V1317 1) V1318)))

(defun shen-unbindv (V1320 V1321)
 (let Vector (<-address (value shen-*prologvectors*) V1321)
  (address-> Vector (<-address V1320 1) shen--null-)))

(defun shen-incinfs () (set shen-*infs* (+ 1 (value shen-*infs*))))

(defun shen-call_the_continuation (V1322 V1323 V1324)
 (cond
  ((and (cons? V1322) (and (cons? (hd V1322)) (= () (tl V1322))))
   (cons (hd (hd V1322))
    (append (tl (hd V1322)) (cons V1323 (cons V1324 ())))))
  ((and (cons? V1322) (cons? (hd V1322)))
   (let NewContinuation (shen-newcontinuation (tl V1322) V1323 V1324)
    (cons (hd (hd V1322))
     (append (tl (hd V1322)) (cons V1323 (cons NewContinuation ()))))))
  (true (shen-sys-error shen-call_the_continuation))))

(defun shen-newcontinuation (V1325 V1326 V1327)
 (cond ((= () V1325) V1327)
  ((and (cons? V1325) (cons? (hd V1325)))
   (cons freeze
    (cons
     (cons (hd (hd V1325))
      (append (tl (hd V1325))
       (cons V1326 (cons (shen-newcontinuation (tl V1325) V1326 V1327) ()))))
     ())))
  (true (shen-sys-error shen-newcontinuation))))

(defun return (V1332 V1333 V1334) (shen-deref V1332 V1333))

(defun shen-measure&return (V1339 V1340 V1341)
 (do (intoutput "~A inferences~%" (@p (value shen-*infs*) ()))
  (shen-deref V1339 V1340)))

(defun unify (V1342 V1343 V1344 V1345)
 (shen-lzy= (shen-lazyderef V1342 V1344) (shen-lazyderef V1343 V1344) V1344
  V1345))

(defun shen-lzy= (V1362 V1363 V1364 V1365)
 (cond ((= V1363 V1362) (thaw V1365))
  ((shen-pvar? V1362) (bind V1362 V1363 V1364 V1365))
  ((shen-pvar? V1363) (bind V1363 V1362 V1364 V1365))
  ((and (cons? V1362) (cons? V1363))
   (shen-lzy= (shen-lazyderef (hd V1362) V1364)
    (shen-lazyderef (hd V1363) V1364) V1364
    (freeze
     (shen-lzy= (shen-lazyderef (tl V1362) V1364)
      (shen-lazyderef (tl V1363) V1364) V1364 V1365))))
  (true false)))

(defun shen-deref (V1367 V1368)
 (cond
  ((cons? V1367)
   (cons (shen-deref (hd V1367) V1368) (shen-deref (tl V1367) V1368)))
  (true
   (if (shen-pvar? V1367)
    (let Value (shen-valvector V1367 V1368)
     (if (= Value shen--null-) V1367 (shen-deref Value V1368)))
    V1367))))

(defun shen-lazyderef (V1369 V1370)
 (if (shen-pvar? V1369)
  (let Value (shen-valvector V1369 V1370)
   (if (= Value shen--null-) V1369 (shen-lazyderef Value V1370)))
  V1369))

(defun shen-valvector (V1371 V1372)
 (<-address (<-address (value shen-*prologvectors*) V1372)
  (<-address V1371 1)))

(defun unify! (V1373 V1374 V1375 V1376)
 (shen-lzy=! (shen-lazyderef V1373 V1375) (shen-lazyderef V1374 V1375) V1375
  V1376))

(defun shen-lzy=! (V1393 V1394 V1395 V1396)
 (cond ((= V1394 V1393) (thaw V1396))
  ((and (shen-pvar? V1393) (not (shen-occurs? V1393 (shen-deref V1394 V1395))))
   (bind V1393 V1394 V1395 V1396))
  ((and (shen-pvar? V1394) (not (shen-occurs? V1394 (shen-deref V1393 V1395))))
   (bind V1394 V1393 V1395 V1396))
  ((and (cons? V1393) (cons? V1394))
   (shen-lzy=! (shen-lazyderef (hd V1393) V1395)
    (shen-lazyderef (hd V1394) V1395) V1395
    (freeze
     (shen-lzy=! (shen-lazyderef (tl V1393) V1395)
      (shen-lazyderef (tl V1394) V1395) V1395 V1396))))
  (true false)))

(defun shen-occurs? (V1406 V1407)
 (cond ((= V1407 V1406) true)
  ((cons? V1407)
   (or (shen-occurs? V1406 (hd V1407)) (shen-occurs? V1406 (tl V1407))))
  (true false)))

(defun identical (V1409 V1410 V1411 V1412)
 (shen-lzy== (shen-lazyderef V1409 V1411) (shen-lazyderef V1410 V1411) V1411
  V1412))

(defun shen-lzy== (V1429 V1430 V1431 V1432)
 (cond ((= V1430 V1429) (thaw V1432))
  ((and (cons? V1429) (cons? V1430))
   (shen-lzy== (shen-lazyderef (hd V1429) V1431)
    (shen-lazyderef (hd V1430) V1431) V1431
    (freeze (shen-lzy== (tl V1429) (tl V1430) V1431 V1432))))
  (true false)))

(defun shen-pvar (V1434) (intmake-string "Var~A" (@p (<-address V1434 1) ())))

(defun bind (V1435 V1436 V1437 V1438)
 (do (shen-bindv V1435 V1436 V1437)
  (let Result (thaw V1438) (do (shen-unbindv V1435 V1437) Result))))

(defun fwhen (V1453 V1454 V1455)
 (cond ((= true V1453) (thaw V1455)) ((= false V1453) false)
  (true (interror "fwhen expects a boolean: not ~S%" (@p V1453 ())))))

(defun call (V1468 V1469 V1470)
 (cond
  ((cons? V1468)
   (shen-call-help
    (shen-m_prolog_to_s-prolog_predicate (shen-lazyderef (hd V1468) V1469))
    (tl V1468) V1469 V1470))
  (true false)))

(defun shen-call-help (V1471 V1472 V1473 V1474)
 (cond ((= () V1472) (V1471 V1473 V1474))
  ((cons? V1472) (shen-call-help (V1471 (hd V1472)) (tl V1472) V1473 V1474))
  (true (shen-sys-error shen-call-help))))

(defun shen-intprolog (V1475)
 (cond
  ((and (cons? V1475) (cons? (hd V1475)))
   (let ProcessN (shen-start-new-prolog-process)
    (shen-intprolog-help (hd (hd V1475))
     (shen-insert-prolog-variables (cons (tl (hd V1475)) (cons (tl V1475) ()))
      ProcessN)
     ProcessN)))
  (true (shen-sys-error shen-intprolog))))

(defun shen-intprolog-help (V1476 V1477 V1478)
 (cond
  ((and (cons? V1477) (and (cons? (tl V1477)) (= () (tl (tl V1477)))))
   (shen-intprolog-help-help V1476 (hd V1477) (hd (tl V1477)) V1478))
  (true (shen-sys-error shen-intprolog-help))))

(defun shen-intprolog-help-help (V1479 V1480 V1481 V1482)
 (cond ((= () V1480) (V1479 V1482 (freeze (shen-call-rest V1481 V1482))))
  ((cons? V1480)
   (shen-intprolog-help-help (V1479 (hd V1480)) (tl V1480) V1481 V1482))
  (true (shen-sys-error shen-intprolog-help-help))))

(defun shen-call-rest (V1485 V1486)
 (cond ((= () V1485) true)
  ((and (cons? V1485) (and (cons? (hd V1485)) (cons? (tl (hd V1485)))))
   (shen-call-rest
    (cons (cons ((hd (hd V1485)) (hd (tl (hd V1485)))) (tl (tl (hd V1485))))
     (tl V1485))
    V1486))
  ((and (cons? V1485) (and (cons? (hd V1485)) (= () (tl (hd V1485)))))
   ((hd (hd V1485)) V1486 (freeze (shen-call-rest (tl V1485) V1486))))
  (true (shen-sys-error shen-call-rest))))

(defun shen-start-new-prolog-process ()
 (let IncrementProcessCounter
  (set shen-*process-counter* (+ 1 (value shen-*process-counter*)))
  (shen-initialise-prolog IncrementProcessCounter)))

(defun shen-insert-prolog-variables (V1487 V1488)
 (shen-insert-prolog-variables-help V1487 (shen-flatten V1487) V1488))

(defun shen-insert-prolog-variables-help (V1493 V1494 V1495)
 (cond ((= () V1494) V1493)
  ((and (cons? V1494) (variable? (hd V1494)))
   (let V (shen-newpv V1495)
    (let XV/Y (subst V (hd V1494) V1493)
     (let Z-Y (remove (hd V1494) (tl V1494))
      (shen-insert-prolog-variables-help XV/Y Z-Y V1495)))))
  ((cons? V1494) (shen-insert-prolog-variables-help V1493 (tl V1494) V1495))
  (true (shen-sys-error shen-insert-prolog-variables-help))))

(defun shen-initialise-prolog (V1496)
 (let Vector
  (address-> (value shen-*prologvectors*) V1496
   (shen-fillvector (vector 10) 1 11 shen--null-))
  (let Counter (address-> (value shen-*varcounter*) V1496 1) V1496)))

