
"                                                   The License
 
 The user is free to produce commercial applications with the software, to distribute these applications in source or binary  form, and to charge monies for them as he sees fit and in concordance with the laws of the land subject to the following  license.
 
 1. The license applies to all the software and all derived software and must appear on such.
 2. It is illegal to distribute the software without this license attached to it and use of the software implies agreement 
    with the license as such. It is illegal for anyone who is not the copyright holder to tamper with or change the license.
 3. Neither the names of Lambda Associates or the copyright holder may be used to endorse or promote products built using
     the software without specific prior written permission from the copyright holder.
 4. That possession of this license does not confer on the copyright holder any special contractual obligation towards the    user. That in no event shall the copyright holder be liable for any direct, indirect, incidental, special, exemplary or   consequential damages (including but not limited to procurement of substitute goods or services, loss of use, data, or    profits; or business interruption), however caused and on any theory of liability, whether in contract, strict liability   or tort (including negligence) arising in any way out of the use of the software, even if advised of the possibility of   such damage. 
5. It is permitted for the user to change the software, for the purpose of improving performance, correcting an error, or    porting to a new platform, and distribute the modified version of Shen (hereafter the modified version) provided the     resulting program conforms in all respects to the Shen standard and is issued under that title. The user must make it clear   with his distribution that he/she is the author of the changes and what these changes are and why. 
6. Derived versions of this software in whatever form are subject to the same restrictions. In particular it is not          permitted to make derived copies of this software which do not conform to the Shen standard or appear under a different title.
7. It is permitted to distribute versions of Shen which incorporate libraries, graphics or other facilities which are not    part of the Shen standard.

For an explication of this license see http://www.lambdassociates.org/News/june11/license.htm which explains this license in full."

(defun shen-<defprolog> (V1164)
 (let Result
  (let Parse_<predicate*> (shen-<predicate*> V1164)
   (if (not (= (fail) Parse_<predicate*>))
    (let Parse_<clauses*> (shen-<clauses*> Parse_<predicate*>)
     (if (not (= (fail) Parse_<clauses*>))
      (shen-reassemble (fst Parse_<clauses*>)
       (hd
        (shen-prolog->shen
         (map (lambda X (shen-insert-predicate (snd Parse_<predicate*>) X))
          (snd Parse_<clauses*>)))))
      (fail)))
    (fail)))
  (if (= Result (fail)) (fail) Result)))

(defun shen-prolog-error (V1165 V1166)
 (interror "prolog syntax error in ~A here:~%~% ~A~%"
  (@p V1165 (@p (shen-next-50 50 V1166) ()))))

(defun shen-next-50 (V1171 V1172)
 (cond ((= () V1172) "") ((= 0 V1171) "")
  ((cons? V1172)
   (cn (shen-decons-string (hd V1172)) (shen-next-50 (- V1171 1) (tl V1172))))
  (true (shen-sys-error shen-next-50))))

(defun shen-decons-string (V1173)
 (cond
  ((and (cons? V1173)
    (and (= cons (hd V1173))
     (and (cons? (tl V1173))
      (and (cons? (tl (tl V1173))) (= () (tl (tl (tl V1173))))))))
   (intmake-string "~S " (@p (shen-eval-cons V1173) ())))
  (true (intmake-string "~R " (@p V1173 ())))))

(defun shen-insert-predicate (V1174 V1175)
 (cond
  ((and (cons? V1175) (and (cons? (tl V1175)) (= () (tl (tl V1175)))))
   (cons (cons V1174 (hd V1175)) (cons :- (tl V1175))))
  (true (shen-sys-error shen-insert-predicate))))

(defun shen-<predicate*> (V1176)
 (let Result
  (if (cons? (fst V1176))
   (shen-reassemble (fst (shen-reassemble (tl (fst V1176)) (snd V1176)))
    (hd (fst V1176)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<clauses*> (V1177)
 (let Result
  (let Parse_<clause*> (shen-<clause*> V1177)
   (if (not (= (fail) Parse_<clause*>))
    (let Parse_<clauses*> (shen-<clauses*> Parse_<clause*>)
     (if (not (= (fail) Parse_<clauses*>))
      (shen-reassemble (fst Parse_<clauses*>)
       (cons (snd Parse_<clause*>) (snd Parse_<clauses*>)))
      (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<e> (<e> V1177)
     (if (not (= (fail) Parse_<e>))
      (shen-reassemble (fst Parse_<e>) (snd Parse_<e>)) (fail)))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<clause*> (V1178)
 (let Result
  (let Parse_<head*> (shen-<head*> V1178)
   (if (not (= (fail) Parse_<head*>))
    (if (and (cons? (fst Parse_<head*>)) (= <-- (hd (fst Parse_<head*>))))
     (let Parse_<body*>
      (shen-<body*>
       (shen-reassemble (tl (fst Parse_<head*>)) (snd Parse_<head*>)))
      (if (not (= (fail) Parse_<body*>))
       (let Parse_<end*> (shen-<end*> Parse_<body*>)
        (if (not (= (fail) Parse_<end*>))
         (shen-reassemble (fst Parse_<end*>)
          (cons (snd Parse_<head*>) (cons (snd Parse_<body*>) ())))
         (fail)))
       (fail)))
     (fail))
    (fail)))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<head*> (V1179)
 (let Result
  (let Parse_<term*> (shen-<term*> V1179)
   (if (not (= (fail) Parse_<term*>))
    (let Parse_<head*> (shen-<head*> Parse_<term*>)
     (if (not (= (fail) Parse_<head*>))
      (shen-reassemble (fst Parse_<head*>)
       (cons (snd Parse_<term*>) (snd Parse_<head*>)))
      (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<e> (<e> V1179)
     (if (not (= (fail) Parse_<e>))
      (shen-reassemble (fst Parse_<e>) (snd Parse_<e>)) (fail)))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<term*> (V1180)
 (let Result
  (if (cons? (fst V1180))
   (shen-reassemble (fst (shen-reassemble (tl (fst V1180)) (snd V1180)))
    (if
     (and (not (= <-- (hd (fst V1180))))
      (shen-legitimate-term? (hd (fst V1180))))
     (shen-eval-cons (hd (fst V1180))) (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-legitimate-term? (V1185)
 (cond
  ((and (cons? V1185)
    (and (= cons (hd V1185))
     (and (cons? (tl V1185))
      (and (cons? (tl (tl V1185))) (= () (tl (tl (tl V1185))))))))
   (and (shen-legitimate-term? (hd (tl V1185)))
    (shen-legitimate-term? (hd (tl (tl V1185))))))
  ((and (cons? V1185)
    (and (= mode (hd V1185))
     (and (cons? (tl V1185))
      (and (cons? (tl (tl V1185)))
       (and (= + (hd (tl (tl V1185)))) (= () (tl (tl (tl V1185)))))))))
   (shen-legitimate-term? (hd (tl V1185))))
  ((and (cons? V1185)
    (and (= mode (hd V1185))
     (and (cons? (tl V1185))
      (and (cons? (tl (tl V1185)))
       (and (= - (hd (tl (tl V1185)))) (= () (tl (tl (tl V1185)))))))))
   (shen-legitimate-term? (hd (tl V1185))))
  ((cons? V1185) false) (true true)))

(defun shen-eval-cons (V1186)
 (cond
  ((and (cons? V1186)
    (and (= cons (hd V1186))
     (and (cons? (tl V1186))
      (and (cons? (tl (tl V1186))) (= () (tl (tl (tl V1186))))))))
   (cons (shen-eval-cons (hd (tl V1186)))
    (shen-eval-cons (hd (tl (tl V1186))))))
  ((and (cons? V1186)
    (and (= mode (hd V1186))
     (and (cons? (tl V1186))
      (and (cons? (tl (tl V1186))) (= () (tl (tl (tl V1186))))))))
   (cons mode (cons (shen-eval-cons (hd (tl V1186))) (tl (tl V1186)))))
  (true V1186)))

(defun shen-<body*> (V1187)
 (let Result
  (let Parse_<literal*> (shen-<literal*> V1187)
   (if (not (= (fail) Parse_<literal*>))
    (let Parse_<body*> (shen-<body*> Parse_<literal*>)
     (if (not (= (fail) Parse_<body*>))
      (shen-reassemble (fst Parse_<body*>)
       (cons (snd Parse_<literal*>) (snd Parse_<body*>)))
      (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<e> (<e> V1187)
     (if (not (= (fail) Parse_<e>))
      (shen-reassemble (fst Parse_<e>) (snd Parse_<e>)) (fail)))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<literal*> (V1188)
 (let Result
  (if (and (cons? (fst V1188)) (= ! (hd (fst V1188))))
   (shen-reassemble (fst (shen-reassemble (tl (fst V1188)) (snd V1188)))
    (cons cut (cons Throwcontrol ())))
   (fail))
  (if (= Result (fail))
   (let Result
    (if (cons? (fst V1188))
     (shen-reassemble (fst (shen-reassemble (tl (fst V1188)) (snd V1188)))
      (if (cons? (hd (fst V1188))) (hd (fst V1188)) (fail)))
     (fail))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<end*> (V1189)
 (let Result
  (if (cons? (fst V1189))
   (shen-reassemble (fst (shen-reassemble (tl (fst V1189)) (snd V1189)))
    (if (= (hd (fst V1189)) ;) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun cut (V1190 V1191 V1192)
 (let Result (thaw V1192) (if (= Result false) V1190 Result)))

(defun shen-insert_modes (V1193)
 (cond
  ((and (cons? V1193)
    (and (= mode (hd V1193))
     (and (cons? (tl V1193))
      (and (cons? (tl (tl V1193))) (= () (tl (tl (tl V1193))))))))
   V1193)
  ((= () V1193) ())
  ((cons? V1193)
   (cons (cons mode (cons (hd V1193) (cons + ())))
    (cons mode (cons (shen-insert_modes (tl V1193)) (cons - ())))))
  (true V1193)))

(defun shen-s-prolog (V1194)
 (map (lambda V1195 (eval V1195)) (shen-prolog->shen V1194)))

(defun shen-prolog->shen (V1196)
 (map (lambda V1197 (shen-compile_prolog_procedure V1197))
  (shen-group_clauses
   (map (lambda V1198 (shen-s-prolog_clause V1198))
    (mapcan (lambda V1199 (shen-head_abstraction V1199)) V1196)))))

(defun shen-s-prolog_clause (V1200)
 (cond
  ((and (cons? V1200)
    (and (cons? (tl V1200))
     (and (= :- (hd (tl V1200)))
      (and (cons? (tl (tl V1200))) (= () (tl (tl (tl V1200))))))))
   (cons (hd V1200)
    (cons :-
     (cons
      (map (lambda V1201 (shen-s-prolog_literal V1201)) (hd (tl (tl V1200))))
      ()))))
  (true (shen-sys-error shen-s-prolog_clause))))

(defun shen-head_abstraction (V1202)
 (cond
  ((and (cons? V1202)
    (and (cons? (tl V1202))
     (and (= :- (hd (tl V1202)))
      (and (cons? (tl (tl V1202)))
       (and (= () (tl (tl (tl V1202))))
        (< (shen-complexity_head (hd V1202))
         (value shen-*maxcomplexity*)))))))
   (cons V1202 ()))
  ((and (cons? V1202)
    (and (cons? (hd V1202))
     (and (cons? (tl V1202))
      (and (= :- (hd (tl V1202)))
       (and (cons? (tl (tl V1202))) (= () (tl (tl (tl V1202)))))))))
   (let Terms (map (lambda Y (gensym V)) (tl (hd V1202)))
    (let XTerms (shen-rcons_form (shen-remove_modes (tl (hd V1202))))
     (let Literal (cons unify (cons (shen-cons_form Terms) (cons XTerms ())))
      (let Clause
       (cons (cons (hd (hd V1202)) Terms)
        (cons :- (cons (cons Literal (hd (tl (tl V1202)))) ())))
       (cons Clause ()))))))
  (true (shen-sys-error shen-head_abstraction))))

(defun shen-complexity_head (V1207)
 (cond
  ((cons? V1207)
   (shen-product (map (lambda V1208 (shen-complexity V1208)) (tl V1207))))
  (true (shen-sys-error shen-complexity_head))))

(defun shen-complexity (V1216)
 (cond
  ((and (cons? V1216)
    (and (= mode (hd V1216))
     (and (cons? (tl V1216))
      (and (cons? (hd (tl V1216)))
       (and (= mode (hd (hd (tl V1216))))
        (and (cons? (tl (hd (tl V1216))))
         (and (cons? (tl (tl (hd (tl V1216)))))
          (and (= () (tl (tl (tl (hd (tl V1216))))))
           (and (cons? (tl (tl V1216)))
            (= () (tl (tl (tl V1216)))))))))))))
   (shen-complexity (hd (tl V1216))))
  ((and (cons? V1216)
    (and (= mode (hd V1216))
     (and (cons? (tl V1216))
      (and (cons? (hd (tl V1216)))
       (and (cons? (tl (tl V1216)))
        (and (= + (hd (tl (tl V1216))))
         (= () (tl (tl (tl V1216))))))))))
   (* 2
    (*
     (shen-complexity (cons mode (cons (hd (hd (tl V1216))) (tl (tl V1216)))))
     (shen-complexity
      (cons mode (cons (tl (hd (tl V1216))) (tl (tl V1216))))))))
  ((and (cons? V1216)
    (and (= mode (hd V1216))
     (and (cons? (tl V1216))
      (and (cons? (hd (tl V1216)))
       (and (cons? (tl (tl V1216)))
        (and (= - (hd (tl (tl V1216))))
         (= () (tl (tl (tl V1216))))))))))
   (* (shen-complexity (cons mode (cons (hd (hd (tl V1216))) (tl (tl V1216)))))
    (shen-complexity (cons mode (cons (tl (hd (tl V1216))) (tl (tl V1216)))))))
  ((and (cons? V1216)
    (and (= mode (hd V1216))
     (and (cons? (tl V1216))
      (and (cons? (tl (tl V1216)))
       (and (= () (tl (tl (tl V1216)))) (variable? (hd (tl V1216))))))))
   1)
  ((and (cons? V1216)
    (and (= mode (hd V1216))
     (and (cons? (tl V1216))
      (and (cons? (tl (tl V1216)))
       (and (= + (hd (tl (tl V1216)))) (= () (tl (tl (tl V1216)))))))))
   2)
  ((and (cons? V1216)
    (and (= mode (hd V1216))
     (and (cons? (tl V1216))
      (and (cons? (tl (tl V1216)))
       (and (= - (hd (tl (tl V1216)))) (= () (tl (tl (tl V1216)))))))))
   1)
  (true (shen-complexity (cons mode (cons V1216 (cons + ())))))))

(defun shen-product (V1217)
 (cond ((= () V1217) 1)
  ((cons? V1217) (* (hd V1217) (shen-product (tl V1217))))
  (true (shen-sys-error shen-product))))

(defun shen-s-prolog_literal (V1218)
 (cond
  ((and (cons? V1218)
    (and (= is (hd V1218))
     (and (cons? (tl V1218))
      (and (cons? (tl (tl V1218))) (= () (tl (tl (tl V1218))))))))
   (cons bind
    (cons (hd (tl V1218))
     (cons (shen-insert_deref (hd (tl (tl V1218)))) ()))))
  ((and (cons? V1218)
    (and (= when (hd V1218))
     (and (cons? (tl V1218)) (= () (tl (tl V1218))))))
   (cons fwhen (cons (shen-insert_deref (hd (tl V1218))) ())))
  ((and (cons? V1218)
    (and (= bind (hd V1218))
     (and (cons? (tl V1218))
      (and (cons? (tl (tl V1218))) (= () (tl (tl (tl V1218))))))))
   (cons bind
    (cons (hd (tl V1218))
     (cons (shen-insert_lazyderef (hd (tl (tl V1218)))) ()))))
  ((and (cons? V1218)
    (and (= fwhen (hd V1218))
     (and (cons? (tl V1218)) (= () (tl (tl V1218))))))
   (cons fwhen (cons (shen-insert_lazyderef (hd (tl V1218))) ())))
  ((cons? V1218)
   (cons (shen-m_prolog_to_s-prolog_predicate (hd V1218)) (tl V1218)))
  (true (shen-sys-error shen-s-prolog_literal))))

(defun shen-insert_deref (V1219)
 (cond ((variable? V1219) (cons shen-deref (cons V1219 (cons ProcessN ()))))
  ((cons? V1219)
   (cons (shen-insert_deref (hd V1219)) (shen-insert_deref (tl V1219))))
  (true V1219)))

(defun shen-insert_lazyderef (V1220)
 (cond
  ((variable? V1220) (cons shen-lazyderef (cons V1220 (cons ProcessN ()))))
  ((cons? V1220)
   (cons (shen-insert_lazyderef (hd V1220))
    (shen-insert_lazyderef (tl V1220))))
  (true V1220)))

(defun shen-m_prolog_to_s-prolog_predicate (V1221)
 (cond ((= = V1221) unify) ((= =! V1221) unify!)
  ((= == V1221) identical) (true V1221)))

(defun shen-group_clauses (V1222)
 (cond ((= () V1222) ())
  ((cons? V1222)
   (let Group
    (shen-collect (lambda X (shen-same_predicate? (hd V1222) X)) V1222)
    (let Rest (difference V1222 Group)
     (cons Group (shen-group_clauses Rest)))))
  (true (shen-sys-error shen-group_clauses))))

(defun shen-collect (V1225 V1226)
 (cond ((= () V1226) ())
  ((cons? V1226)
   (if (V1225 (hd V1226)) (cons (hd V1226) (shen-collect V1225 (tl V1226)))
    (shen-collect V1225 (tl V1226))))
  (true (shen-sys-error shen-collect))))

(defun shen-same_predicate? (V1243 V1244)
 (cond
  ((and (cons? V1243)
    (and (cons? (hd V1243)) (and (cons? V1244) (cons? (hd V1244)))))
   (= (hd (hd V1243)) (hd (hd V1244))))
  (true (shen-sys-error shen-same_predicate?))))

(defun shen-compile_prolog_procedure (V1245)
 (let F (shen-procedure_name V1245)
  (let Shen (shen-clauses-to-shen F V1245) Shen)))

(defun shen-procedure_name (V1258)
 (cond
  ((and (cons? V1258) (and (cons? (hd V1258)) (cons? (hd (hd V1258)))))
   (hd (hd (hd V1258))))
  (true (shen-sys-error shen-procedure_name))))

(defun shen-clauses-to-shen (V1259 V1260)
 (let Linear (map (lambda V1261 (shen-linearise-clause V1261)) V1260)
  (let Arity
   (shen-prolog-aritycheck V1259 (map (lambda V1262 (head V1262)) V1260))
   (let Parameters (shen-parameters Arity)
    (let AUM_instructions (map (lambda X (shen-aum X Parameters)) Linear)
     (let Code
      (shen-catch-cut
       (shen-nest-disjunct
        (map (lambda V1263 (shen-aum_to_shen V1263)) AUM_instructions)))
      (let ShenDef
       (cons define
        (cons V1259
         (append Parameters
          (append (cons ProcessN (cons Continuation ()))
           (cons -> (cons Code ()))))))
       ShenDef)))))))

(defun shen-catch-cut (V1264)
 (cond ((not (shen-occurs? cut V1264)) V1264)
  (true
   (cons let
    (cons Throwcontrol
     (cons (cons shen-catchpoint ())
      (cons (cons shen-cutpoint (cons Throwcontrol (cons V1264 ())))
       ())))))))

(defun shen-catchpoint () (set shen-*catch* (+ 1 (value shen-*catch*))))

(defun shen-cutpoint (V1269 V1270)
 (cond ((= V1270 V1269) false) (true V1270)))

(defun shen-nest-disjunct (V1272)
 (cond ((and (cons? V1272) (= () (tl V1272))) (hd V1272))
  ((cons? V1272) (shen-lisp-or (hd V1272) (shen-nest-disjunct (tl V1272))))
  (true (shen-sys-error shen-nest-disjunct))))

(defun shen-lisp-or (V1273 V1274)
 (cons let
  (cons Case
   (cons V1273
    (cons
     (cons if
      (cons (cons = (cons Case (cons false ())))
       (cons V1274 (cons Case ()))))
     ())))))

(defun shen-prolog-aritycheck (V1277 V1278)
 (cond ((and (cons? V1278) (= () (tl V1278))) (- (length (hd V1278)) 1))
  ((and (cons? V1278) (cons? (tl V1278)))
   (if (= (length (hd V1278)) (length (hd (tl V1278))))
    (shen-prolog-aritycheck V1277 (tl V1278))
    (interror "arity error in prolog procedure ~A~%"
     (@p (cons V1277 ()) ()))))
  (true (shen-sys-error shen-prolog-aritycheck))))

(defun shen-linearise-clause (V1279)
 (cond
  ((and (cons? V1279)
    (and (cons? (tl V1279))
     (and (= :- (hd (tl V1279)))
      (and (cons? (tl (tl V1279))) (= () (tl (tl (tl V1279))))))))
   (let Linear (shen-linearise (cons (hd V1279) (tl (tl V1279))))
    (shen-clause_form Linear)))
  (true (shen-sys-error shen-linearise-clause))))

(defun shen-clause_form (V1280)
 (cond
  ((and (cons? V1280) (and (cons? (tl V1280)) (= () (tl (tl V1280)))))
   (cons (shen-explicit_modes (hd V1280))
    (cons :- (cons (shen-cf_help (hd (tl V1280))) ()))))
  (true (shen-sys-error shen-clause_form))))

(defun shen-explicit_modes (V1281)
 (cond
  ((cons? V1281)
   (cons (hd V1281) (map (lambda V1282 (shen-em_help V1282)) (tl V1281))))
  (true (shen-sys-error shen-explicit_modes))))

(defun shen-em_help (V1283)
 (cond
  ((and (cons? V1283)
    (and (= mode (hd V1283))
     (and (cons? (tl V1283))
      (and (cons? (tl (tl V1283))) (= () (tl (tl (tl V1283))))))))
   V1283)
  (true (cons mode (cons V1283 (cons + ()))))))

(defun shen-cf_help (V1284)
 (cond
  ((and (cons? V1284)
    (and (= where (hd V1284))
     (and (cons? (tl V1284))
      (and (cons? (hd (tl V1284)))
       (and (= = (hd (hd (tl V1284))))
        (and (cons? (tl (hd (tl V1284))))
         (and (cons? (tl (tl (hd (tl V1284)))))
          (and (= () (tl (tl (tl (hd (tl V1284))))))
           (and (cons? (tl (tl V1284)))
            (= () (tl (tl (tl V1284)))))))))))))
   (cons (cons (if (value shen-*occurs*) unify! unify) (tl (hd (tl V1284))))
    (shen-cf_help (hd (tl (tl V1284))))))
  (true V1284)))

(defun occurs-check (V1289)
 (cond ((= + V1289) (set shen-*occurs* true))
  ((= - V1289) (set shen-*occurs* false))
  (true (interror "occurs-check expects + or -~%" ()))))

(defun shen-aum (V1290 V1291)
 (cond
  ((and (cons? V1290)
    (and (cons? (hd V1290))
     (and (cons? (tl V1290))
      (and (= :- (hd (tl V1290)))
       (and (cons? (tl (tl V1290))) (= () (tl (tl (tl V1290)))))))))
   (let MuApplication
    (shen-make_mu_application
     (cons shen-mu
      (cons (tl (hd V1290))
       (cons (shen-continuation_call (tl (hd V1290)) (hd (tl (tl V1290))))
        ())))
     V1291)
    (shen-mu_reduction MuApplication +)))
  (true (shen-sys-error shen-aum))))

(defun shen-continuation_call (V1292 V1293)
 (let VTerms (cons ProcessN (shen-extract_vars V1292))
  (let VBody (shen-extract_vars V1293)
   (let Free (remove Throwcontrol (difference VBody VTerms))
    (shen-cc_help Free V1293)))))

(defun remove (V1294 V1295) (shen-remove-h V1294 V1295 ()))

(defun shen-remove-h (V1298 V1299 V1300)
 (cond ((= () V1299) (reverse V1300))
  ((and (cons? V1299) (= (hd V1299) V1298))
   (shen-remove-h (hd V1299) (tl V1299) V1300))
  ((cons? V1299) (shen-remove-h V1298 (tl V1299) (cons (hd V1299) V1300)))
  (true (shen-sys-error shen-remove-h))))

(defun shen-cc_help (V1302 V1303)
 (cond
  ((and (= () V1302) (= () V1303))
   (cons shen-pop (cons shen-the (cons shen-stack ()))))
  ((= () V1303)
   (cons shen-rename
    (cons shen-the
     (cons shen-variables
      (cons in
       (cons V1302
        (cons and
         (cons shen-then
          (cons (cons shen-pop (cons shen-the (cons shen-stack ())))
           ())))))))))
  ((= () V1302)
   (cons call (cons shen-the (cons shen-continuation (cons V1303 ())))))
  (true
   (cons shen-rename
    (cons shen-the
     (cons shen-variables
      (cons in
       (cons V1302
        (cons and
         (cons shen-then
          (cons
           (cons call
            (cons shen-the (cons shen-continuation (cons V1303 ()))))
           ())))))))))))

(defun shen-make_mu_application (V1304 V1305)
 (cond
  ((and (cons? V1304)
    (and (= shen-mu (hd V1304))
     (and (cons? (tl V1304))
      (and (= () (hd (tl V1304)))
       (and (cons? (tl (tl V1304)))
        (and (= () (tl (tl (tl V1304)))) (= () V1305)))))))
   (hd (tl (tl V1304))))
  ((and (cons? V1304)
    (and (= shen-mu (hd V1304))
     (and (cons? (tl V1304))
      (and (cons? (hd (tl V1304)))
       (and (cons? (tl (tl V1304)))
        (and (= () (tl (tl (tl V1304)))) (cons? V1305)))))))
   (cons
    (cons shen-mu
     (cons (hd (hd (tl V1304)))
      (cons
       (shen-make_mu_application
        (cons shen-mu (cons (tl (hd (tl V1304))) (tl (tl V1304)))) (tl V1305))
       ())))
    (cons (hd V1305) ())))
  (true (shen-sys-error shen-make_mu_application))))

(defun shen-mu_reduction (V1312 V1313)
 (cond
  ((and (cons? V1312)
    (and (cons? (hd V1312))
     (and (= shen-mu (hd (hd V1312)))
      (and (cons? (tl (hd V1312)))
       (and (cons? (hd (tl (hd V1312))))
        (and (= mode (hd (hd (tl (hd V1312)))))
         (and (cons? (tl (hd (tl (hd V1312)))))
          (and (cons? (tl (tl (hd (tl (hd V1312))))))
           (and (= () (tl (tl (tl (hd (tl (hd V1312)))))))
            (and (cons? (tl (tl (hd V1312))))
             (and (= () (tl (tl (tl (hd V1312)))))
              (and (cons? (tl V1312)) (= () (tl (tl V1312)))))))))))))))
   (shen-mu_reduction
    (cons
     (cons shen-mu (cons (hd (tl (hd (tl (hd V1312))))) (tl (tl (hd V1312)))))
     (tl V1312))
    (hd (tl (tl (hd (tl (hd V1312))))))))
  ((and (cons? V1312)
    (and (cons? (hd V1312))
     (and (= shen-mu (hd (hd V1312)))
      (and (cons? (tl (hd V1312)))
       (and (cons? (tl (tl (hd V1312))))
        (and (= () (tl (tl (tl (hd V1312)))))
         (and (cons? (tl V1312))
          (and (= () (tl (tl V1312))) (= _ (hd (tl (hd V1312))))))))))))
   (shen-mu_reduction (hd (tl (tl (hd V1312)))) V1313))
  ((and (cons? V1312)
    (and (cons? (hd V1312))
     (and (= shen-mu (hd (hd V1312)))
      (and (cons? (tl (hd V1312)))
       (and (cons? (tl (tl (hd V1312))))
        (and (= () (tl (tl (tl (hd V1312)))))
         (and (cons? (tl V1312))
          (and (= () (tl (tl V1312)))
           (shen-ephemeral_variable? (hd (tl (hd V1312)))
            (hd (tl V1312)))))))))))
   (subst (hd (tl V1312)) (hd (tl (hd V1312)))
    (shen-mu_reduction (hd (tl (tl (hd V1312)))) V1313)))
  ((and (cons? V1312)
    (and (cons? (hd V1312))
     (and (= shen-mu (hd (hd V1312)))
      (and (cons? (tl (hd V1312)))
       (and (cons? (tl (tl (hd V1312))))
        (and (= () (tl (tl (tl (hd V1312)))))
         (and (cons? (tl V1312))
          (and (= () (tl (tl V1312)))
           (variable? (hd (tl (hd V1312))))))))))))
   (cons let
    (cons (hd (tl (hd V1312)))
     (cons shen-be
      (cons (hd (tl V1312))
       (cons in
        (cons (shen-mu_reduction (hd (tl (tl (hd V1312)))) V1313) ())))))))
  ((and (cons? V1312)
    (and (cons? (hd V1312))
     (and (= shen-mu (hd (hd V1312)))
      (and (cons? (tl (hd V1312)))
       (and (cons? (tl (tl (hd V1312))))
        (and (= () (tl (tl (tl (hd V1312)))))
         (and (cons? (tl V1312))
          (and (= () (tl (tl V1312)))
           (and (= - V1313)
            (shen-prolog_constant? (hd (tl (hd V1312)))))))))))))
   (let Z (gensym V)
    (cons let
     (cons Z
      (cons shen-be
       (cons
        (cons shen-the
         (cons shen-result
          (cons shen-of (cons shen-dereferencing (tl V1312)))))
        (cons in
         (cons
          (cons if
           (cons
            (cons Z
             (cons is
              (cons identical (cons shen-to (cons (hd (tl (hd V1312))) ())))))
            (cons shen-then
             (cons (shen-mu_reduction (hd (tl (tl (hd V1312)))) -)
              (cons shen-else (cons fail! ()))))))
          ()))))))))
  ((and (cons? V1312)
    (and (cons? (hd V1312))
     (and (= shen-mu (hd (hd V1312)))
      (and (cons? (tl (hd V1312)))
       (and (cons? (tl (tl (hd V1312))))
        (and (= () (tl (tl (tl (hd V1312)))))
         (and (cons? (tl V1312))
          (and (= () (tl (tl V1312)))
           (and (= + V1313)
            (shen-prolog_constant? (hd (tl (hd V1312)))))))))))))
   (let Z (gensym V)
    (cons let
     (cons Z
      (cons shen-be
       (cons
        (cons shen-the
         (cons shen-result
          (cons shen-of (cons shen-dereferencing (tl V1312)))))
        (cons in
         (cons
          (cons if
           (cons
            (cons Z
             (cons is
              (cons identical (cons shen-to (cons (hd (tl (hd V1312))) ())))))
            (cons shen-then
             (cons (shen-mu_reduction (hd (tl (tl (hd V1312)))) +)
              (cons shen-else
               (cons
                (cons if
                 (cons
                  (cons Z (cons is (cons shen-a (cons shen-variable ()))))
                  (cons shen-then
                   (cons
                    (cons bind
                     (cons Z
                      (cons shen-to
                       (cons (hd (tl (hd V1312)))
                        (cons in
                         (cons (shen-mu_reduction (hd (tl (tl (hd V1312)))) +)
                          ()))))))
                    (cons shen-else (cons fail! ()))))))
                ()))))))
          ()))))))))
  ((and (cons? V1312)
    (and (cons? (hd V1312))
     (and (= shen-mu (hd (hd V1312)))
      (and (cons? (tl (hd V1312)))
       (and (cons? (hd (tl (hd V1312))))
        (and (cons? (tl (tl (hd V1312))))
         (and (= () (tl (tl (tl (hd V1312)))))
          (and (cons? (tl V1312))
           (and (= () (tl (tl V1312))) (= - V1313))))))))))
   (let Z (gensym V)
    (cons let
     (cons Z
      (cons shen-be
       (cons
        (cons shen-the
         (cons shen-result
          (cons shen-of (cons shen-dereferencing (tl V1312)))))
        (cons in
         (cons
          (cons if
           (cons
            (cons Z
             (cons is (cons shen-a (cons shen-non-empty (cons list ())))))
            (cons shen-then
             (cons
              (shen-mu_reduction
               (cons
                (cons shen-mu
                 (cons (hd (hd (tl (hd V1312))))
                  (cons
                   (cons
                    (cons shen-mu
                     (cons (tl (hd (tl (hd V1312)))) (tl (tl (hd V1312)))))
                    (cons
                     (cons shen-the (cons tail (cons shen-of (cons Z ()))))
                     ()))
                   ())))
                (cons (cons shen-the (cons head (cons shen-of (cons Z ()))))
                 ()))
               -)
              (cons shen-else (cons fail! ()))))))
          ()))))))))
  ((and (cons? V1312)
    (and (cons? (hd V1312))
     (and (= shen-mu (hd (hd V1312)))
      (and (cons? (tl (hd V1312)))
       (and (cons? (hd (tl (hd V1312))))
        (and (cons? (tl (tl (hd V1312))))
         (and (= () (tl (tl (tl (hd V1312)))))
          (and (cons? (tl V1312))
           (and (= () (tl (tl V1312))) (= + V1313))))))))))
   (let Z (gensym V)
    (cons let
     (cons Z
      (cons shen-be
       (cons
        (cons shen-the
         (cons shen-result
          (cons shen-of (cons shen-dereferencing (tl V1312)))))
        (cons in
         (cons
          (cons if
           (cons
            (cons Z
             (cons is (cons shen-a (cons shen-non-empty (cons list ())))))
            (cons shen-then
             (cons
              (shen-mu_reduction
               (cons
                (cons shen-mu
                 (cons (hd (hd (tl (hd V1312))))
                  (cons
                   (cons
                    (cons shen-mu
                     (cons (tl (hd (tl (hd V1312)))) (tl (tl (hd V1312)))))
                    (cons
                     (cons shen-the (cons tail (cons shen-of (cons Z ()))))
                     ()))
                   ())))
                (cons (cons shen-the (cons head (cons shen-of (cons Z ()))))
                 ()))
               +)
              (cons shen-else
               (cons
                (cons if
                 (cons
                  (cons Z (cons is (cons shen-a (cons shen-variable ()))))
                  (cons shen-then
                   (cons
                    (cons shen-rename
                     (cons shen-the
                      (cons shen-variables
                       (cons in
                        (cons (shen-extract_vars (hd (tl (hd V1312))))
                         (cons and
                          (cons shen-then
                           (cons
                            (cons bind
                             (cons Z
                              (cons shen-to
                               (cons
                                (shen-rcons_form
                                 (shen-remove_modes (hd (tl (hd V1312)))))
                                (cons in
                                 (cons
                                  (shen-mu_reduction (hd (tl (tl (hd V1312))))
                                   +)
                                  ()))))))
                            ()))))))))
                    (cons shen-else (cons fail! ()))))))
                ()))))))
          ()))))))))
  (true V1312)))

(defun shen-rcons_form (V1314)
 (cond
  ((cons? V1314)
   (cons cons
    (cons (shen-rcons_form (hd V1314))
     (cons (shen-rcons_form (tl V1314)) ()))))
  (true V1314)))

(defun shen-remove_modes (V1315)
 (cond
  ((and (cons? V1315)
    (and (= mode (hd V1315))
     (and (cons? (tl V1315))
      (and (cons? (tl (tl V1315)))
       (and (= + (hd (tl (tl V1315)))) (= () (tl (tl (tl V1315)))))))))
   (shen-remove_modes (hd (tl V1315))))
  ((and (cons? V1315)
    (and (= mode (hd V1315))
     (and (cons? (tl V1315))
      (and (cons? (tl (tl V1315)))
       (and (= - (hd (tl (tl V1315)))) (= () (tl (tl (tl V1315)))))))))
   (shen-remove_modes (hd (tl V1315))))
  ((cons? V1315)
   (cons (shen-remove_modes (hd V1315)) (shen-remove_modes (tl V1315))))
  (true V1315)))

(defun shen-ephemeral_variable? (V1316 V1317)
 (and (variable? V1316) (variable? V1317)))

(defun shen-prolog_constant? (V1326) (cond ((cons? V1326) false) (true true)))

(defun shen-aum_to_shen (V1327)
 (cond
  ((and (cons? V1327)
    (and (= let (hd V1327))
     (and (cons? (tl V1327))
      (and (cons? (tl (tl V1327)))
       (and (= shen-be (hd (tl (tl V1327))))
        (and (cons? (tl (tl (tl V1327))))
         (and (cons? (tl (tl (tl (tl V1327)))))
          (and (= in (hd (tl (tl (tl (tl V1327))))))
           (and (cons? (tl (tl (tl (tl (tl V1327))))))
            (= () (tl (tl (tl (tl (tl (tl V1327))))))))))))))))
   (cons let
    (cons (hd (tl V1327))
     (cons (shen-aum_to_shen (hd (tl (tl (tl V1327)))))
      (cons (shen-aum_to_shen (hd (tl (tl (tl (tl (tl V1327))))))) ())))))
  ((and (cons? V1327)
    (and (= shen-the (hd V1327))
     (and (cons? (tl V1327))
      (and (= shen-result (hd (tl V1327)))
       (and (cons? (tl (tl V1327)))
        (and (= shen-of (hd (tl (tl V1327))))
         (and (cons? (tl (tl (tl V1327))))
          (and (= shen-dereferencing (hd (tl (tl (tl V1327)))))
           (and (cons? (tl (tl (tl (tl V1327)))))
            (= () (tl (tl (tl (tl (tl V1327)))))))))))))))
   (cons shen-lazyderef
    (cons (shen-aum_to_shen (hd (tl (tl (tl (tl V1327))))))
     (cons ProcessN ()))))
  ((and (cons? V1327)
    (and (= if (hd V1327))
     (and (cons? (tl V1327))
      (and (cons? (tl (tl V1327)))
       (and (= shen-then (hd (tl (tl V1327))))
        (and (cons? (tl (tl (tl V1327))))
         (and (cons? (tl (tl (tl (tl V1327)))))
          (and (= shen-else (hd (tl (tl (tl (tl V1327))))))
           (and (cons? (tl (tl (tl (tl (tl V1327))))))
            (= () (tl (tl (tl (tl (tl (tl V1327))))))))))))))))
   (cons if
    (cons (shen-aum_to_shen (hd (tl V1327)))
     (cons (shen-aum_to_shen (hd (tl (tl (tl V1327)))))
      (cons (shen-aum_to_shen (hd (tl (tl (tl (tl (tl V1327))))))) ())))))
  ((and (cons? V1327)
    (and (cons? (tl V1327))
     (and (= is (hd (tl V1327)))
      (and (cons? (tl (tl V1327)))
       (and (= shen-a (hd (tl (tl V1327))))
        (and (cons? (tl (tl (tl V1327))))
         (and (= shen-variable (hd (tl (tl (tl V1327)))))
          (= () (tl (tl (tl (tl V1327))))))))))))
   (cons shen-pvar? (cons (hd V1327) ())))
  ((and (cons? V1327)
    (and (cons? (tl V1327))
     (and (= is (hd (tl V1327)))
      (and (cons? (tl (tl V1327)))
       (and (= shen-a (hd (tl (tl V1327))))
        (and (cons? (tl (tl (tl V1327))))
         (and (= shen-non-empty (hd (tl (tl (tl V1327)))))
          (and (cons? (tl (tl (tl (tl V1327)))))
           (and (= list (hd (tl (tl (tl (tl V1327))))))
            (= () (tl (tl (tl (tl (tl V1327)))))))))))))))
   (cons cons? (cons (hd V1327) ())))
  ((and (cons? V1327)
    (and (= shen-rename (hd V1327))
     (and (cons? (tl V1327))
      (and (= shen-the (hd (tl V1327)))
       (and (cons? (tl (tl V1327)))
        (and (= shen-variables (hd (tl (tl V1327))))
         (and (cons? (tl (tl (tl V1327))))
          (and (= in (hd (tl (tl (tl V1327)))))
           (and (cons? (tl (tl (tl (tl V1327)))))
            (and (= () (hd (tl (tl (tl (tl V1327))))))
             (and (cons? (tl (tl (tl (tl (tl V1327))))))
              (and (= and (hd (tl (tl (tl (tl (tl V1327)))))))
               (and (cons? (tl (tl (tl (tl (tl (tl V1327)))))))
                (and (= shen-then (hd (tl (tl (tl (tl (tl (tl V1327))))))))
                 (and (cons? (tl (tl (tl (tl (tl (tl (tl V1327))))))))
                  (= ()
                   (tl
                    (tl (tl (tl (tl (tl (tl (tl V1327))))))))))))))))))))))))
   (shen-aum_to_shen (hd (tl (tl (tl (tl (tl (tl (tl V1327))))))))))
  ((and (cons? V1327)
    (and (= shen-rename (hd V1327))
     (and (cons? (tl V1327))
      (and (= shen-the (hd (tl V1327)))
       (and (cons? (tl (tl V1327)))
        (and (= shen-variables (hd (tl (tl V1327))))
         (and (cons? (tl (tl (tl V1327))))
          (and (= in (hd (tl (tl (tl V1327)))))
           (and (cons? (tl (tl (tl (tl V1327)))))
            (and (cons? (hd (tl (tl (tl (tl V1327))))))
             (and (cons? (tl (tl (tl (tl (tl V1327))))))
              (and (= and (hd (tl (tl (tl (tl (tl V1327)))))))
               (and (cons? (tl (tl (tl (tl (tl (tl V1327)))))))
                (and (= shen-then (hd (tl (tl (tl (tl (tl (tl V1327))))))))
                 (and (cons? (tl (tl (tl (tl (tl (tl (tl V1327))))))))
                  (= ()
                   (tl
                    (tl (tl (tl (tl (tl (tl (tl V1327))))))))))))))))))))))))
   (cons let
    (cons (hd (hd (tl (tl (tl (tl V1327))))))
     (cons (cons shen-newpv (cons ProcessN ()))
      (cons
       (shen-aum_to_shen
        (cons shen-rename
         (cons shen-the
          (cons shen-variables
           (cons in
            (cons (tl (hd (tl (tl (tl (tl V1327))))))
             (tl (tl (tl (tl (tl V1327)))))))))))
       ())))))
  ((and (cons? V1327)
    (and (= bind (hd V1327))
     (and (cons? (tl V1327))
      (and (cons? (tl (tl V1327)))
       (and (= shen-to (hd (tl (tl V1327))))
        (and (cons? (tl (tl (tl V1327))))
         (and (cons? (tl (tl (tl (tl V1327)))))
          (and (= in (hd (tl (tl (tl (tl V1327))))))
           (and (cons? (tl (tl (tl (tl (tl V1327))))))
            (= () (tl (tl (tl (tl (tl (tl V1327))))))))))))))))
   (cons do
    (cons
     (cons shen-bindv
      (cons (hd (tl V1327))
       (cons (shen-chwild (hd (tl (tl (tl V1327))))) (cons ProcessN ()))))
     (cons
      (cons let
       (cons Result
        (cons (shen-aum_to_shen (hd (tl (tl (tl (tl (tl V1327)))))))
         (cons
          (cons do
           (cons (cons shen-unbindv (cons (hd (tl V1327)) (cons ProcessN ())))
            (cons Result ())))
          ()))))
      ()))))
  ((and (cons? V1327)
    (and (cons? (tl V1327))
     (and (= is (hd (tl V1327)))
      (and (cons? (tl (tl V1327)))
       (and (= identical (hd (tl (tl V1327))))
        (and (cons? (tl (tl (tl V1327))))
         (and (= shen-to (hd (tl (tl (tl V1327)))))
          (and (cons? (tl (tl (tl (tl V1327)))))
           (= () (tl (tl (tl (tl (tl V1327))))))))))))))
   (cons = (cons (hd (tl (tl (tl (tl V1327))))) (cons (hd V1327) ()))))
  ((= fail! V1327) false)
  ((and (cons? V1327)
    (and (= shen-the (hd V1327))
     (and (cons? (tl V1327))
      (and (= head (hd (tl V1327)))
       (and (cons? (tl (tl V1327)))
        (and (= shen-of (hd (tl (tl V1327))))
         (and (cons? (tl (tl (tl V1327))))
          (= () (tl (tl (tl (tl V1327))))))))))))
   (cons hd (tl (tl (tl V1327)))))
  ((and (cons? V1327)
    (and (= shen-the (hd V1327))
     (and (cons? (tl V1327))
      (and (= tail (hd (tl V1327)))
       (and (cons? (tl (tl V1327)))
        (and (= shen-of (hd (tl (tl V1327))))
         (and (cons? (tl (tl (tl V1327))))
          (= () (tl (tl (tl (tl V1327))))))))))))
   (cons tl (tl (tl (tl V1327)))))
  ((and (cons? V1327)
    (and (= shen-pop (hd V1327))
     (and (cons? (tl V1327))
      (and (= shen-the (hd (tl V1327)))
       (and (cons? (tl (tl V1327)))
        (and (= shen-stack (hd (tl (tl V1327))))
         (= () (tl (tl (tl V1327))))))))))
   (cons do
    (cons (cons shen-incinfs ())
     (cons (cons thaw (cons Continuation ())) ()))))
  ((and (cons? V1327)
    (and (= call (hd V1327))
     (and (cons? (tl V1327))
      (and (= shen-the (hd (tl V1327)))
       (and (cons? (tl (tl V1327)))
        (and (= shen-continuation (hd (tl (tl V1327))))
         (and (cons? (tl (tl (tl V1327))))
          (= () (tl (tl (tl (tl V1327))))))))))))
   (cons do
    (cons (cons shen-incinfs ())
     (cons
      (shen-call_the_continuation (shen-chwild (hd (tl (tl (tl V1327)))))
       ProcessN Continuation)
      ()))))
  (true V1327)))

(defun shen-chwild (V1328)
 (cond ((= V1328 _) (cons shen-newpv (cons ProcessN ())))
  ((cons? V1328) (map (lambda V1329 (shen-chwild V1329)) V1328)) (true V1328)))

(defun shen-newpv (V1330)
 (let Count+1 (+ (<-address (value shen-*varcounter*) V1330) 1)
  (let IncVar (address-> (value shen-*varcounter*) V1330 Count+1)
   (let Vector (<-address (value shen-*prologvectors*) V1330)
    (let ResizeVectorIfNeeded
     (if (= Count+1 (limit Vector)) (shen-resizeprocessvector V1330 Count+1)
      shen-skip)
     (shen-mk-pvar Count+1))))))

(defun shen-resizeprocessvector (V1331 V1332)
 (let Vector (<-address (value shen-*prologvectors*) V1331)
  (let BigVector (shen-resize-vector Vector (+ V1332 V1332) shen--null-)
   (address-> (value shen-*prologvectors*) V1331 BigVector))))

(defun shen-resize-vector (V1333 V1334 V1335)
 (let BigVector (address-> (absvector (+ 1 V1334)) 0 V1334)
  (shen-copy-vector V1333 BigVector (limit V1333) V1334 V1335)))

(defun shen-copy-vector (V1336 V1337 V1338 V1339 V1340)
 (shen-copy-vector-stage-2 (+ 1 V1338) (+ V1339 1) V1340
  (shen-copy-vector-stage-1 1 V1336 V1337 (+ 1 V1338))))

(defun shen-copy-vector-stage-1 (V1343 V1344 V1345 V1346)
 (cond ((= V1346 V1343) V1345)
  (true
   (shen-copy-vector-stage-1 (+ 1 V1343) V1344
    (address-> V1345 V1343 (<-address V1344 V1343)) V1346))))

(defun shen-copy-vector-stage-2 (V1350 V1351 V1352 V1353)
 (cond ((= V1351 V1350) V1353)
  (true
   (shen-copy-vector-stage-2 (+ V1350 1) V1351 V1352
    (address-> V1353 V1350 V1352)))))

(defun shen-mk-pvar (V1355)
 (address-> (address-> (absvector 2) 0 shen-pvar) 1 V1355))

(defun shen-pvar? (V1356)
 (and (absvector? V1356) (= (<-address V1356 0) shen-pvar)))

(defun shen-bindv (V1357 V1358 V1359)
 (let Vector (<-address (value shen-*prologvectors*) V1359)
  (address-> Vector (<-address V1357 1) V1358)))

(defun shen-unbindv (V1360 V1361)
 (let Vector (<-address (value shen-*prologvectors*) V1361)
  (address-> Vector (<-address V1360 1) shen--null-)))

(defun shen-incinfs () (set shen-*infs* (+ 1 (value shen-*infs*))))

(defun shen-call_the_continuation (V1362 V1363 V1364)
 (cond
  ((and (cons? V1362) (and (cons? (hd V1362)) (= () (tl V1362))))
   (cons (hd (hd V1362))
    (append (tl (hd V1362)) (cons V1363 (cons V1364 ())))))
  ((and (cons? V1362) (cons? (hd V1362)))
   (let NewContinuation (shen-newcontinuation (tl V1362) V1363 V1364)
    (cons (hd (hd V1362))
     (append (tl (hd V1362)) (cons V1363 (cons NewContinuation ()))))))
  (true (shen-sys-error shen-call_the_continuation))))

(defun shen-newcontinuation (V1365 V1366 V1367)
 (cond ((= () V1365) V1367)
  ((and (cons? V1365) (cons? (hd V1365)))
   (cons freeze
    (cons
     (cons (hd (hd V1365))
      (append (tl (hd V1365))
       (cons V1366 (cons (shen-newcontinuation (tl V1365) V1366 V1367) ()))))
     ())))
  (true (shen-sys-error shen-newcontinuation))))

(defun return (V1372 V1373 V1374) (shen-deref V1372 V1373))

(defun shen-measure&return (V1379 V1380 V1381)
 (do (intoutput "~A inferences~%" (@p (value shen-*infs*) ()))
  (shen-deref V1379 V1380)))

(defun unify (V1382 V1383 V1384 V1385)
 (shen-lzy= (shen-lazyderef V1382 V1384) (shen-lazyderef V1383 V1384) V1384
  V1385))

(defun shen-lzy= (V1402 V1403 V1404 V1405)
 (cond ((= V1403 V1402) (thaw V1405))
  ((shen-pvar? V1402) (bind V1402 V1403 V1404 V1405))
  ((shen-pvar? V1403) (bind V1403 V1402 V1404 V1405))
  ((and (cons? V1402) (cons? V1403))
   (shen-lzy= (shen-lazyderef (hd V1402) V1404)
    (shen-lazyderef (hd V1403) V1404) V1404
    (freeze
     (shen-lzy= (shen-lazyderef (tl V1402) V1404)
      (shen-lazyderef (tl V1403) V1404) V1404 V1405))))
  (true false)))

(defun shen-deref (V1407 V1408)
 (cond
  ((cons? V1407)
   (cons (shen-deref (hd V1407) V1408) (shen-deref (tl V1407) V1408)))
  (true
   (if (shen-pvar? V1407)
    (let Value (shen-valvector V1407 V1408)
     (if (= Value shen--null-) V1407 (shen-deref Value V1408)))
    V1407))))

(defun shen-lazyderef (V1409 V1410)
 (if (shen-pvar? V1409)
  (let Value (shen-valvector V1409 V1410)
   (if (= Value shen--null-) V1409 (shen-lazyderef Value V1410)))
  V1409))

(defun shen-valvector (V1411 V1412)
 (<-address (<-address (value shen-*prologvectors*) V1412)
  (<-address V1411 1)))

(defun unify! (V1413 V1414 V1415 V1416)
 (shen-lzy=! (shen-lazyderef V1413 V1415) (shen-lazyderef V1414 V1415) V1415
  V1416))

(defun shen-lzy=! (V1433 V1434 V1435 V1436)
 (cond ((= V1434 V1433) (thaw V1436))
  ((and (shen-pvar? V1433) (not (shen-occurs? V1433 (shen-deref V1434 V1435))))
   (bind V1433 V1434 V1435 V1436))
  ((and (shen-pvar? V1434) (not (shen-occurs? V1434 (shen-deref V1433 V1435))))
   (bind V1434 V1433 V1435 V1436))
  ((and (cons? V1433) (cons? V1434))
   (shen-lzy=! (shen-lazyderef (hd V1433) V1435)
    (shen-lazyderef (hd V1434) V1435) V1435
    (freeze
     (shen-lzy=! (shen-lazyderef (tl V1433) V1435)
      (shen-lazyderef (tl V1434) V1435) V1435 V1436))))
  (true false)))

(defun shen-occurs? (V1446 V1447)
 (cond ((= V1447 V1446) true)
  ((cons? V1447)
   (or (shen-occurs? V1446 (hd V1447)) (shen-occurs? V1446 (tl V1447))))
  (true false)))

(defun identical (V1449 V1450 V1451 V1452)
 (shen-lzy== (shen-lazyderef V1449 V1451) (shen-lazyderef V1450 V1451) V1451
  V1452))

(defun shen-lzy== (V1469 V1470 V1471 V1472)
 (cond ((= V1470 V1469) (thaw V1472))
  ((and (cons? V1469) (cons? V1470))
   (shen-lzy== (shen-lazyderef (hd V1469) V1471)
    (shen-lazyderef (hd V1470) V1471) V1471
    (freeze (shen-lzy== (tl V1469) (tl V1470) V1471 V1472))))
  (true false)))

(defun shen-pvar (V1474) (intmake-string "Var~A" (@p (<-address V1474 1) ())))

(defun bind (V1475 V1476 V1477 V1478)
 (do (shen-bindv V1475 V1476 V1477)
  (let Result (thaw V1478) (do (shen-unbindv V1475 V1477) Result))))

(defun fwhen (V1493 V1494 V1495)
 (cond ((= true V1493) (thaw V1495)) ((= false V1493) false)
  (true (interror "fwhen expects a boolean: not ~S%" (@p V1493 ())))))

(defun call (V1508 V1509 V1510)
 (cond
  ((cons? V1508)
   (shen-call-help
    (shen-m_prolog_to_s-prolog_predicate (shen-lazyderef (hd V1508) V1509))
    (tl V1508) V1509 V1510))
  (true false)))

(defun shen-call-help (V1511 V1512 V1513 V1514)
 (cond ((= () V1512) (V1511 V1513 V1514))
  ((cons? V1512) (shen-call-help (V1511 (hd V1512)) (tl V1512) V1513 V1514))
  (true (shen-sys-error shen-call-help))))

(defun shen-intprolog (V1515)
 (cond
  ((and (cons? V1515) (cons? (hd V1515)))
   (let ProcessN (shen-start-new-prolog-process)
    (shen-intprolog-help (hd (hd V1515))
     (shen-insert-prolog-variables (cons (tl (hd V1515)) (cons (tl V1515) ()))
      ProcessN)
     ProcessN)))
  (true (shen-sys-error shen-intprolog))))

(defun shen-intprolog-help (V1516 V1517 V1518)
 (cond
  ((and (cons? V1517) (and (cons? (tl V1517)) (= () (tl (tl V1517)))))
   (shen-intprolog-help-help V1516 (hd V1517) (hd (tl V1517)) V1518))
  (true (shen-sys-error shen-intprolog-help))))

(defun shen-intprolog-help-help (V1519 V1520 V1521 V1522)
 (cond ((= () V1520) (V1519 V1522 (freeze (shen-call-rest V1521 V1522))))
  ((cons? V1520)
   (shen-intprolog-help-help (V1519 (hd V1520)) (tl V1520) V1521 V1522))
  (true (shen-sys-error shen-intprolog-help-help))))

(defun shen-call-rest (V1525 V1526)
 (cond ((= () V1525) true)
  ((and (cons? V1525) (and (cons? (hd V1525)) (cons? (tl (hd V1525)))))
   (shen-call-rest
    (cons (cons ((hd (hd V1525)) (hd (tl (hd V1525)))) (tl (tl (hd V1525))))
     (tl V1525))
    V1526))
  ((and (cons? V1525) (and (cons? (hd V1525)) (= () (tl (hd V1525)))))
   ((hd (hd V1525)) V1526 (freeze (shen-call-rest (tl V1525) V1526))))
  (true (shen-sys-error shen-call-rest))))

(defun shen-start-new-prolog-process ()
 (let IncrementProcessCounter
  (set shen-*process-counter* (+ 1 (value shen-*process-counter*)))
  (shen-initialise-prolog IncrementProcessCounter)))

(defun shen-insert-prolog-variables (V1527 V1528)
 (shen-insert-prolog-variables-help V1527 (shen-flatten V1527) V1528))

(defun shen-insert-prolog-variables-help (V1533 V1534 V1535)
 (cond ((= () V1534) V1533)
  ((and (cons? V1534) (variable? (hd V1534)))
   (let V (shen-newpv V1535)
    (let XV/Y (subst V (hd V1534) V1533)
     (let Z-Y (remove (hd V1534) (tl V1534))
      (shen-insert-prolog-variables-help XV/Y Z-Y V1535)))))
  ((cons? V1534) (shen-insert-prolog-variables-help V1533 (tl V1534) V1535))
  (true (shen-sys-error shen-insert-prolog-variables-help))))

(defun shen-initialise-prolog (V1536)
 (let Vector
  (address-> (value shen-*prologvectors*) V1536
   (shen-fillvector (vector 10) 1 10 shen--null-))
  (let Counter (address-> (value shen-*varcounter*) V1536 1) V1536)))

