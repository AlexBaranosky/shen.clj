
"                                                   The License
 
 The user is free to produce commercial applications with the software, to distribute these applications in source or binary  form, and to charge monies for them as he sees fit and in concordance with the laws of the land subject to the following  license.
 
 1. The license applies to all the software and all derived software and must appear on such.
 2. It is illegal to distribute the software without this license attached to it and use of the software implies agreement 
    with the license as such. It is illegal for anyone who is not the copyright holder to tamper with or change the license.
 3. Neither the names of Lambda Associates or the copyright holder may be used to endorse or promote products built using
     the software without specific prior written permission from the copyright holder.
 4. That possession of this license does not confer on the copyright holder any special contractual obligation towards the    user. That in no event shall the copyright holder be liable for any direct, indirect, incidental, special, exemplary or   consequential damages (including but not limited to procurement of substitute goods or services, loss of use, data, or    profits; or business interruption), however caused and on any theory of liability, whether in contract, strict liability   or tort (including negligence) arising in any way out of the use of the software, even if advised of the possibility of   such damage. 
5. It is permitted for the user to change the software, for the purpose of improving performance, correcting an error, or    porting to a new platform, and distribute the modified version of Shen (hereafter the modified version) provided the     resulting program conforms in all respects to the Shen standard and is issued under that title. The user must make it clear   with his distribution that he/she is the author of the changes and what these changes are and why. 
6. Derived versions of this software in whatever form are subject to the same restrictions. In particular it is not          permitted to make derived copies of this software which do not conform to the Shen standard or appear under a different title.
7. It is permitted to distribute versions of Shen which incorporate libraries, graphics or other facilities which are not    part of the Shen standard.

For an explication of this license see http://www.lambdassociates.org/News/june11/license.htm which explains this license in full."

(defun shen-<defprolog> (V4805)
 (let Result
  (let Parse_<predicate*> (shen-<predicate*> V4805)
   (if (not (= (fail) Parse_<predicate*>))
    (let Parse_<clauses*> (shen-<clauses*> Parse_<predicate*>)
     (if (not (= (fail) Parse_<clauses*>))
      (shen-reassemble (fst Parse_<clauses*>)
       (hd
        (shen-prolog->shen
         (map (lambda X (shen-insert-predicate (snd Parse_<predicate*>) X))
          (snd Parse_<clauses*>)))))
      (fail)))
    (fail)))
  (if (= Result (fail)) (fail) Result)))

(defun shen-prolog-error (V4806 V4807)
 (interror "prolog syntax error in ~A here:~%~% ~A~%"
  (@p V4806 (@p (shen-next-50 50 V4807) ()))))

(defun shen-next-50 (V4812 V4813)
 (cond ((= () V4813) "") ((= 0 V4812) "")
  ((cons? V4813)
   (cn (shen-decons-string (hd V4813)) (shen-next-50 (- V4812 1) (tl V4813))))
  (true (shen-sys-error shen-next-50))))

(defun shen-decons-string (V4814)
 (cond
  ((and (cons? V4814)
    (and (= cons (hd V4814))
     (and (cons? (tl V4814))
      (and (cons? (tl (tl V4814))) (= () (tl (tl (tl V4814))))))))
   (intmake-string "~S " (@p (shen-eval-cons V4814) ())))
  (true (intmake-string "~R " (@p V4814 ())))))

(defun shen-insert-predicate (V4815 V4816)
 (cond
  ((and (cons? V4816) (and (cons? (tl V4816)) (= () (tl (tl V4816)))))
   (cons (cons V4815 (hd V4816)) (cons :- (tl V4816))))
  (true (shen-sys-error shen-insert-predicate))))

(defun shen-<predicate*> (V4817)
 (let Result
  (if (cons? (fst V4817))
   (shen-reassemble (fst (shen-reassemble (tl (fst V4817)) (snd V4817)))
    (hd (fst V4817)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<clauses*> (V4818)
 (let Result
  (let Parse_<clause*> (shen-<clause*> V4818)
   (if (not (= (fail) Parse_<clause*>))
    (let Parse_<clauses*> (shen-<clauses*> Parse_<clause*>)
     (if (not (= (fail) Parse_<clauses*>))
      (shen-reassemble (fst Parse_<clauses*>)
       (cons (snd Parse_<clause*>) (snd Parse_<clauses*>)))
      (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<e> (<e> V4818)
     (if (not (= (fail) Parse_<e>))
      (shen-reassemble (fst Parse_<e>) (snd Parse_<e>)) (fail)))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<clause*> (V4819)
 (let Result
  (let Parse_<head*> (shen-<head*> V4819)
   (if (not (= (fail) Parse_<head*>))
    (if (and (cons? (fst Parse_<head*>)) (= <-- (hd (fst Parse_<head*>))))
     (let Parse_<body*>
      (shen-<body*>
       (shen-reassemble (tl (fst Parse_<head*>)) (snd Parse_<head*>)))
      (if (not (= (fail) Parse_<body*>))
       (let Parse_<end*> (shen-<end*> Parse_<body*>)
        (if (not (= (fail) Parse_<end*>))
         (shen-reassemble (fst Parse_<end*>)
          (cons (snd Parse_<head*>) (cons (snd Parse_<body*>) ())))
         (fail)))
       (fail)))
     (fail))
    (fail)))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<head*> (V4820)
 (let Result
  (let Parse_<term*> (shen-<term*> V4820)
   (if (not (= (fail) Parse_<term*>))
    (let Parse_<head*> (shen-<head*> Parse_<term*>)
     (if (not (= (fail) Parse_<head*>))
      (shen-reassemble (fst Parse_<head*>)
       (cons (snd Parse_<term*>) (snd Parse_<head*>)))
      (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<e> (<e> V4820)
     (if (not (= (fail) Parse_<e>))
      (shen-reassemble (fst Parse_<e>) (snd Parse_<e>)) (fail)))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<term*> (V4821)
 (let Result
  (if (cons? (fst V4821))
   (shen-reassemble (fst (shen-reassemble (tl (fst V4821)) (snd V4821)))
    (if
     (and (not (= <-- (hd (fst V4821))))
      (shen-legitimate-term? (hd (fst V4821))))
     (shen-eval-cons (hd (fst V4821))) (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-legitimate-term? (V4826)
 (cond
  ((and (cons? V4826)
    (and (= cons (hd V4826))
     (and (cons? (tl V4826))
      (and (cons? (tl (tl V4826))) (= () (tl (tl (tl V4826))))))))
   (and (shen-legitimate-term? (hd (tl V4826)))
    (shen-legitimate-term? (hd (tl (tl V4826))))))
  ((and (cons? V4826)
    (and (= mode (hd V4826))
     (and (cons? (tl V4826))
      (and (cons? (tl (tl V4826)))
       (and (= + (hd (tl (tl V4826)))) (= () (tl (tl (tl V4826)))))))))
   (shen-legitimate-term? (hd (tl V4826))))
  ((and (cons? V4826)
    (and (= mode (hd V4826))
     (and (cons? (tl V4826))
      (and (cons? (tl (tl V4826)))
       (and (= - (hd (tl (tl V4826)))) (= () (tl (tl (tl V4826)))))))))
   (shen-legitimate-term? (hd (tl V4826))))
  ((cons? V4826) false) (true true)))

(defun shen-eval-cons (V4827)
 (cond
  ((and (cons? V4827)
    (and (= cons (hd V4827))
     (and (cons? (tl V4827))
      (and (cons? (tl (tl V4827))) (= () (tl (tl (tl V4827))))))))
   (cons (shen-eval-cons (hd (tl V4827)))
    (shen-eval-cons (hd (tl (tl V4827))))))
  ((and (cons? V4827)
    (and (= mode (hd V4827))
     (and (cons? (tl V4827))
      (and (cons? (tl (tl V4827))) (= () (tl (tl (tl V4827))))))))
   (cons mode (cons (shen-eval-cons (hd (tl V4827))) (tl (tl V4827)))))
  (true V4827)))

(defun shen-<body*> (V4828)
 (let Result
  (let Parse_<literal*> (shen-<literal*> V4828)
   (if (not (= (fail) Parse_<literal*>))
    (let Parse_<body*> (shen-<body*> Parse_<literal*>)
     (if (not (= (fail) Parse_<body*>))
      (shen-reassemble (fst Parse_<body*>)
       (cons (snd Parse_<literal*>) (snd Parse_<body*>)))
      (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<e> (<e> V4828)
     (if (not (= (fail) Parse_<e>))
      (shen-reassemble (fst Parse_<e>) (snd Parse_<e>)) (fail)))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<literal*> (V4829)
 (let Result
  (if (and (cons? (fst V4829)) (= ! (hd (fst V4829))))
   (shen-reassemble (fst (shen-reassemble (tl (fst V4829)) (snd V4829)))
    (cons cut (cons Throwcontrol ())))
   (fail))
  (if (= Result (fail))
   (let Result
    (if (cons? (fst V4829))
     (shen-reassemble (fst (shen-reassemble (tl (fst V4829)) (snd V4829)))
      (if (cons? (hd (fst V4829))) (hd (fst V4829)) (fail)))
     (fail))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<end*> (V4830)
 (let Result
  (if (cons? (fst V4830))
   (shen-reassemble (fst (shen-reassemble (tl (fst V4830)) (snd V4830)))
    (if (= (hd (fst V4830)) ;) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun cut (V4831 V4832 V4833)
 (let Result (thaw V4833) (if (= Result false) V4831 Result)))

(defun shen-insert_modes (V4834)
 (cond
  ((and (cons? V4834)
    (and (= mode (hd V4834))
     (and (cons? (tl V4834))
      (and (cons? (tl (tl V4834))) (= () (tl (tl (tl V4834))))))))
   V4834)
  ((= () V4834) ())
  ((cons? V4834)
   (cons (cons mode (cons (hd V4834) (cons + ())))
    (cons mode (cons (shen-insert_modes (tl V4834)) (cons - ())))))
  (true V4834)))

(defun shen-s-prolog (V4835)
 (map (lambda V4836 (eval V4836)) (shen-prolog->shen V4835)))

(defun shen-prolog->shen (V4837)
 (map (lambda V4838 (shen-compile_prolog_procedure V4838))
  (shen-group_clauses
   (map (lambda V4839 (shen-s-prolog_clause V4839))
    (mapcan (lambda V4840 (shen-head_abstraction V4840)) V4837)))))

(defun shen-s-prolog_clause (V4841)
 (cond
  ((and (cons? V4841)
    (and (cons? (tl V4841))
     (and (= :- (hd (tl V4841)))
      (and (cons? (tl (tl V4841))) (= () (tl (tl (tl V4841))))))))
   (cons (hd V4841)
    (cons :-
     (cons
      (map (lambda V4842 (shen-s-prolog_literal V4842)) (hd (tl (tl V4841))))
      ()))))
  (true (shen-sys-error shen-s-prolog_clause))))

(defun shen-head_abstraction (V4843)
 (cond
  ((and (cons? V4843)
    (and (cons? (tl V4843))
     (and (= :- (hd (tl V4843)))
      (and (cons? (tl (tl V4843)))
       (and (= () (tl (tl (tl V4843))))
        (< (shen-complexity_head (hd V4843))
         (value shen-*maxcomplexity*)))))))
   (cons V4843 ()))
  ((and (cons? V4843)
    (and (cons? (hd V4843))
     (and (cons? (tl V4843))
      (and (= :- (hd (tl V4843)))
       (and (cons? (tl (tl V4843))) (= () (tl (tl (tl V4843)))))))))
   (let Terms (map (lambda Y (gensym V)) (tl (hd V4843)))
    (let XTerms (shen-rcons_form (shen-remove_modes (tl (hd V4843))))
     (let Literal (cons unify (cons (shen-cons_form Terms) (cons XTerms ())))
      (let Clause
       (cons (cons (hd (hd V4843)) Terms)
        (cons :- (cons (cons Literal (hd (tl (tl V4843)))) ())))
       (cons Clause ()))))))
  (true (shen-sys-error shen-head_abstraction))))

(defun shen-complexity_head (V4848)
 (cond
  ((cons? V4848)
   (shen-product (map (lambda V4849 (shen-complexity V4849)) (tl V4848))))
  (true (shen-sys-error shen-complexity_head))))

(defun shen-complexity (V4857)
 (cond
  ((and (cons? V4857)
    (and (= mode (hd V4857))
     (and (cons? (tl V4857))
      (and (cons? (hd (tl V4857)))
       (and (= mode (hd (hd (tl V4857))))
        (and (cons? (tl (hd (tl V4857))))
         (and (cons? (tl (tl (hd (tl V4857)))))
          (and (= () (tl (tl (tl (hd (tl V4857))))))
           (and (cons? (tl (tl V4857)))
            (= () (tl (tl (tl V4857)))))))))))))
   (shen-complexity (hd (tl V4857))))
  ((and (cons? V4857)
    (and (= mode (hd V4857))
     (and (cons? (tl V4857))
      (and (cons? (hd (tl V4857)))
       (and (cons? (tl (tl V4857)))
        (and (= + (hd (tl (tl V4857))))
         (= () (tl (tl (tl V4857))))))))))
   (* 2
    (*
     (shen-complexity (cons mode (cons (hd (hd (tl V4857))) (tl (tl V4857)))))
     (shen-complexity
      (cons mode (cons (tl (hd (tl V4857))) (tl (tl V4857))))))))
  ((and (cons? V4857)
    (and (= mode (hd V4857))
     (and (cons? (tl V4857))
      (and (cons? (hd (tl V4857)))
       (and (cons? (tl (tl V4857)))
        (and (= - (hd (tl (tl V4857))))
         (= () (tl (tl (tl V4857))))))))))
   (* (shen-complexity (cons mode (cons (hd (hd (tl V4857))) (tl (tl V4857)))))
    (shen-complexity (cons mode (cons (tl (hd (tl V4857))) (tl (tl V4857)))))))
  ((and (cons? V4857)
    (and (= mode (hd V4857))
     (and (cons? (tl V4857))
      (and (cons? (tl (tl V4857)))
       (and (= () (tl (tl (tl V4857)))) (variable? (hd (tl V4857))))))))
   1)
  ((and (cons? V4857)
    (and (= mode (hd V4857))
     (and (cons? (tl V4857))
      (and (cons? (tl (tl V4857)))
       (and (= + (hd (tl (tl V4857)))) (= () (tl (tl (tl V4857)))))))))
   2)
  ((and (cons? V4857)
    (and (= mode (hd V4857))
     (and (cons? (tl V4857))
      (and (cons? (tl (tl V4857)))
       (and (= - (hd (tl (tl V4857)))) (= () (tl (tl (tl V4857)))))))))
   1)
  (true (shen-complexity (cons mode (cons V4857 (cons + ())))))))

(defun shen-product (V4858)
 (cond ((= () V4858) 1)
  ((cons? V4858) (* (hd V4858) (shen-product (tl V4858))))
  (true (shen-sys-error shen-product))))

(defun shen-s-prolog_literal (V4859)
 (cond
  ((and (cons? V4859)
    (and (= is (hd V4859))
     (and (cons? (tl V4859))
      (and (cons? (tl (tl V4859))) (= () (tl (tl (tl V4859))))))))
   (cons bind
    (cons (hd (tl V4859))
     (cons (shen-insert_deref (hd (tl (tl V4859)))) ()))))
  ((and (cons? V4859)
    (and (= when (hd V4859))
     (and (cons? (tl V4859)) (= () (tl (tl V4859))))))
   (cons fwhen (cons (shen-insert_deref (hd (tl V4859))) ())))
  ((and (cons? V4859)
    (and (= bind (hd V4859))
     (and (cons? (tl V4859))
      (and (cons? (tl (tl V4859))) (= () (tl (tl (tl V4859))))))))
   (cons bind
    (cons (hd (tl V4859))
     (cons (shen-insert_lazyderef (hd (tl (tl V4859)))) ()))))
  ((and (cons? V4859)
    (and (= fwhen (hd V4859))
     (and (cons? (tl V4859)) (= () (tl (tl V4859))))))
   (cons fwhen (cons (shen-insert_lazyderef (hd (tl V4859))) ())))
  ((cons? V4859)
   (cons (shen-m_prolog_to_s-prolog_predicate (hd V4859)) (tl V4859)))
  (true (shen-sys-error shen-s-prolog_literal))))

(defun shen-insert_deref (V4860)
 (cond ((variable? V4860) (cons shen-deref (cons V4860 (cons ProcessN ()))))
  ((cons? V4860)
   (cons (shen-insert_deref (hd V4860)) (shen-insert_deref (tl V4860))))
  (true V4860)))

(defun shen-insert_lazyderef (V4861)
 (cond
  ((variable? V4861) (cons shen-lazyderef (cons V4861 (cons ProcessN ()))))
  ((cons? V4861)
   (cons (shen-insert_lazyderef (hd V4861))
    (shen-insert_lazyderef (tl V4861))))
  (true V4861)))

(defun shen-m_prolog_to_s-prolog_predicate (V4862)
 (cond ((= = V4862) unify) ((= =! V4862) unify!)
  ((= == V4862) identical) (true V4862)))

(defun shen-group_clauses (V4863)
 (cond ((= () V4863) ())
  ((cons? V4863)
   (let Group
    (shen-collect (lambda X (shen-same_predicate? (hd V4863) X)) V4863)
    (let Rest (difference V4863 Group)
     (cons Group (shen-group_clauses Rest)))))
  (true (shen-sys-error shen-group_clauses))))

(defun shen-collect (V4866 V4867)
 (cond ((= () V4867) ())
  ((cons? V4867)
   (if (V4866 (hd V4867)) (cons (hd V4867) (shen-collect V4866 (tl V4867)))
    (shen-collect V4866 (tl V4867))))
  (true (shen-sys-error shen-collect))))

(defun shen-same_predicate? (V4884 V4885)
 (cond
  ((and (cons? V4884)
    (and (cons? (hd V4884)) (and (cons? V4885) (cons? (hd V4885)))))
   (= (hd (hd V4884)) (hd (hd V4885))))
  (true (shen-sys-error shen-same_predicate?))))

(defun shen-compile_prolog_procedure (V4886)
 (let F (shen-procedure_name V4886)
  (let Shen (shen-clauses-to-shen F V4886) Shen)))

(defun shen-procedure_name (V4899)
 (cond
  ((and (cons? V4899) (and (cons? (hd V4899)) (cons? (hd (hd V4899)))))
   (hd (hd (hd V4899))))
  (true (shen-sys-error shen-procedure_name))))

(defun shen-clauses-to-shen (V4900 V4901)
 (let Linear (map (lambda V4902 (shen-linearise-clause V4902)) V4901)
  (let Arity
   (shen-prolog-aritycheck V4900 (map (lambda V4903 (head V4903)) V4901))
   (let Parameters (shen-parameters Arity)
    (let AUM_instructions (map (lambda X (shen-aum X Parameters)) Linear)
     (let Code
      (shen-catch-cut
       (shen-nest-disjunct
        (map (lambda V4904 (shen-aum_to_shen V4904)) AUM_instructions)))
      (let ShenDef
       (cons define
        (cons V4900
         (append Parameters
          (append (cons ProcessN (cons Continuation ()))
           (cons -> (cons Code ()))))))
       ShenDef)))))))

(defun shen-catch-cut (V4905)
 (cond ((not (shen-occurs? cut V4905)) V4905)
  (true
   (cons let
    (cons Throwcontrol
     (cons (cons shen-catchpoint ())
      (cons (cons shen-cutpoint (cons Throwcontrol (cons V4905 ())))
       ())))))))

(defun shen-catchpoint () (set shen-*catch* (+ 1 (value shen-*catch*))))

(defun shen-cutpoint (V4910 V4911)
 (cond ((= V4911 V4910) false) (true V4911)))

(defun shen-nest-disjunct (V4913)
 (cond ((and (cons? V4913) (= () (tl V4913))) (hd V4913))
  ((cons? V4913) (shen-lisp-or (hd V4913) (shen-nest-disjunct (tl V4913))))
  (true (shen-sys-error shen-nest-disjunct))))

(defun shen-lisp-or (V4914 V4915)
 (cons let
  (cons Case
   (cons V4914
    (cons
     (cons if
      (cons (cons = (cons Case (cons false ())))
       (cons V4915 (cons Case ()))))
     ())))))

(defun shen-prolog-aritycheck (V4918 V4919)
 (cond ((and (cons? V4919) (= () (tl V4919))) (- (length (hd V4919)) 1))
  ((and (cons? V4919) (cons? (tl V4919)))
   (if (= (length (hd V4919)) (length (hd (tl V4919))))
    (shen-prolog-aritycheck V4918 (tl V4919))
    (interror "arity error in prolog procedure ~A~%"
     (@p (cons V4918 ()) ()))))
  (true (shen-sys-error shen-prolog-aritycheck))))

(defun shen-linearise-clause (V4920)
 (cond
  ((and (cons? V4920)
    (and (cons? (tl V4920))
     (and (= :- (hd (tl V4920)))
      (and (cons? (tl (tl V4920))) (= () (tl (tl (tl V4920))))))))
   (let Linear (shen-linearise (cons (hd V4920) (tl (tl V4920))))
    (shen-clause_form Linear)))
  (true (shen-sys-error shen-linearise-clause))))

(defun shen-clause_form (V4921)
 (cond
  ((and (cons? V4921) (and (cons? (tl V4921)) (= () (tl (tl V4921)))))
   (cons (shen-explicit_modes (hd V4921))
    (cons :- (cons (shen-cf_help (hd (tl V4921))) ()))))
  (true (shen-sys-error shen-clause_form))))

(defun shen-explicit_modes (V4922)
 (cond
  ((cons? V4922)
   (cons (hd V4922) (map (lambda V4923 (shen-em_help V4923)) (tl V4922))))
  (true (shen-sys-error shen-explicit_modes))))

(defun shen-em_help (V4924)
 (cond
  ((and (cons? V4924)
    (and (= mode (hd V4924))
     (and (cons? (tl V4924))
      (and (cons? (tl (tl V4924))) (= () (tl (tl (tl V4924))))))))
   V4924)
  (true (cons mode (cons V4924 (cons + ()))))))

(defun shen-cf_help (V4925)
 (cond
  ((and (cons? V4925)
    (and (= where (hd V4925))
     (and (cons? (tl V4925))
      (and (cons? (hd (tl V4925)))
       (and (= = (hd (hd (tl V4925))))
        (and (cons? (tl (hd (tl V4925))))
         (and (cons? (tl (tl (hd (tl V4925)))))
          (and (= () (tl (tl (tl (hd (tl V4925))))))
           (and (cons? (tl (tl V4925)))
            (= () (tl (tl (tl V4925)))))))))))))
   (cons (cons (if (value shen-*occurs*) unify! unify) (tl (hd (tl V4925))))
    (shen-cf_help (hd (tl (tl V4925))))))
  (true V4925)))

(defun occurs-check (V4930)
 (cond ((= + V4930) (set shen-*occurs* true))
  ((= - V4930) (set shen-*occurs* false))
  (true (interror "occurs-check expects + or -~%" ()))))

(defun shen-aum (V4931 V4932)
 (cond
  ((and (cons? V4931)
    (and (cons? (hd V4931))
     (and (cons? (tl V4931))
      (and (= :- (hd (tl V4931)))
       (and (cons? (tl (tl V4931))) (= () (tl (tl (tl V4931)))))))))
   (let MuApplication
    (shen-make_mu_application
     (cons shen-mu
      (cons (tl (hd V4931))
       (cons (shen-continuation_call (tl (hd V4931)) (hd (tl (tl V4931))))
        ())))
     V4932)
    (shen-mu_reduction MuApplication +)))
  (true (shen-sys-error shen-aum))))

(defun shen-continuation_call (V4933 V4934)
 (let VTerms (cons ProcessN (shen-extract_vars V4933))
  (let VBody (shen-extract_vars V4934)
   (let Free (remove Throwcontrol (difference VBody VTerms))
    (shen-cc_help Free V4934)))))

(defun remove (V4935 V4936) (shen-remove-h V4935 V4936 ()))

(defun shen-remove-h (V4939 V4940 V4941)
 (cond ((= () V4940) (reverse V4941))
  ((and (cons? V4940) (= (hd V4940) V4939))
   (shen-remove-h (hd V4940) (tl V4940) V4941))
  ((cons? V4940) (shen-remove-h V4939 (tl V4940) (cons (hd V4940) V4941)))
  (true (shen-sys-error shen-remove-h))))

(defun shen-cc_help (V4943 V4944)
 (cond
  ((and (= () V4943) (= () V4944))
   (cons shen-pop (cons shen-the (cons shen-stack ()))))
  ((= () V4944)
   (cons shen-rename
    (cons shen-the
     (cons shen-variables
      (cons in
       (cons V4943
        (cons and
         (cons shen-then
          (cons (cons shen-pop (cons shen-the (cons shen-stack ())))
           ())))))))))
  ((= () V4943)
   (cons call (cons shen-the (cons shen-continuation (cons V4944 ())))))
  (true
   (cons shen-rename
    (cons shen-the
     (cons shen-variables
      (cons in
       (cons V4943
        (cons and
         (cons shen-then
          (cons
           (cons call
            (cons shen-the (cons shen-continuation (cons V4944 ()))))
           ())))))))))))

(defun shen-make_mu_application (V4945 V4946)
 (cond
  ((and (cons? V4945)
    (and (= shen-mu (hd V4945))
     (and (cons? (tl V4945))
      (and (= () (hd (tl V4945)))
       (and (cons? (tl (tl V4945)))
        (and (= () (tl (tl (tl V4945)))) (= () V4946)))))))
   (hd (tl (tl V4945))))
  ((and (cons? V4945)
    (and (= shen-mu (hd V4945))
     (and (cons? (tl V4945))
      (and (cons? (hd (tl V4945)))
       (and (cons? (tl (tl V4945)))
        (and (= () (tl (tl (tl V4945)))) (cons? V4946)))))))
   (cons
    (cons shen-mu
     (cons (hd (hd (tl V4945)))
      (cons
       (shen-make_mu_application
        (cons shen-mu (cons (tl (hd (tl V4945))) (tl (tl V4945)))) (tl V4946))
       ())))
    (cons (hd V4946) ())))
  (true (shen-sys-error shen-make_mu_application))))

(defun shen-mu_reduction (V4953 V4954)
 (cond
  ((and (cons? V4953)
    (and (cons? (hd V4953))
     (and (= shen-mu (hd (hd V4953)))
      (and (cons? (tl (hd V4953)))
       (and (cons? (hd (tl (hd V4953))))
        (and (= mode (hd (hd (tl (hd V4953)))))
         (and (cons? (tl (hd (tl (hd V4953)))))
          (and (cons? (tl (tl (hd (tl (hd V4953))))))
           (and (= () (tl (tl (tl (hd (tl (hd V4953)))))))
            (and (cons? (tl (tl (hd V4953))))
             (and (= () (tl (tl (tl (hd V4953)))))
              (and (cons? (tl V4953)) (= () (tl (tl V4953)))))))))))))))
   (shen-mu_reduction
    (cons
     (cons shen-mu (cons (hd (tl (hd (tl (hd V4953))))) (tl (tl (hd V4953)))))
     (tl V4953))
    (hd (tl (tl (hd (tl (hd V4953))))))))
  ((and (cons? V4953)
    (and (cons? (hd V4953))
     (and (= shen-mu (hd (hd V4953)))
      (and (cons? (tl (hd V4953)))
       (and (cons? (tl (tl (hd V4953))))
        (and (= () (tl (tl (tl (hd V4953)))))
         (and (cons? (tl V4953))
          (and (= () (tl (tl V4953))) (= _ (hd (tl (hd V4953))))))))))))
   (shen-mu_reduction (hd (tl (tl (hd V4953)))) V4954))
  ((and (cons? V4953)
    (and (cons? (hd V4953))
     (and (= shen-mu (hd (hd V4953)))
      (and (cons? (tl (hd V4953)))
       (and (cons? (tl (tl (hd V4953))))
        (and (= () (tl (tl (tl (hd V4953)))))
         (and (cons? (tl V4953))
          (and (= () (tl (tl V4953)))
           (shen-ephemeral_variable? (hd (tl (hd V4953)))
            (hd (tl V4953)))))))))))
   (subst (hd (tl V4953)) (hd (tl (hd V4953)))
    (shen-mu_reduction (hd (tl (tl (hd V4953)))) V4954)))
  ((and (cons? V4953)
    (and (cons? (hd V4953))
     (and (= shen-mu (hd (hd V4953)))
      (and (cons? (tl (hd V4953)))
       (and (cons? (tl (tl (hd V4953))))
        (and (= () (tl (tl (tl (hd V4953)))))
         (and (cons? (tl V4953))
          (and (= () (tl (tl V4953)))
           (variable? (hd (tl (hd V4953))))))))))))
   (cons let
    (cons (hd (tl (hd V4953)))
     (cons shen-be
      (cons (hd (tl V4953))
       (cons in
        (cons (shen-mu_reduction (hd (tl (tl (hd V4953)))) V4954) ())))))))
  ((and (cons? V4953)
    (and (cons? (hd V4953))
     (and (= shen-mu (hd (hd V4953)))
      (and (cons? (tl (hd V4953)))
       (and (cons? (tl (tl (hd V4953))))
        (and (= () (tl (tl (tl (hd V4953)))))
         (and (cons? (tl V4953))
          (and (= () (tl (tl V4953)))
           (and (= - V4954)
            (shen-prolog_constant? (hd (tl (hd V4953)))))))))))))
   (let Z (gensym V)
    (cons let
     (cons Z
      (cons shen-be
       (cons
        (cons shen-the
         (cons shen-result
          (cons shen-of (cons shen-dereferencing (tl V4953)))))
        (cons in
         (cons
          (cons if
           (cons
            (cons Z
             (cons is
              (cons identical (cons shen-to (cons (hd (tl (hd V4953))) ())))))
            (cons shen-then
             (cons (shen-mu_reduction (hd (tl (tl (hd V4953)))) -)
              (cons shen-else (cons fail! ()))))))
          ()))))))))
  ((and (cons? V4953)
    (and (cons? (hd V4953))
     (and (= shen-mu (hd (hd V4953)))
      (and (cons? (tl (hd V4953)))
       (and (cons? (tl (tl (hd V4953))))
        (and (= () (tl (tl (tl (hd V4953)))))
         (and (cons? (tl V4953))
          (and (= () (tl (tl V4953)))
           (and (= + V4954)
            (shen-prolog_constant? (hd (tl (hd V4953)))))))))))))
   (let Z (gensym V)
    (cons let
     (cons Z
      (cons shen-be
       (cons
        (cons shen-the
         (cons shen-result
          (cons shen-of (cons shen-dereferencing (tl V4953)))))
        (cons in
         (cons
          (cons if
           (cons
            (cons Z
             (cons is
              (cons identical (cons shen-to (cons (hd (tl (hd V4953))) ())))))
            (cons shen-then
             (cons (shen-mu_reduction (hd (tl (tl (hd V4953)))) +)
              (cons shen-else
               (cons
                (cons if
                 (cons
                  (cons Z (cons is (cons shen-a (cons shen-variable ()))))
                  (cons shen-then
                   (cons
                    (cons bind
                     (cons Z
                      (cons shen-to
                       (cons (hd (tl (hd V4953)))
                        (cons in
                         (cons (shen-mu_reduction (hd (tl (tl (hd V4953)))) +)
                          ()))))))
                    (cons shen-else (cons fail! ()))))))
                ()))))))
          ()))))))))
  ((and (cons? V4953)
    (and (cons? (hd V4953))
     (and (= shen-mu (hd (hd V4953)))
      (and (cons? (tl (hd V4953)))
       (and (cons? (hd (tl (hd V4953))))
        (and (cons? (tl (tl (hd V4953))))
         (and (= () (tl (tl (tl (hd V4953)))))
          (and (cons? (tl V4953))
           (and (= () (tl (tl V4953))) (= - V4954))))))))))
   (let Z (gensym V)
    (cons let
     (cons Z
      (cons shen-be
       (cons
        (cons shen-the
         (cons shen-result
          (cons shen-of (cons shen-dereferencing (tl V4953)))))
        (cons in
         (cons
          (cons if
           (cons
            (cons Z
             (cons is (cons shen-a (cons shen-non-empty (cons list ())))))
            (cons shen-then
             (cons
              (shen-mu_reduction
               (cons
                (cons shen-mu
                 (cons (hd (hd (tl (hd V4953))))
                  (cons
                   (cons
                    (cons shen-mu
                     (cons (tl (hd (tl (hd V4953)))) (tl (tl (hd V4953)))))
                    (cons
                     (cons shen-the (cons tail (cons shen-of (cons Z ()))))
                     ()))
                   ())))
                (cons (cons shen-the (cons head (cons shen-of (cons Z ()))))
                 ()))
               -)
              (cons shen-else (cons fail! ()))))))
          ()))))))))
  ((and (cons? V4953)
    (and (cons? (hd V4953))
     (and (= shen-mu (hd (hd V4953)))
      (and (cons? (tl (hd V4953)))
       (and (cons? (hd (tl (hd V4953))))
        (and (cons? (tl (tl (hd V4953))))
         (and (= () (tl (tl (tl (hd V4953)))))
          (and (cons? (tl V4953))
           (and (= () (tl (tl V4953))) (= + V4954))))))))))
   (let Z (gensym V)
    (cons let
     (cons Z
      (cons shen-be
       (cons
        (cons shen-the
         (cons shen-result
          (cons shen-of (cons shen-dereferencing (tl V4953)))))
        (cons in
         (cons
          (cons if
           (cons
            (cons Z
             (cons is (cons shen-a (cons shen-non-empty (cons list ())))))
            (cons shen-then
             (cons
              (shen-mu_reduction
               (cons
                (cons shen-mu
                 (cons (hd (hd (tl (hd V4953))))
                  (cons
                   (cons
                    (cons shen-mu
                     (cons (tl (hd (tl (hd V4953)))) (tl (tl (hd V4953)))))
                    (cons
                     (cons shen-the (cons tail (cons shen-of (cons Z ()))))
                     ()))
                   ())))
                (cons (cons shen-the (cons head (cons shen-of (cons Z ()))))
                 ()))
               +)
              (cons shen-else
               (cons
                (cons if
                 (cons
                  (cons Z (cons is (cons shen-a (cons shen-variable ()))))
                  (cons shen-then
                   (cons
                    (cons shen-rename
                     (cons shen-the
                      (cons shen-variables
                       (cons in
                        (cons (shen-extract_vars (hd (tl (hd V4953))))
                         (cons and
                          (cons shen-then
                           (cons
                            (cons bind
                             (cons Z
                              (cons shen-to
                               (cons
                                (shen-rcons_form
                                 (shen-remove_modes (hd (tl (hd V4953)))))
                                (cons in
                                 (cons
                                  (shen-mu_reduction (hd (tl (tl (hd V4953))))
                                   +)
                                  ()))))))
                            ()))))))))
                    (cons shen-else (cons fail! ()))))))
                ()))))))
          ()))))))))
  (true V4953)))

(defun shen-rcons_form (V4955)
 (cond
  ((cons? V4955)
   (cons cons
    (cons (shen-rcons_form (hd V4955))
     (cons (shen-rcons_form (tl V4955)) ()))))
  (true V4955)))

(defun shen-remove_modes (V4956)
 (cond
  ((and (cons? V4956)
    (and (= mode (hd V4956))
     (and (cons? (tl V4956))
      (and (cons? (tl (tl V4956)))
       (and (= + (hd (tl (tl V4956)))) (= () (tl (tl (tl V4956)))))))))
   (shen-remove_modes (hd (tl V4956))))
  ((and (cons? V4956)
    (and (= mode (hd V4956))
     (and (cons? (tl V4956))
      (and (cons? (tl (tl V4956)))
       (and (= - (hd (tl (tl V4956)))) (= () (tl (tl (tl V4956)))))))))
   (shen-remove_modes (hd (tl V4956))))
  ((cons? V4956)
   (cons (shen-remove_modes (hd V4956)) (shen-remove_modes (tl V4956))))
  (true V4956)))

(defun shen-ephemeral_variable? (V4957 V4958)
 (and (variable? V4957) (variable? V4958)))

(defun shen-prolog_constant? (V4967) (cond ((cons? V4967) false) (true true)))

(defun shen-aum_to_shen (V4968)
 (cond
  ((and (cons? V4968)
    (and (= let (hd V4968))
     (and (cons? (tl V4968))
      (and (cons? (tl (tl V4968)))
       (and (= shen-be (hd (tl (tl V4968))))
        (and (cons? (tl (tl (tl V4968))))
         (and (cons? (tl (tl (tl (tl V4968)))))
          (and (= in (hd (tl (tl (tl (tl V4968))))))
           (and (cons? (tl (tl (tl (tl (tl V4968))))))
            (= () (tl (tl (tl (tl (tl (tl V4968))))))))))))))))
   (cons let
    (cons (hd (tl V4968))
     (cons (shen-aum_to_shen (hd (tl (tl (tl V4968)))))
      (cons (shen-aum_to_shen (hd (tl (tl (tl (tl (tl V4968))))))) ())))))
  ((and (cons? V4968)
    (and (= shen-the (hd V4968))
     (and (cons? (tl V4968))
      (and (= shen-result (hd (tl V4968)))
       (and (cons? (tl (tl V4968)))
        (and (= shen-of (hd (tl (tl V4968))))
         (and (cons? (tl (tl (tl V4968))))
          (and (= shen-dereferencing (hd (tl (tl (tl V4968)))))
           (and (cons? (tl (tl (tl (tl V4968)))))
            (= () (tl (tl (tl (tl (tl V4968)))))))))))))))
   (cons shen-lazyderef
    (cons (shen-aum_to_shen (hd (tl (tl (tl (tl V4968))))))
     (cons ProcessN ()))))
  ((and (cons? V4968)
    (and (= if (hd V4968))
     (and (cons? (tl V4968))
      (and (cons? (tl (tl V4968)))
       (and (= shen-then (hd (tl (tl V4968))))
        (and (cons? (tl (tl (tl V4968))))
         (and (cons? (tl (tl (tl (tl V4968)))))
          (and (= shen-else (hd (tl (tl (tl (tl V4968))))))
           (and (cons? (tl (tl (tl (tl (tl V4968))))))
            (= () (tl (tl (tl (tl (tl (tl V4968))))))))))))))))
   (cons if
    (cons (shen-aum_to_shen (hd (tl V4968)))
     (cons (shen-aum_to_shen (hd (tl (tl (tl V4968)))))
      (cons (shen-aum_to_shen (hd (tl (tl (tl (tl (tl V4968))))))) ())))))
  ((and (cons? V4968)
    (and (cons? (tl V4968))
     (and (= is (hd (tl V4968)))
      (and (cons? (tl (tl V4968)))
       (and (= shen-a (hd (tl (tl V4968))))
        (and (cons? (tl (tl (tl V4968))))
         (and (= shen-variable (hd (tl (tl (tl V4968)))))
          (= () (tl (tl (tl (tl V4968))))))))))))
   (cons shen-pvar? (cons (hd V4968) ())))
  ((and (cons? V4968)
    (and (cons? (tl V4968))
     (and (= is (hd (tl V4968)))
      (and (cons? (tl (tl V4968)))
       (and (= shen-a (hd (tl (tl V4968))))
        (and (cons? (tl (tl (tl V4968))))
         (and (= shen-non-empty (hd (tl (tl (tl V4968)))))
          (and (cons? (tl (tl (tl (tl V4968)))))
           (and (= list (hd (tl (tl (tl (tl V4968))))))
            (= () (tl (tl (tl (tl (tl V4968)))))))))))))))
   (cons cons? (cons (hd V4968) ())))
  ((and (cons? V4968)
    (and (= shen-rename (hd V4968))
     (and (cons? (tl V4968))
      (and (= shen-the (hd (tl V4968)))
       (and (cons? (tl (tl V4968)))
        (and (= shen-variables (hd (tl (tl V4968))))
         (and (cons? (tl (tl (tl V4968))))
          (and (= in (hd (tl (tl (tl V4968)))))
           (and (cons? (tl (tl (tl (tl V4968)))))
            (and (= () (hd (tl (tl (tl (tl V4968))))))
             (and (cons? (tl (tl (tl (tl (tl V4968))))))
              (and (= and (hd (tl (tl (tl (tl (tl V4968)))))))
               (and (cons? (tl (tl (tl (tl (tl (tl V4968)))))))
                (and (= shen-then (hd (tl (tl (tl (tl (tl (tl V4968))))))))
                 (and (cons? (tl (tl (tl (tl (tl (tl (tl V4968))))))))
                  (= ()
                   (tl
                    (tl (tl (tl (tl (tl (tl (tl V4968))))))))))))))))))))))))
   (shen-aum_to_shen (hd (tl (tl (tl (tl (tl (tl (tl V4968))))))))))
  ((and (cons? V4968)
    (and (= shen-rename (hd V4968))
     (and (cons? (tl V4968))
      (and (= shen-the (hd (tl V4968)))
       (and (cons? (tl (tl V4968)))
        (and (= shen-variables (hd (tl (tl V4968))))
         (and (cons? (tl (tl (tl V4968))))
          (and (= in (hd (tl (tl (tl V4968)))))
           (and (cons? (tl (tl (tl (tl V4968)))))
            (and (cons? (hd (tl (tl (tl (tl V4968))))))
             (and (cons? (tl (tl (tl (tl (tl V4968))))))
              (and (= and (hd (tl (tl (tl (tl (tl V4968)))))))
               (and (cons? (tl (tl (tl (tl (tl (tl V4968)))))))
                (and (= shen-then (hd (tl (tl (tl (tl (tl (tl V4968))))))))
                 (and (cons? (tl (tl (tl (tl (tl (tl (tl V4968))))))))
                  (= ()
                   (tl
                    (tl (tl (tl (tl (tl (tl (tl V4968))))))))))))))))))))))))
   (cons let
    (cons (hd (hd (tl (tl (tl (tl V4968))))))
     (cons (cons shen-newpv (cons ProcessN ()))
      (cons
       (shen-aum_to_shen
        (cons shen-rename
         (cons shen-the
          (cons shen-variables
           (cons in
            (cons (tl (hd (tl (tl (tl (tl V4968))))))
             (tl (tl (tl (tl (tl V4968)))))))))))
       ())))))
  ((and (cons? V4968)
    (and (= bind (hd V4968))
     (and (cons? (tl V4968))
      (and (cons? (tl (tl V4968)))
       (and (= shen-to (hd (tl (tl V4968))))
        (and (cons? (tl (tl (tl V4968))))
         (and (cons? (tl (tl (tl (tl V4968)))))
          (and (= in (hd (tl (tl (tl (tl V4968))))))
           (and (cons? (tl (tl (tl (tl (tl V4968))))))
            (= () (tl (tl (tl (tl (tl (tl V4968))))))))))))))))
   (cons do
    (cons
     (cons shen-bindv
      (cons (hd (tl V4968))
       (cons (shen-chwild (hd (tl (tl (tl V4968))))) (cons ProcessN ()))))
     (cons
      (cons let
       (cons Result
        (cons (shen-aum_to_shen (hd (tl (tl (tl (tl (tl V4968)))))))
         (cons
          (cons do
           (cons (cons shen-unbindv (cons (hd (tl V4968)) (cons ProcessN ())))
            (cons Result ())))
          ()))))
      ()))))
  ((and (cons? V4968)
    (and (cons? (tl V4968))
     (and (= is (hd (tl V4968)))
      (and (cons? (tl (tl V4968)))
       (and (= identical (hd (tl (tl V4968))))
        (and (cons? (tl (tl (tl V4968))))
         (and (= shen-to (hd (tl (tl (tl V4968)))))
          (and (cons? (tl (tl (tl (tl V4968)))))
           (= () (tl (tl (tl (tl (tl V4968))))))))))))))
   (cons = (cons (hd (tl (tl (tl (tl V4968))))) (cons (hd V4968) ()))))
  ((= fail! V4968) false)
  ((and (cons? V4968)
    (and (= shen-the (hd V4968))
     (and (cons? (tl V4968))
      (and (= head (hd (tl V4968)))
       (and (cons? (tl (tl V4968)))
        (and (= shen-of (hd (tl (tl V4968))))
         (and (cons? (tl (tl (tl V4968))))
          (= () (tl (tl (tl (tl V4968))))))))))))
   (cons hd (tl (tl (tl V4968)))))
  ((and (cons? V4968)
    (and (= shen-the (hd V4968))
     (and (cons? (tl V4968))
      (and (= tail (hd (tl V4968)))
       (and (cons? (tl (tl V4968)))
        (and (= shen-of (hd (tl (tl V4968))))
         (and (cons? (tl (tl (tl V4968))))
          (= () (tl (tl (tl (tl V4968))))))))))))
   (cons tl (tl (tl (tl V4968)))))
  ((and (cons? V4968)
    (and (= shen-pop (hd V4968))
     (and (cons? (tl V4968))
      (and (= shen-the (hd (tl V4968)))
       (and (cons? (tl (tl V4968)))
        (and (= shen-stack (hd (tl (tl V4968))))
         (= () (tl (tl (tl V4968))))))))))
   (cons do
    (cons (cons shen-incinfs ())
     (cons (cons thaw (cons Continuation ())) ()))))
  ((and (cons? V4968)
    (and (= call (hd V4968))
     (and (cons? (tl V4968))
      (and (= shen-the (hd (tl V4968)))
       (and (cons? (tl (tl V4968)))
        (and (= shen-continuation (hd (tl (tl V4968))))
         (and (cons? (tl (tl (tl V4968))))
          (= () (tl (tl (tl (tl V4968))))))))))))
   (cons do
    (cons (cons shen-incinfs ())
     (cons
      (shen-call_the_continuation (shen-chwild (hd (tl (tl (tl V4968)))))
       ProcessN Continuation)
      ()))))
  (true V4968)))

(defun shen-chwild (V4969)
 (cond ((= V4969 _) (cons shen-newpv (cons ProcessN ())))
  ((cons? V4969) (map (lambda V4970 (shen-chwild V4970)) V4969)) (true V4969)))

(defun shen-newpv (V4971)
 (let Count+1 (+ (<-address (value shen-*varcounter*) V4971) 1)
  (let IncVar (address-> (value shen-*varcounter*) V4971 Count+1)
   (let Vector (<-address (value shen-*prologvectors*) V4971)
    (let ResizeVectorIfNeeded
     (if (= Count+1 (limit Vector)) (shen-resizeprocessvector V4971 Count+1)
      shen-skip)
     (shen-mk-pvar Count+1))))))

(defun shen-resizeprocessvector (V4972 V4973)
 (let Vector (<-address (value shen-*prologvectors*) V4972)
  (let BigVector (shen-resize-vector Vector (+ V4973 V4973) shen--null-)
   (address-> (value shen-*prologvectors*) V4972 BigVector))))

(defun shen-resize-vector (V4974 V4975 V4976)
 (let BigVector (address-> (absvector (+ 1 V4975)) 0 V4975)
  (shen-copy-vector V4974 BigVector (limit V4974) V4975 V4976)))

(defun shen-copy-vector (V4977 V4978 V4979 V4980 V4981)
 (shen-copy-vector-stage-2 (+ 1 V4979) (+ V4980 1) V4981
  (shen-copy-vector-stage-1 1 V4977 V4978 (+ 1 V4979))))

(defun shen-copy-vector-stage-1 (V4984 V4985 V4986 V4987)
 (cond ((= V4987 V4984) V4986)
  (true
   (shen-copy-vector-stage-1 (+ 1 V4984) V4985
    (address-> V4986 V4984 (<-address V4985 V4984)) V4987))))

(defun shen-copy-vector-stage-2 (V4991 V4992 V4993 V4994)
 (cond ((= V4992 V4991) V4994)
  (true
   (shen-copy-vector-stage-2 (+ V4991 1) V4992 V4993
    (address-> V4994 V4991 V4993)))))

(defun shen-mk-pvar (V4996)
 (address-> (address-> (absvector 2) 0 shen-pvar) 1 V4996))

(defun shen-pvar? (V4997)
 (and (absvector? V4997) (= (<-address V4997 0) shen-pvar)))

(defun shen-bindv (V4998 V4999 V5000)
 (let Vector (<-address (value shen-*prologvectors*) V5000)
  (address-> Vector (<-address V4998 1) V4999)))

(defun shen-unbindv (V5001 V5002)
 (let Vector (<-address (value shen-*prologvectors*) V5002)
  (address-> Vector (<-address V5001 1) shen--null-)))

(defun shen-incinfs () (set shen-*infs* (+ 1 (value shen-*infs*))))

(defun shen-call_the_continuation (V5003 V5004 V5005)
 (cond
  ((and (cons? V5003) (and (cons? (hd V5003)) (= () (tl V5003))))
   (cons (hd (hd V5003))
    (append (tl (hd V5003)) (cons V5004 (cons V5005 ())))))
  ((and (cons? V5003) (cons? (hd V5003)))
   (let NewContinuation (shen-newcontinuation (tl V5003) V5004 V5005)
    (cons (hd (hd V5003))
     (append (tl (hd V5003)) (cons V5004 (cons NewContinuation ()))))))
  (true (shen-sys-error shen-call_the_continuation))))

(defun shen-newcontinuation (V5006 V5007 V5008)
 (cond ((= () V5006) V5008)
  ((and (cons? V5006) (cons? (hd V5006)))
   (cons freeze
    (cons
     (cons (hd (hd V5006))
      (append (tl (hd V5006))
       (cons V5007 (cons (shen-newcontinuation (tl V5006) V5007 V5008) ()))))
     ())))
  (true (shen-sys-error shen-newcontinuation))))

(defun return (V5013 V5014 V5015) (shen-deref V5013 V5014))

(defun shen-measure&return (V5020 V5021 V5022)
 (do (intoutput "~A inferences~%" (@p (value shen-*infs*) ()))
  (shen-deref V5020 V5021)))

(defun unify (V5023 V5024 V5025 V5026)
 (shen-lzy= (shen-lazyderef V5023 V5025) (shen-lazyderef V5024 V5025) V5025
  V5026))

(defun shen-lzy= (V5043 V5044 V5045 V5046)
 (cond ((= V5044 V5043) (thaw V5046))
  ((shen-pvar? V5043) (bind V5043 V5044 V5045 V5046))
  ((shen-pvar? V5044) (bind V5044 V5043 V5045 V5046))
  ((and (cons? V5043) (cons? V5044))
   (shen-lzy= (shen-lazyderef (hd V5043) V5045)
    (shen-lazyderef (hd V5044) V5045) V5045
    (freeze
     (shen-lzy= (shen-lazyderef (tl V5043) V5045)
      (shen-lazyderef (tl V5044) V5045) V5045 V5046))))
  (true false)))

(defun shen-deref (V5048 V5049)
 (cond
  ((cons? V5048)
   (cons (shen-deref (hd V5048) V5049) (shen-deref (tl V5048) V5049)))
  (true
   (if (shen-pvar? V5048)
    (let Value (shen-valvector V5048 V5049)
     (if (= Value shen--null-) V5048 (shen-deref Value V5049)))
    V5048))))

(defun shen-lazyderef (V5050 V5051)
 (if (shen-pvar? V5050)
  (let Value (shen-valvector V5050 V5051)
   (if (= Value shen--null-) V5050 (shen-lazyderef Value V5051)))
  V5050))

(defun shen-valvector (V5052 V5053)
 (<-address (<-address (value shen-*prologvectors*) V5053)
  (<-address V5052 1)))

(defun unify! (V5054 V5055 V5056 V5057)
 (shen-lzy=! (shen-lazyderef V5054 V5056) (shen-lazyderef V5055 V5056) V5056
  V5057))

(defun shen-lzy=! (V5074 V5075 V5076 V5077)
 (cond ((= V5075 V5074) (thaw V5077))
  ((and (shen-pvar? V5074) (not (shen-occurs? V5074 (shen-deref V5075 V5076))))
   (bind V5074 V5075 V5076 V5077))
  ((and (shen-pvar? V5075) (not (shen-occurs? V5075 (shen-deref V5074 V5076))))
   (bind V5075 V5074 V5076 V5077))
  ((and (cons? V5074) (cons? V5075))
   (shen-lzy=! (shen-lazyderef (hd V5074) V5076)
    (shen-lazyderef (hd V5075) V5076) V5076
    (freeze
     (shen-lzy=! (shen-lazyderef (tl V5074) V5076)
      (shen-lazyderef (tl V5075) V5076) V5076 V5077))))
  (true false)))

(defun shen-occurs? (V5087 V5088)
 (cond ((= V5088 V5087) true)
  ((cons? V5088)
   (or (shen-occurs? V5087 (hd V5088)) (shen-occurs? V5087 (tl V5088))))
  (true false)))

(defun identical (V5090 V5091 V5092 V5093)
 (shen-lzy== (shen-lazyderef V5090 V5092) (shen-lazyderef V5091 V5092) V5092
  V5093))

(defun shen-lzy== (V5110 V5111 V5112 V5113)
 (cond ((= V5111 V5110) (thaw V5113))
  ((and (cons? V5110) (cons? V5111))
   (shen-lzy== (shen-lazyderef (hd V5110) V5112)
    (shen-lazyderef (hd V5111) V5112) V5112
    (freeze (shen-lzy== (tl V5110) (tl V5111) V5112 V5113))))
  (true false)))

(defun shen-pvar (V5115) (intmake-string "Var~A" (@p (<-address V5115 1) ())))

(defun bind (V5116 V5117 V5118 V5119)
 (do (shen-bindv V5116 V5117 V5118)
  (let Result (thaw V5119) (do (shen-unbindv V5116 V5118) Result))))

(defun fwhen (V5134 V5135 V5136)
 (cond ((= true V5134) (thaw V5136)) ((= false V5134) false)
  (true (interror "fwhen expects a boolean: not ~S%" (@p V5134 ())))))

(defun call (V5149 V5150 V5151)
 (cond
  ((cons? V5149)
   (shen-call-help
    (shen-m_prolog_to_s-prolog_predicate (shen-lazyderef (hd V5149) V5150))
    (tl V5149) V5150 V5151))
  (true false)))

(defun shen-call-help (V5152 V5153 V5154 V5155)
 (cond ((= () V5153) (V5152 V5154 V5155))
  ((cons? V5153) (shen-call-help (V5152 (hd V5153)) (tl V5153) V5154 V5155))
  (true (shen-sys-error shen-call-help))))

(defun shen-intprolog (V5156)
 (cond
  ((and (cons? V5156) (cons? (hd V5156)))
   (let ProcessN (shen-start-new-prolog-process)
    (shen-intprolog-help (hd (hd V5156))
     (shen-insert-prolog-variables (cons (tl (hd V5156)) (cons (tl V5156) ()))
      ProcessN)
     ProcessN)))
  (true (shen-sys-error shen-intprolog))))

(defun shen-intprolog-help (V5157 V5158 V5159)
 (cond
  ((and (cons? V5158) (and (cons? (tl V5158)) (= () (tl (tl V5158)))))
   (shen-intprolog-help-help V5157 (hd V5158) (hd (tl V5158)) V5159))
  (true (shen-sys-error shen-intprolog-help))))

(defun shen-intprolog-help-help (V5160 V5161 V5162 V5163)
 (cond ((= () V5161) (V5160 V5163 (freeze (shen-call-rest V5162 V5163))))
  ((cons? V5161)
   (shen-intprolog-help-help (V5160 (hd V5161)) (tl V5161) V5162 V5163))
  (true (shen-sys-error shen-intprolog-help-help))))

(defun shen-call-rest (V5166 V5167)
 (cond ((= () V5166) true)
  ((and (cons? V5166) (and (cons? (hd V5166)) (cons? (tl (hd V5166)))))
   (shen-call-rest
    (cons (cons ((hd (hd V5166)) (hd (tl (hd V5166)))) (tl (tl (hd V5166))))
     (tl V5166))
    V5167))
  ((and (cons? V5166) (and (cons? (hd V5166)) (= () (tl (hd V5166)))))
   ((hd (hd V5166)) V5167 (freeze (shen-call-rest (tl V5166) V5167))))
  (true (shen-sys-error shen-call-rest))))

(defun shen-start-new-prolog-process ()
 (let IncrementProcessCounter
  (set shen-*process-counter* (+ 1 (value shen-*process-counter*)))
  (shen-initialise-prolog IncrementProcessCounter)))

(defun shen-insert-prolog-variables (V5168 V5169)
 (shen-insert-prolog-variables-help V5168 (shen-flatten V5168) V5169))

(defun shen-insert-prolog-variables-help (V5174 V5175 V5176)
 (cond ((= () V5175) V5174)
  ((and (cons? V5175) (variable? (hd V5175)))
   (let V (shen-newpv V5176)
    (let XV/Y (subst V (hd V5175) V5174)
     (let Z-Y (remove (hd V5175) (tl V5175))
      (shen-insert-prolog-variables-help XV/Y Z-Y V5176)))))
  ((cons? V5175) (shen-insert-prolog-variables-help V5174 (tl V5175) V5176))
  (true (shen-sys-error shen-insert-prolog-variables-help))))

(defun shen-initialise-prolog (V5177)
 (let Vector
  (address-> (value shen-*prologvectors*) V5177
   (shen-fillvector (vector 10) 1 11 shen--null-))
  (let Counter (address-> (value shen-*varcounter*) V5177 1) V5177)))

