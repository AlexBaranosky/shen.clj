
"                                                   The License

 The user is free to produce commercial applications with the software, to distribute these applications in source or binary  form, and to charge monies for them as he sees fit and in concordance with the laws of the land subject to the following  license.

 1. The license applies to all the software and all derived software and must appear on such.
 2. It is illegal to distribute the software without this license attached to it and use of the software implies agreement
    with the license as such. It is illegal for anyone who is not the copyright holder to tamper with or change the license.
 3. Neither the names of Lambda Associates or the copyright holder may be used to endorse or promote products built using
     the software without specific prior written permission from the copyright holder.
 4. That possession of this license does not confer on the copyright holder any special contractual obligation towards the    user. That in no event shall the copyright holder be liable for any direct, indirect, incidental, special, exemplary or   consequential damages (including but not limited to procurement of substitute goods or services, loss of use, data, or    profits; or business interruption), however caused and on any theory of liability, whether in contract, strict liability   or tort (including negligence) arising in any way out of the use of the software, even if advised of the possibility of   such damage.
5. It is permitted for the user to change the software, for the purpose of improving performance, correcting an error, or    porting to a new platform, and distribute the modified version of Shen (hereafter the modified version) provided the     resulting program conforms in all respects to the Shen standard and is issued under that title. The user must make it clear   with his distribution that he/she is the author of the changes and what these changes are and why.
6. Derived versions of this software in whatever form are subject to the same restrictions. In particular it is not          permitted to make derived copies of this software which do not conform to the Shen standard or appear under a different title.
7. It is permitted to distribute versions of Shen which incorporate libraries, graphics or other facilities which are not    part of the Shen standard.

For an explication of this license see http://www.lambdassociates.org/News/june11/license.htm which explains this license in full."

(defun shen-shen->kl (V4025 V4026)
 (compile (lambda V4027 (shen-<define> V4027)) (cons V4025 V4026)
  (lambda X (shen-shen-syntax-error V4025 X))))

(defun shen-shen-syntax-error (V4028 V4029)
 (interror "syntax error in ~A here:~%~% ~A~%"
  (@p V4028 (@p (shen-next-50 50 V4029) ()))))

(defun shen-<define> (V4030)
 (let Result
  (let Parse_<name> (shen-<name> V4030)
   (if (not (= (fail) Parse_<name>))
    (let Parse_<signature> (shen-<signature> Parse_<name>)
     (if (not (= (fail) Parse_<signature>))
      (let Parse_<rules> (shen-<rules> Parse_<signature>)
       (if (not (= (fail) Parse_<rules>))
        (shen-reassemble (fst Parse_<rules>)
         (shen-compile_to_machine_code (snd Parse_<name>) (snd Parse_<rules>)))
        (fail)))
      (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<name> (shen-<name> V4030)
     (if (not (= (fail) Parse_<name>))
      (let Parse_<rules> (shen-<rules> Parse_<name>)
       (if (not (= (fail) Parse_<rules>))
        (shen-reassemble (fst Parse_<rules>)
         (shen-compile_to_machine_code (snd Parse_<name>) (snd Parse_<rules>)))
        (fail)))
      (fail)))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<name> (V4031)
 (let Result
  (if (cons? (fst V4031))
   (shen-reassemble (fst (shen-reassemble (tl (fst V4031)) (snd V4031)))
    (if (and (symbol? (hd (fst V4031))) (not (shen-sysfunc? (hd (fst V4031)))))
     (hd (fst V4031))
     (interror "~A is not a legitimate function name.~%"
      (@p (hd (fst V4031)) ()))))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-sysfunc? (V4032) (element? V4032 (value shen-*system*)))

(defun shen-<signature> (V4033)
 (let Result
  (if (and (cons? (fst V4033)) (= { (hd (fst V4033))))
   (let Parse_<signature-help>
    (shen-<signature-help> (shen-reassemble (tl (fst V4033)) (snd V4033)))
    (if (not (= (fail) Parse_<signature-help>))
     (if
      (and (cons? (fst Parse_<signature-help>))
       (= } (hd (fst Parse_<signature-help>))))
      (shen-reassemble
       (fst
        (shen-reassemble (tl (fst Parse_<signature-help>))
         (snd Parse_<signature-help>)))
       (shen-normalise-type (shen-curry-type (snd Parse_<signature-help>))))
      (fail))
     (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-curry-type (V4036)
 (cond
  ((and (cons? V4036)
    (and (cons? (tl V4036))
     (and (= --> (hd (tl V4036)))
      (and (cons? (tl (tl V4036)))
       (and (cons? (tl (tl (tl V4036))))
        (= --> (hd (tl (tl (tl V4036))))))))))
   (shen-curry-type (cons (hd V4036) (cons --> (cons (tl (tl V4036)) ())))))
  ((and (cons? V4036)
    (and (= cons (hd V4036))
     (and (cons? (tl V4036))
      (and (cons? (tl (tl V4036))) (= () (tl (tl (tl V4036))))))))
   (cons list (cons (shen-curry-type (hd (tl V4036))) ())))
  ((and (cons? V4036)
    (and (cons? (tl V4036))
     (and (= * (hd (tl V4036)))
      (and (cons? (tl (tl V4036)))
       (and (cons? (tl (tl (tl V4036))))
        (= * (hd (tl (tl (tl V4036))))))))))
   (shen-curry-type (cons (hd V4036) (cons * (cons (tl (tl V4036)) ())))))
  ((cons? V4036) (map (lambda V4037 (shen-curry-type V4037)) V4036))
  (true V4036)))

(defun shen-<signature-help> (V4038)
 (let Result
  (if (cons? (fst V4038))
   (let Parse_<signature-help>
    (shen-<signature-help> (shen-reassemble (tl (fst V4038)) (snd V4038)))
    (if (not (= (fail) Parse_<signature-help>))
     (shen-reassemble (fst Parse_<signature-help>)
      (if (element? (hd (fst V4038)) (cons { (cons } ()))) (fail)
       (cons (hd (fst V4038)) (snd Parse_<signature-help>))))
     (fail)))
   (fail))
  (if (= Result (fail))
   (let Result
    (let Parse_<e> (<e> V4038)
     (if (not (= (fail) Parse_<e>)) (shen-reassemble (fst Parse_<e>) ())
      (fail)))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<rules> (V4039)
 (let Result
  (let Parse_<rule> (shen-<rule> V4039)
   (if (not (= (fail) Parse_<rule>))
    (let Parse_<rules> (shen-<rules> Parse_<rule>)
     (if (not (= (fail) Parse_<rules>))
      (shen-reassemble (fst Parse_<rules>)
       (cons (snd Parse_<rule>) (snd Parse_<rules>)))
      (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<rule> (shen-<rule> V4039)
     (if (not (= (fail) Parse_<rule>))
      (shen-reassemble (fst Parse_<rule>) (cons (snd Parse_<rule>) ()))
      (fail)))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<rule> (V4040)
 (let Result
  (let Parse_<patterns> (shen-<patterns> V4040)
   (if (not (= (fail) Parse_<patterns>))
    (if
     (and (cons? (fst Parse_<patterns>)) (= -> (hd (fst Parse_<patterns>))))
     (let Parse_<action>
      (shen-<action>
       (shen-reassemble (tl (fst Parse_<patterns>)) (snd Parse_<patterns>)))
      (if (not (= (fail) Parse_<action>))
       (if
        (and (cons? (fst Parse_<action>))
         (= where (hd (fst Parse_<action>))))
        (let Parse_<guard>
         (shen-<guard>
          (shen-reassemble (tl (fst Parse_<action>)) (snd Parse_<action>)))
         (if (not (= (fail) Parse_<guard>))
          (shen-reassemble (fst Parse_<guard>)
           (cons (snd Parse_<patterns>)
            (cons
             (cons where
              (cons (snd Parse_<guard>) (cons (snd Parse_<action>) ())))
             ())))
          (fail)))
        (fail))
       (fail)))
     (fail))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<patterns> (shen-<patterns> V4040)
     (if (not (= (fail) Parse_<patterns>))
      (if
       (and (cons? (fst Parse_<patterns>))
        (= -> (hd (fst Parse_<patterns>))))
       (let Parse_<action>
        (shen-<action>
         (shen-reassemble (tl (fst Parse_<patterns>)) (snd Parse_<patterns>)))
        (if (not (= (fail) Parse_<action>))
         (shen-reassemble (fst Parse_<action>)
          (cons (snd Parse_<patterns>) (cons (snd Parse_<action>) ())))
         (fail)))
       (fail))
      (fail)))
    (if (= Result (fail))
     (let Result
      (let Parse_<patterns> (shen-<patterns> V4040)
       (if (not (= (fail) Parse_<patterns>))
        (if
         (and (cons? (fst Parse_<patterns>))
          (= <- (hd (fst Parse_<patterns>))))
         (let Parse_<action>
          (shen-<action>
           (shen-reassemble (tl (fst Parse_<patterns>))
            (snd Parse_<patterns>)))
          (if (not (= (fail) Parse_<action>))
           (if
            (and (cons? (fst Parse_<action>))
             (= where (hd (fst Parse_<action>))))
            (let Parse_<guard>
             (shen-<guard>
              (shen-reassemble (tl (fst Parse_<action>)) (snd Parse_<action>)))
             (if (not (= (fail) Parse_<guard>))
              (shen-reassemble (fst Parse_<guard>)
               (cons (snd Parse_<patterns>)
                (cons
                 (cons where
                  (cons (snd Parse_<guard>)
                   (cons
                    (cons shen-choicepoint! (cons (snd Parse_<action>) ()))
                    ())))
                 ())))
              (fail)))
            (fail))
           (fail)))
         (fail))
        (fail)))
      (if (= Result (fail))
       (let Result
        (let Parse_<patterns> (shen-<patterns> V4040)
         (if (not (= (fail) Parse_<patterns>))
          (if
           (and (cons? (fst Parse_<patterns>))
            (= <- (hd (fst Parse_<patterns>))))
           (let Parse_<action>
            (shen-<action>
             (shen-reassemble (tl (fst Parse_<patterns>))
              (snd Parse_<patterns>)))
            (if (not (= (fail) Parse_<action>))
             (shen-reassemble (fst Parse_<action>)
              (cons (snd Parse_<patterns>)
               (cons (cons shen-choicepoint! (cons (snd Parse_<action>) ()))
                ())))
             (fail)))
           (fail))
          (fail)))
        (if (= Result (fail)) (fail) Result))
       Result))
     Result))
   Result)))

(defun shen-fail_if (V4041 V4042) (if (V4041 V4042) (fail) V4042))

(defun shen-succeeds? (V4047) (cond ((= V4047 (fail)) false) (true true)))

(defun shen-<patterns> (V4048)
 (let Result
  (let Parse_<pattern> (shen-<pattern> V4048)
   (if (not (= (fail) Parse_<pattern>))
    (let Parse_<patterns> (shen-<patterns> Parse_<pattern>)
     (if (not (= (fail) Parse_<patterns>))
      (shen-reassemble (fst Parse_<patterns>)
       (cons (snd Parse_<pattern>) (snd Parse_<patterns>)))
      (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<e> (<e> V4048)
     (if (not (= (fail) Parse_<e>)) (shen-reassemble (fst Parse_<e>) ())
      (fail)))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<pattern> (V4049)
 (let Result
  (if (and (cons? (fst V4049)) (cons? (hd (fst V4049))))
   (shen-snd-or-fail
    (if
     (and (cons? (fst (shen-reassemble (hd (fst V4049)) (snd V4049))))
      (= @p (hd (fst (shen-reassemble (hd (fst V4049)) (snd V4049))))))
     (let Parse_<pattern1>
      (shen-<pattern1>
       (shen-reassemble
        (tl (fst (shen-reassemble (hd (fst V4049)) (snd V4049))))
        (snd (shen-reassemble (hd (fst V4049)) (snd V4049)))))
      (if (not (= (fail) Parse_<pattern1>))
       (let Parse_<pattern2> (shen-<pattern2> Parse_<pattern1>)
        (if (not (= (fail) Parse_<pattern2>))
         (shen-reassemble (fst Parse_<pattern2>)
          (shen-reassemble (fst (shen-reassemble (tl (fst V4049)) (snd V4049)))
           (cons @p
            (cons (snd Parse_<pattern1>) (cons (snd Parse_<pattern2>) ())))))
         (fail)))
       (fail)))
     (fail)))
   (fail))
  (if (= Result (fail))
   (let Result
    (if (and (cons? (fst V4049)) (cons? (hd (fst V4049))))
     (shen-snd-or-fail
      (if
       (and (cons? (fst (shen-reassemble (hd (fst V4049)) (snd V4049))))
        (= cons (hd (fst (shen-reassemble (hd (fst V4049)) (snd V4049))))))
       (let Parse_<pattern1>
        (shen-<pattern1>
         (shen-reassemble
          (tl (fst (shen-reassemble (hd (fst V4049)) (snd V4049))))
          (snd (shen-reassemble (hd (fst V4049)) (snd V4049)))))
        (if (not (= (fail) Parse_<pattern1>))
         (let Parse_<pattern2> (shen-<pattern2> Parse_<pattern1>)
          (if (not (= (fail) Parse_<pattern2>))
           (shen-reassemble (fst Parse_<pattern2>)
            (shen-reassemble
             (fst (shen-reassemble (tl (fst V4049)) (snd V4049)))
             (cons cons
              (cons (snd Parse_<pattern1>)
               (cons (snd Parse_<pattern2>) ())))))
           (fail)))
         (fail)))
       (fail)))
     (fail))
    (if (= Result (fail))
     (let Result
      (if (and (cons? (fst V4049)) (cons? (hd (fst V4049))))
       (shen-snd-or-fail
        (if
         (and (cons? (fst (shen-reassemble (hd (fst V4049)) (snd V4049))))
          (= @v (hd (fst (shen-reassemble (hd (fst V4049)) (snd V4049))))))
         (let Parse_<pattern1>
          (shen-<pattern1>
           (shen-reassemble
            (tl (fst (shen-reassemble (hd (fst V4049)) (snd V4049))))
            (snd (shen-reassemble (hd (fst V4049)) (snd V4049)))))
          (if (not (= (fail) Parse_<pattern1>))
           (let Parse_<pattern2> (shen-<pattern2> Parse_<pattern1>)
            (if (not (= (fail) Parse_<pattern2>))
             (shen-reassemble (fst Parse_<pattern2>)
              (shen-reassemble
               (fst (shen-reassemble (tl (fst V4049)) (snd V4049)))
               (cons @v
                (cons (snd Parse_<pattern1>)
                 (cons (snd Parse_<pattern2>) ())))))
             (fail)))
           (fail)))
         (fail)))
       (fail))
      (if (= Result (fail))
       (let Result
        (if (and (cons? (fst V4049)) (cons? (hd (fst V4049))))
         (shen-snd-or-fail
          (if
           (and (cons? (fst (shen-reassemble (hd (fst V4049)) (snd V4049))))
            (= @s
             (hd (fst (shen-reassemble (hd (fst V4049)) (snd V4049))))))
           (let Parse_<pattern1>
            (shen-<pattern1>
             (shen-reassemble
              (tl (fst (shen-reassemble (hd (fst V4049)) (snd V4049))))
              (snd (shen-reassemble (hd (fst V4049)) (snd V4049)))))
            (if (not (= (fail) Parse_<pattern1>))
             (let Parse_<pattern2> (shen-<pattern2> Parse_<pattern1>)
              (if (not (= (fail) Parse_<pattern2>))
               (shen-reassemble (fst Parse_<pattern2>)
                (shen-reassemble
                 (fst (shen-reassemble (tl (fst V4049)) (snd V4049)))
                 (cons @s
                  (cons (snd Parse_<pattern1>)
                   (cons (snd Parse_<pattern2>) ())))))
               (fail)))
             (fail)))
           (fail)))
         (fail))
        (if (= Result (fail))
         (let Result
          (if (and (cons? (fst V4049)) (cons? (hd (fst V4049))))
           (shen-snd-or-fail
            (if
             (and (cons? (fst (shen-reassemble (hd (fst V4049)) (snd V4049))))
              (= vector
               (hd (fst (shen-reassemble (hd (fst V4049)) (snd V4049))))))
             (if
              (and
               (cons?
                (fst
                 (shen-reassemble
                  (tl (fst (shen-reassemble (hd (fst V4049)) (snd V4049))))
                  (snd (shen-reassemble (hd (fst V4049)) (snd V4049))))))
               (= 0
                (hd
                 (fst
                  (shen-reassemble
                   (tl (fst (shen-reassemble (hd (fst V4049)) (snd V4049))))
                   (snd (shen-reassemble (hd (fst V4049)) (snd V4049))))))))
              (shen-reassemble
               (fst
                (shen-reassemble
                 (tl
                  (fst
                   (shen-reassemble
                    (tl (fst (shen-reassemble (hd (fst V4049)) (snd V4049))))
                    (snd (shen-reassemble (hd (fst V4049)) (snd V4049))))))
                 (snd
                  (shen-reassemble
                   (tl (fst (shen-reassemble (hd (fst V4049)) (snd V4049))))
                   (snd (shen-reassemble (hd (fst V4049)) (snd V4049)))))))
               (shen-reassemble
                (fst (shen-reassemble (tl (fst V4049)) (snd V4049)))
                (cons vector (cons 0 ()))))
              (fail))
             (fail)))
           (fail))
          (if (= Result (fail))
           (let Result
            (if (cons? (fst V4049))
             (shen-reassemble
              (fst (shen-reassemble (tl (fst V4049)) (snd V4049)))
              (if (cons? (hd (fst V4049)))
               (interror "~A is not a legitimate constructor~%"
                (@p (hd (fst V4049)) ()))
               (fail)))
             (fail))
            (if (= Result (fail))
             (let Result
              (let Parse_<simple_pattern> (shen-<simple_pattern> V4049)
               (if (not (= (fail) Parse_<simple_pattern>))
                (shen-reassemble (fst Parse_<simple_pattern>)
                 (snd Parse_<simple_pattern>))
                (fail)))
              (if (= Result (fail)) (fail) Result))
             Result))
           Result))
         Result))
       Result))
     Result))
   Result)))

(defun shen-<simple_pattern> (V4050)
 (let Result
  (if (cons? (fst V4050))
   (shen-reassemble (fst (shen-reassemble (tl (fst V4050)) (snd V4050)))
    (if (= (hd (fst V4050)) _) (gensym X) (fail)))
   (fail))
  (if (= Result (fail))
   (let Result
    (if (cons? (fst V4050))
     (shen-reassemble (fst (shen-reassemble (tl (fst V4050)) (snd V4050)))
      (if (element? (hd (fst V4050)) (cons -> (cons <- ()))) (fail)
       (hd (fst V4050))))
     (fail))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<pattern1> (V4051)
 (let Result
  (let Parse_<pattern> (shen-<pattern> V4051)
   (if (not (= (fail) Parse_<pattern>))
    (shen-reassemble (fst Parse_<pattern>) (snd Parse_<pattern>)) (fail)))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<pattern2> (V4052)
 (let Result
  (let Parse_<pattern> (shen-<pattern> V4052)
   (if (not (= (fail) Parse_<pattern>))
    (shen-reassemble (fst Parse_<pattern>) (snd Parse_<pattern>)) (fail)))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<action> (V4053)
 (let Result
  (if (cons? (fst V4053))
   (shen-reassemble (fst (shen-reassemble (tl (fst V4053)) (snd V4053)))
    (hd (fst V4053)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<guard> (V4054)
 (let Result
  (if (cons? (fst V4054))
   (shen-reassemble (fst (shen-reassemble (tl (fst V4054)) (snd V4054)))
    (hd (fst V4054)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-compile_to_machine_code (V4055 V4056)
 (let Lambda+ (shen-compile_to_lambda+ V4055 V4056)
  (let KL (shen-compile_to_kl V4055 Lambda+)
   (let Record (shen-record-source V4055 KL) KL))))

(defun shen-record-source (V4059 V4060)
 (cond ((value shen-*installing-kl*) shen-skip)
  (true (put V4059 shen-source V4060 (value shen-*property-vector*)))))

(defun shen-compile_to_lambda+ (V4061 V4062)
 (let Arity (shen-aritycheck V4061 V4062)
  (let Free (map (lambda Rule (shen-free_variable_check V4061 Rule)) V4062)
   (let Variables (shen-parameters Arity)
    (let Linear (map shen-linearise (shen-strip-protect V4062))
     (let Abstractions (map (lambda V4063 (shen-abstract_rule V4063)) Linear)
      (let Applications
       (map (lambda X (shen-application_build Variables X)) Abstractions)
       (cons Variables (cons Applications ())))))))))

(defun shen-free_variable_check (V4064 V4065)
 (cond
  ((and (cons? V4065) (and (cons? (tl V4065)) (= () (tl (tl V4065)))))
   (let Bound (shen-extract_vars (hd V4065))
    (let Free (shen-extract_free_vars Bound (hd (tl V4065)))
     (shen-free_variable_warnings V4064 Free))))
  (true (shen-sys-error shen-free_variable_check))))

(defun shen-extract_vars (V4066)
 (cond ((variable? V4066) (cons V4066 ()))
  ((cons? V4066)
   (union (shen-extract_vars (hd V4066)) (shen-extract_vars (tl V4066))))
  (true ())))

(defun shen-extract_free_vars (V4077 V4078)
 (cond
  ((and (cons? V4078)
    (and (= protect (hd V4078))
     (and (cons? (tl V4078)) (= () (tl (tl V4078))))))
   ())
  ((and (variable? V4078) (not (element? V4078 V4077))) (cons V4078 ()))
  ((and (cons? V4078)
    (and (= lambda (hd V4078))
     (and (cons? (tl V4078))
      (and (cons? (tl (tl V4078))) (= () (tl (tl (tl V4078))))))))
   (shen-extract_free_vars (cons (hd (tl V4078)) V4077) (hd (tl (tl V4078)))))
  ((and (cons? V4078)
    (and (= let (hd V4078))
     (and (cons? (tl V4078))
      (and (cons? (tl (tl V4078)))
       (and (cons? (tl (tl (tl V4078))))
        (= () (tl (tl (tl (tl V4078))))))))))
   (union (shen-extract_free_vars V4077 (hd (tl (tl V4078))))
    (shen-extract_free_vars (cons (hd (tl V4078)) V4077)
     (hd (tl (tl (tl V4078)))))))
  ((cons? V4078)
   (union (shen-extract_free_vars V4077 (hd V4078))
    (shen-extract_free_vars V4077 (tl V4078))))
  (true ())))

(defun shen-free_variable_warnings (V4081 V4082)
 (cond ((= () V4082) _)
  (true
   (interror "error: the following variables are free in ~A: ~A"
    (@p V4081 (@p (shen-list_variables V4082) ()))))))

(defun shen-list_variables (V4083)
 (cond ((and (cons? V4083) (= () (tl V4083))) (cn (str (hd V4083)) "."))
  ((cons? V4083)
   (cn (str (hd V4083)) (cn ", " (shen-list_variables (tl V4083)))))
  (true (shen-sys-error shen-list_variables))))

(defun shen-strip-protect (V4084)
 (cond
  ((and (cons? V4084)
    (and (= protect (hd V4084))
     (and (cons? (tl V4084)) (= () (tl (tl V4084))))))
   (hd (tl V4084)))
  ((cons? V4084)
   (cons (shen-strip-protect (hd V4084)) (shen-strip-protect (tl V4084))))
  (true V4084)))

(defun shen-linearise (V4085)
 (cond
  ((and (cons? V4085) (and (cons? (tl V4085)) (= () (tl (tl V4085)))))
   (shen-linearise_help (shen-flatten (hd V4085)) (hd V4085) (hd (tl V4085))))
  (true (shen-sys-error shen-linearise))))

(defun shen-flatten (V4086)
 (cond ((= () V4086) ())
  ((cons? V4086) (append (shen-flatten (hd V4086)) (shen-flatten (tl V4086))))
  (true (cons V4086 ()))))

(defun shen-linearise_help (V4087 V4088 V4089)
 (cond ((= () V4087) (cons V4088 (cons V4089 ())))
  ((cons? V4087)
   (if (and (variable? (hd V4087)) (element? (hd V4087) (tl V4087)))
    (let Var (gensym (hd V4087))
     (let NewAction
      (cons where
       (cons (cons = (cons (hd V4087) (cons Var ()))) (cons V4089 ())))
      (let NewPatts (shen-linearise_X (hd V4087) Var V4088)
       (shen-linearise_help (tl V4087) NewPatts NewAction))))
    (shen-linearise_help (tl V4087) V4088 V4089)))
  (true (shen-sys-error shen-linearise_help))))

(defun shen-linearise_X (V4098 V4099 V4100)
 (cond ((= V4100 V4098) V4099)
  ((cons? V4100)
   (let L (shen-linearise_X V4098 V4099 (hd V4100))
    (if (= L (hd V4100))
     (cons (hd V4100) (shen-linearise_X V4098 V4099 (tl V4100)))
     (cons L (tl V4100)))))
  (true V4100)))

(defun shen-aritycheck (V4102 V4103)
 (cond
  ((and (cons? V4103)
    (and (cons? (hd V4103))
     (and (cons? (tl (hd V4103)))
      (and (= () (tl (tl (hd V4103)))) (= () (tl V4103))))))
   (do (shen-aritycheck-action (hd (tl (hd V4103))))
    (shen-aritycheck-name V4102 (arity V4102) (length (hd (hd V4103))))))
  ((and (cons? V4103)
    (and (cons? (hd V4103))
     (and (cons? (tl (hd V4103)))
      (and (= () (tl (tl (hd V4103))))
       (and (cons? (tl V4103))
        (and (cons? (hd (tl V4103)))
         (and (cons? (tl (hd (tl V4103))))
          (= () (tl (tl (hd (tl V4103))))))))))))
   (if (= (length (hd (hd V4103))) (length (hd (hd (tl V4103)))))
    (do (shen-aritycheck-action Action) (shen-aritycheck V4102 (tl V4103)))
    (interror "arity error in ~A~%" (@p V4102 ()))))
  (true (shen-sys-error shen-aritycheck))))

(defun shen-aritycheck-name (V4112 V4113 V4114)
 (cond ((= -1 V4113) V4114) ((= V4114 V4113) V4114)
  (true
   (do
    (intoutput "~%warning: changing the arity of ~A can cause errors.~%"
     (@p V4112 ()))
    V4114))))

(defun shen-aritycheck-action (V4120)
 (cond
  ((cons? V4120)
   (do (shen-aah (hd V4120) (tl V4120))
    (map (lambda V4121 (shen-aritycheck-action V4121)) V4120)))
  (true shen-skip)))

(defun shen-aah (V4122 V4123)
 (let Arity (arity V4122)
  (let Len (length V4123)
   (if (and (> Arity -1) (> Len Arity))
    (intoutput "warning: ~A might not like ~A argument~A.~%"
     (@p V4122 (@p Len (@p (if (> Len 1) "s" "") ()))))
    shen-skip))))

(defun shen-abstract_rule (V4124)
 (cond
  ((and (cons? V4124) (and (cons? (tl V4124)) (= () (tl (tl V4124)))))
   (shen-abstraction_build (hd V4124) (hd (tl V4124))))
  (true (shen-sys-error shen-abstract_rule))))

(defun shen-abstraction_build (V4125 V4126)
 (cond ((= () V4125) V4126)
  ((cons? V4125)
   (cons /.
    (cons (hd V4125) (cons (shen-abstraction_build (tl V4125) V4126) ()))))
  (true (shen-sys-error shen-abstraction_build))))

(defun shen-parameters (V4127)
 (cond ((= 0 V4127) ())
  (true (cons (gensym V) (shen-parameters (- V4127 1))))))

(defun shen-application_build (V4128 V4129)
 (cond ((= () V4128) V4129)
  ((cons? V4128)
   (shen-application_build (tl V4128) (cons V4129 (cons (hd V4128) ()))))
  (true (shen-sys-error shen-application_build))))

(defun shen-compile_to_kl (V4130 V4131)
 (cond
  ((and (cons? V4131) (and (cons? (tl V4131)) (= () (tl (tl V4131)))))
   (let Arity (shen-store-arity V4130 (length (hd V4131)))
    (let Reduce (map (lambda V4132 (shen-reduce V4132)) (hd (tl V4131)))
     (let CondExpression (shen-cond-expression V4130 (hd V4131) Reduce)
      (let KL
       (cons defun (cons V4130 (cons (hd V4131) (cons CondExpression ()))))
       KL)))))
  (true (shen-sys-error shen-compile_to_kl))))

(defun shen-store-arity (V4135 V4136)
 (cond ((value shen-*installing-kl*) shen-skip)
  (true (put V4135 arity V4136 (value shen-*property-vector*)))))

(defun shen-reduce (V4137)
 (do (set shen-*teststack* ())
  (let Result (shen-reduce_help V4137)
   (cons (cons shen-tests (reverse (value shen-*teststack*)))
    (cons Result ())))))

(defun shen-reduce_help (V4138)
 (cond
  ((and (cons? V4138)
    (and (cons? (hd V4138))
     (and (= /. (hd (hd V4138)))
      (and (cons? (tl (hd V4138)))
       (and (cons? (hd (tl (hd V4138))))
        (and (= cons (hd (hd (tl (hd V4138)))))
         (and (cons? (tl (hd (tl (hd V4138)))))
          (and (cons? (tl (tl (hd (tl (hd V4138))))))
           (and (= () (tl (tl (tl (hd (tl (hd V4138)))))))
            (and (cons? (tl (tl (hd V4138))))
             (and (= () (tl (tl (tl (hd V4138)))))
              (and (cons? (tl V4138)) (= () (tl (tl V4138)))))))))))))))
   (do (shen-add_test (cons cons? (tl V4138)))
    (let Abstraction
     (cons /.
      (cons (hd (tl (hd (tl (hd V4138)))))
       (cons
        (cons /.
         (cons (hd (tl (tl (hd (tl (hd V4138))))))
          (cons
           (shen-ebr (hd (tl V4138)) (hd (tl (hd V4138)))
            (hd (tl (tl (hd V4138)))))
           ())))
        ())))
     (let Application
      (cons (cons Abstraction (cons (cons hd (tl V4138)) ()))
       (cons (cons tl (tl V4138)) ()))
      (shen-reduce_help Application)))))
  ((and (cons? V4138)
    (and (cons? (hd V4138))
     (and (= /. (hd (hd V4138)))
      (and (cons? (tl (hd V4138)))
       (and (cons? (hd (tl (hd V4138))))
        (and (= @p (hd (hd (tl (hd V4138)))))
         (and (cons? (tl (hd (tl (hd V4138)))))
          (and (cons? (tl (tl (hd (tl (hd V4138))))))
           (and (= () (tl (tl (tl (hd (tl (hd V4138)))))))
            (and (cons? (tl (tl (hd V4138))))
             (and (= () (tl (tl (tl (hd V4138)))))
              (and (cons? (tl V4138)) (= () (tl (tl V4138)))))))))))))))
   (do (shen-add_test (cons tuple? (tl V4138)))
    (let Abstraction
     (cons /.
      (cons (hd (tl (hd (tl (hd V4138)))))
       (cons
        (cons /.
         (cons (hd (tl (tl (hd (tl (hd V4138))))))
          (cons
           (shen-ebr (hd (tl V4138)) (hd (tl (hd V4138)))
            (hd (tl (tl (hd V4138)))))
           ())))
        ())))
     (let Application
      (cons (cons Abstraction (cons (cons fst (tl V4138)) ()))
       (cons (cons snd (tl V4138)) ()))
      (shen-reduce_help Application)))))
  ((and (cons? V4138)
    (and (cons? (hd V4138))
     (and (= /. (hd (hd V4138)))
      (and (cons? (tl (hd V4138)))
       (and (cons? (hd (tl (hd V4138))))
        (and (= @v (hd (hd (tl (hd V4138)))))
         (and (cons? (tl (hd (tl (hd V4138)))))
          (and (cons? (tl (tl (hd (tl (hd V4138))))))
           (and (= () (tl (tl (tl (hd (tl (hd V4138)))))))
            (and (cons? (tl (tl (hd V4138))))
             (and (= () (tl (tl (tl (hd V4138)))))
              (and (cons? (tl V4138)) (= () (tl (tl V4138)))))))))))))))
   (do (shen-add_test (cons shen-+vector? (tl V4138)))
    (let Abstraction
     (cons /.
      (cons (hd (tl (hd (tl (hd V4138)))))
       (cons
        (cons /.
         (cons (hd (tl (tl (hd (tl (hd V4138))))))
          (cons
           (shen-ebr (hd (tl V4138)) (hd (tl (hd V4138)))
            (hd (tl (tl (hd V4138)))))
           ())))
        ())))
     (let Application
      (cons (cons Abstraction (cons (cons hdv (tl V4138)) ()))
       (cons (cons tlv (tl V4138)) ()))
      (shen-reduce_help Application)))))
  ((and (cons? V4138)
    (and (cons? (hd V4138))
     (and (= /. (hd (hd V4138)))
      (and (cons? (tl (hd V4138)))
       (and (cons? (hd (tl (hd V4138))))
        (and (= @s (hd (hd (tl (hd V4138)))))
         (and (cons? (tl (hd (tl (hd V4138)))))
          (and (cons? (tl (tl (hd (tl (hd V4138))))))
           (and (= () (tl (tl (tl (hd (tl (hd V4138)))))))
            (and (cons? (tl (tl (hd V4138))))
             (and (= () (tl (tl (tl (hd V4138)))))
              (and (cons? (tl V4138)) (= () (tl (tl V4138)))))))))))))))
   (do (shen-add_test (cons shen-+string? (tl V4138)))
    (let Abstraction
     (cons /.
      (cons (hd (tl (hd (tl (hd V4138)))))
       (cons
        (cons /.
         (cons (hd (tl (tl (hd (tl (hd V4138))))))
          (cons
           (shen-ebr (hd (tl V4138)) (hd (tl (hd V4138)))
            (hd (tl (tl (hd V4138)))))
           ())))
        ())))
     (let Application
      (cons
       (cons Abstraction
        (cons (cons pos (cons (hd (tl V4138)) (cons 0 ()))) ()))
       (cons (cons tlstr (tl V4138)) ()))
      (shen-reduce_help Application)))))
  ((and (cons? V4138)
    (and (cons? (hd V4138))
     (and (= /. (hd (hd V4138)))
      (and (cons? (tl (hd V4138)))
       (and (cons? (tl (tl (hd V4138))))
        (and (= () (tl (tl (tl (hd V4138)))))
         (and (cons? (tl V4138))
          (and (= () (tl (tl V4138)))
           (not (variable? (hd (tl (hd V4138)))))))))))))
   (do (shen-add_test (cons = (cons (hd (tl (hd V4138))) (tl V4138))))
    (shen-reduce_help (hd (tl (tl (hd V4138)))))))
  ((and (cons? V4138)
    (and (cons? (hd V4138))
     (and (= /. (hd (hd V4138)))
      (and (cons? (tl (hd V4138)))
       (and (cons? (tl (tl (hd V4138))))
        (and (= () (tl (tl (tl (hd V4138)))))
         (and (cons? (tl V4138)) (= () (tl (tl V4138))))))))))
   (shen-reduce_help
    (shen-ebr (hd (tl V4138)) (hd (tl (hd V4138))) (hd (tl (tl (hd V4138)))))))
  ((and (cons? V4138)
    (and (= where (hd V4138))
     (and (cons? (tl V4138))
      (and (cons? (tl (tl V4138))) (= () (tl (tl (tl V4138))))))))
   (do (shen-add_test (hd (tl V4138)))
    (shen-reduce_help (hd (tl (tl V4138))))))
  ((and (cons? V4138) (and (cons? (tl V4138)) (= () (tl (tl V4138)))))
   (let Z (shen-reduce_help (hd V4138))
    (if (= (hd V4138) Z) V4138 (shen-reduce_help (cons Z (tl V4138))))))
  (true V4138)))

(defun shen-+string? (V4139)
 (cond ((= "" V4139) false) (true (string? V4139))))

(defun shen-+vector (V4140)
 (cond ((= V4140 (vector 0)) false) (true (vector? V4140))))

(defun shen-ebr (V4149 V4150 V4151)
 (cond ((= V4151 V4150) V4149)
  ((and (cons? V4151)
    (and (= /. (hd V4151))
     (and (cons? (tl V4151))
      (and (cons? (tl (tl V4151)))
       (and (= () (tl (tl (tl V4151))))
        (> (occurrences V4150 (hd (tl V4151))) 0))))))
   V4151)
  ((and (cons? V4151)
    (and (= let (hd V4151))
     (and (cons? (tl V4151))
      (and (cons? (tl (tl V4151)))
       (and (cons? (tl (tl (tl V4151))))
        (and (= () (tl (tl (tl (tl V4151)))))
         (= (hd (tl V4151)) V4150)))))))
   (cons let
    (cons (hd (tl V4151))
     (cons (shen-ebr V4149 (hd (tl V4151)) (hd (tl (tl V4151))))
      (tl (tl (tl V4151)))))))
  ((cons? V4151)
   (cons (shen-ebr V4149 V4150 (hd V4151)) (shen-ebr V4149 V4150 (tl V4151))))
  (true V4151)))

(defun shen-add_test (V4154)
 (set shen-*teststack* (cons V4154 (value shen-*teststack*))))

(defun shen-cond-expression (V4155 V4156 V4157)
 (let Err (shen-err-condition V4155)
  (let Cases (shen-case-form V4157 Err)
   (let EncodeChoices (shen-encode-choices Cases V4155)
    (shen-cond-form EncodeChoices)))))

(defun shen-cond-form (V4160)
 (cond
  ((and (cons? V4160)
    (and (cons? (hd V4160))
     (and (= true (hd (hd V4160)))
      (and (cons? (tl (hd V4160))) (= () (tl (tl (hd V4160))))))))
   (hd (tl (hd V4160))))
  (true (cons cond V4160))))

(defun shen-encode-choices (V4163 V4164)
 (cond ((= () V4163) ())
  ((and (cons? V4163)
    (and (cons? (hd V4163))
     (and (= true (hd (hd V4163)))
      (and (cons? (tl (hd V4163)))
       (and (cons? (hd (tl (hd V4163))))
        (and (= shen-choicepoint! (hd (hd (tl (hd V4163)))))
         (and (cons? (tl (hd (tl (hd V4163)))))
          (and (= () (tl (tl (hd (tl (hd V4163))))))
           (and (= () (tl (tl (hd V4163)))) (= () (tl V4163)))))))))))
   (cons
    (cons true
     (cons
      (cons let
       (cons Result
        (cons (hd (tl (hd (tl (hd V4163)))))
         (cons
          (cons if
           (cons (cons = (cons Result (cons (cons fail ()) ())))
            (cons
             (if (value shen-*installing-kl*)
              (cons shen-sys-error (cons V4164 ()))
              (cons shen-f_error (cons V4164 ())))
             (cons Result ()))))
          ()))))
      ()))
    ()))
  ((and (cons? V4163)
    (and (cons? (hd V4163))
     (and (= true (hd (hd V4163)))
      (and (cons? (tl (hd V4163)))
       (and (cons? (hd (tl (hd V4163))))
        (and (= shen-choicepoint! (hd (hd (tl (hd V4163)))))
         (and (cons? (tl (hd (tl (hd V4163)))))
          (and (= () (tl (tl (hd (tl (hd V4163))))))
           (= () (tl (tl (hd V4163))))))))))))
   (cons
    (cons true
     (cons
      (cons let
       (cons Result
        (cons (hd (tl (hd (tl (hd V4163)))))
         (cons
          (cons if
           (cons (cons = (cons Result (cons (cons fail ()) ())))
            (cons (shen-cond-form (shen-encode-choices (tl V4163) V4164))
             (cons Result ()))))
          ()))))
      ()))
    ()))
  ((and (cons? V4163)
    (and (cons? (hd V4163))
     (and (cons? (tl (hd V4163)))
      (and (cons? (hd (tl (hd V4163))))
       (and (= shen-choicepoint! (hd (hd (tl (hd V4163)))))
        (and (cons? (tl (hd (tl (hd V4163)))))
         (and (= () (tl (tl (hd (tl (hd V4163))))))
          (= () (tl (tl (hd V4163)))))))))))
   (cons
    (cons true
     (cons
      (cons let
       (cons Freeze
        (cons
         (cons freeze
          (cons (shen-cond-form (shen-encode-choices (tl V4163) V4164)) ()))
         (cons
          (cons if
           (cons (hd (hd V4163))
            (cons
             (cons let
              (cons Result
               (cons (hd (tl (hd (tl (hd V4163)))))
                (cons
                 (cons if
                  (cons (cons = (cons Result (cons (cons fail ()) ())))
                   (cons (cons thaw (cons Freeze ())) (cons Result ()))))
                 ()))))
             (cons (cons thaw (cons Freeze ())) ()))))
          ()))))
      ()))
    ()))
  ((and (cons? V4163)
    (and (cons? (hd V4163))
     (and (cons? (tl (hd V4163))) (= () (tl (tl (hd V4163)))))))
   (cons (hd V4163) (shen-encode-choices (tl V4163) V4164)))
  (true (shen-sys-error shen-encode-choices))))

(defun shen-case-form (V4169 V4170)
 (cond ((= () V4169) (cons V4170 ()))
  ((and (cons? V4169)
    (and (cons? (hd V4169))
     (and (cons? (hd (hd V4169)))
      (and (= shen-tests (hd (hd (hd V4169))))
       (and (= () (tl (hd (hd V4169))))
        (and (cons? (tl (hd V4169)))
         (and (cons? (hd (tl (hd V4169))))
          (and (= shen-choicepoint! (hd (hd (tl (hd V4169)))))
           (and (cons? (tl (hd (tl (hd V4169)))))
            (and (= () (tl (tl (hd (tl (hd V4169))))))
             (= () (tl (tl (hd V4169))))))))))))))
   (cons (cons true (tl (hd V4169))) (shen-case-form (tl V4169) V4170)))
  ((and (cons? V4169)
    (and (cons? (hd V4169))
     (and (cons? (hd (hd V4169)))
      (and (= shen-tests (hd (hd (hd V4169))))
       (and (= () (tl (hd (hd V4169))))
        (and (cons? (tl (hd V4169))) (= () (tl (tl (hd V4169))))))))))
   (cons (cons true (tl (hd V4169))) ()))
  ((and (cons? V4169)
    (and (cons? (hd V4169))
     (and (cons? (hd (hd V4169)))
      (and (= shen-tests (hd (hd (hd V4169))))
       (and (cons? (tl (hd V4169))) (= () (tl (tl (hd V4169)))))))))
   (cons (cons (shen-embed-and (tl (hd (hd V4169)))) (tl (hd V4169)))
    (shen-case-form (tl V4169) V4170)))
  (true (shen-sys-error shen-case-form))))

(defun shen-embed-and (V4171)
 (cond ((and (cons? V4171) (= () (tl V4171))) (hd V4171))
  ((cons? V4171)
   (cons and (cons (hd V4171) (cons (shen-embed-and (tl V4171)) ()))))
  (true (shen-sys-error shen-embed-and))))

(defun shen-err-condition (V4172)
 (cond
  ((value shen-*installing-kl*)
   (cons true (cons (cons shen-sys-error (cons V4172 ())) ())))
  (true (cons true (cons (cons shen-f_error (cons V4172 ())) ())))))

(defun shen-sys-error (V4173)
 (interror "system function ~A: unexpected argument~%" (@p V4173 ())))

