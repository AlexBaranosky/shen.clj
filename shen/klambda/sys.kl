
"                                                   The License
 
 The user is free to produce commercial applications with the software, to distribute these applications in source or binary  form, and to charge monies for them as he sees fit and in concordance with the laws of the land subject to the following  license.
 
 1. The license applies to all the software and all derived software and must appear on such.
 2. It is illegal to distribute the software without this license attached to it and use of the software implies agreement 
    with the license as such. It is illegal for anyone who is not the copyright holder to tamper with or change the license.
 3. Neither the names of Lambda Associates or the copyright holder may be used to endorse or promote products built using
     the software without specific prior written permission from the copyright holder.
 4. That possession of this license does not confer on the copyright holder any special contractual obligation towards the    user. That in no event shall the copyright holder be liable for any direct, indirect, incidental, special, exemplary or   consequential damages (including but not limited to procurement of substitute goods or services, loss of use, data, or    profits; or business interruption), however caused and on any theory of liability, whether in contract, strict liability   or tort (including negligence) arising in any way out of the use of the software, even if advised of the possibility of   such damage. 
5. It is permitted for the user to change the software, for the purpose of improving performance, correcting an error, or    porting to a new platform, and distribute the modified version of Shen (hereafter the modified version) provided the     resulting program conforms in all respects to the Shen standard and is issued under that title. The user must make it clear   with his distribution that he/she is the author of the changes and what these changes are and why. 
6. Derived versions of this software in whatever form are subject to the same restrictions. In particular it is not          permitted to make derived copies of this software which do not conform to the Shen standard or appear under a different title.
7. It is permitted to distribute versions of Shen which incorporate libraries, graphics or other facilities which are not    part of the Shen standard.

For an explication of this license see http://www.lambdassociates.org/News/june11/license.htm which explains this license in full."

(defun thaw (V4294) (V4294))

(defun eval (V4295)
 (let Macroexpand (shen-walk (lambda V4296 (macroexpand V4296)) V4295)
  (if (shen-packaged? Macroexpand)
   (map (lambda V4297 (shen-eval-without-macros V4297))
    (shen-package-contents Macroexpand))
   (shen-eval-without-macros Macroexpand))))

(defun shen-eval-without-macros (V4298)
 (eval-kl (shen-elim-define (shen-proc-input+ V4298))))

(defun shen-proc-input+ (V4299)
 (cond
  ((and (cons? V4299)
    (and (= input+ (hd V4299))
     (and (cons? (tl V4299))
      (and (cons? (tl (tl V4299))) (= () (tl (tl (tl V4299))))))))
   (cons input+
    (cons (hd (tl V4299)) (cons (shen-rcons_form (hd (tl (tl V4299)))) ()))))
  ((cons? V4299) (map (lambda V4300 (shen-proc-input+ V4300)) V4299))
  (true V4299)))

(defun shen-elim-define (V4301)
 (cond
  ((and (cons? V4301) (and (= define (hd V4301)) (cons? (tl V4301))))
   (shen-shen->kl (hd (tl V4301)) (tl (tl V4301))))
  ((cons? V4301) (map (lambda V4302 (shen-elim-define V4302)) V4301))
  (true V4301)))

(defun shen-packaged? (V4309)
 (cond
  ((and (cons? V4309)
    (and (= package (hd V4309))
     (and (cons? (tl V4309)) (cons? (tl (tl V4309))))))
   true)
  (true false)))

(defun external (V4310)
 (trap-error (get V4310 shen-external-symbols (value shen-*property-vector*))
  (lambda E (interror "package ~A has not been used.~" ()))))

(defun shen-package-contents (V4313)
 (cond
  ((and (cons? V4313)
    (and (= package (hd V4313))
     (and (cons? (tl V4313))
      (and (= null (hd (tl V4313))) (cons? (tl (tl V4313)))))))
   (tl (tl (tl V4313))))
  ((and (cons? V4313)
    (and (= package (hd V4313))
     (and (cons? (tl V4313)) (cons? (tl (tl V4313))))))
   (shen-packageh (hd (tl V4313)) (hd (tl (tl V4313))) Code))
  (true (shen-sys-error shen-package-contents))))

(defun shen-walk (V4314 V4315)
 (cond ((cons? V4315) (V4314 (map (lambda Z (shen-walk V4314 Z)) V4315)))
  (true (V4314 V4315))))

(defun compile (V4316 V4317 V4318)
 (let O (V4316 (@p V4317 ()))
  (if (or (= (fail) O) (not (empty? (fst O)))) (shen-compile-error O V4318)
   (snd O))))

(defun shen-compile-error (V4331 V4332)
 (cond ((= () V4332) (fail))
  ((and (tuple? V4331) (cons? (fst V4331))) (V4332 (fst V4331)))
  (true (interror "syntax error~%" ()))))

(defun <e> (V4337)
 (cond ((tuple? V4337) (@p (fst V4337) ())) (true (shen-sys-error <e>))))

(defun fail-if (V4338 V4339) (if (V4338 V4339) (fail) V4339))

(defun @s (V4340 V4341) (cn V4340 V4341))

(defun tc? (V4346) (value shen-*tc*))

(defun ps (V4347)
 (trap-error (get V4347 shen-source (value shen-*property-vector*))
  (lambda E (interror "~A not found.~%" (@p V4347 ())))))

(defun explode (V4348)
 (if (string? V4348) (shen-explode-string V4348)
  (explode (intmake-string "~A" (@p V4348 ())))))

(defun shen-explode-string (V4349)
 (cond ((= "" V4349) ())
  (true
   (let S (pos V4349 0)
    (let Ss (tlstr V4349)
     (if (= Ss shen-eos) () (cons S (shen-explode-string Ss))))))))

(defun stinput (V4354) (value *stinput*))

(defun shen-+vector? (V4355)
 (and (absvector? V4355) (> (<-address V4355 0) 0)))

(defun vector (V4356)
 (let Vector (absvector (+ V4356 1)) (address-> Vector 0 V4356)))

(defun shen-fillvector (V4359 V4360 V4361 V4362)
 (cond ((= V4361 V4360) V4359)
  (true
   (shen-fillvector (address-> V4359 V4360 V4362) (+ 1 V4360) V4361 V4362))))

(defun vector? (V4364)
 (and (absvector? V4364)
  (trap-error (>= (<-address V4364 0) 0) (lambda E false))))

(defun vector-> (V4365 V4366 V4367)
 (if (= V4366 0) (interror "cannot access 0th element of a vector~%" ())
  (address-> V4365 V4366 V4367)))

(defun <-vector (V4368 V4369)
 (if (= V4369 0) (interror "cannot access 0th element of a vector~%" ())
  (let VectorElement (<-address V4368 V4369)
   (if (= VectorElement (fail)) (interror "vector element not found~%" ())
    VectorElement))))

(defun shen-posint? (V4370) (and (integer? V4370) (>= V4370 0)))

(defun limit (V4371) (<-address V4371 0))

(defun symbol? (V4372)
 (cond ((or (boolean? V4372) (number? V4372)) false)
  (true
   (trap-error
    (let String (str V4372)
     (let Unit (pos String 0)
      (element? Unit
       (cons "A"
        (cons "B"
         (cons "C"
          (cons "D"
           (cons "E"
            (cons "F"
             (cons "G"
              (cons "H"
               (cons "I"
                (cons "J"
                 (cons "K"
                  (cons "L"
                   (cons "M"
                    (cons "N"
                     (cons "O"
                      (cons "P"
                       (cons "Q"
                        (cons "R"
                         (cons "S"
                          (cons "T"
                           (cons "U"
                            (cons "V"
                             (cons "W"
                              (cons "X"
                               (cons "Y"
                                (cons "Z"
                                 (cons "a"
                                  (cons "b"
                                   (cons "c"
                                    (cons "d"
                                     (cons "e"
                                      (cons "f"
                                       (cons "g"
                                        (cons "h"
                                         (cons "i"
                                          (cons "j"
                                           (cons "k"
                                            (cons "l"
                                             (cons "m"
                                              (cons "n"
                                               (cons "o"
                                                (cons "p"
                                                 (cons "q"
                                                  (cons "r"
                                                   (cons "s"
                                                    (cons "t"
                                                     (cons "u"
                                                      (cons "v"
                                                       (cons "w"
                                                        (cons "x"
                                                         (cons "y"
                                                          (cons "z"
                                                           (cons "="
                                                            (cons "*"
                                                             (cons "/"
                                                              (cons "+"
                                                               (cons "-"
                                                                (cons "_"
                                                                 (cons "?"
                                                                  (cons "$"
                                                                   (cons "!"
                                                                    (cons "@"
                                                                     (cons "~"
                                                                      (cons ">"
                                                                       (cons
                                                                        "<"
                                                                        (cons
                                                                         "&"
                                                                         (cons
                                                                          "%"
                                                                          (cons
                                                                           "{"
                                                                           (cons
                                                                            "}"
                                                                            (cons
                                                                             ":"
                                                                             (cons
                                                                              ";"
                                                                              (cons
                                                                               "`"
                                                                               (cons
                                                                                "#"
                                                                                (cons
                                                                                 "'"
                                                                                 (cons
                                                                                  "."
                                                                                  ()))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
    (lambda E false)))))

(defun variable? (V4373)
 (trap-error
  (let String (str V4373)
   (let Unit (pos String 0)
    (element? Unit
     (cons "A"
      (cons "B"
       (cons "C"
        (cons "D"
         (cons "E"
          (cons "F"
           (cons "G"
            (cons "H"
             (cons "I"
              (cons "J"
               (cons "K"
                (cons "L"
                 (cons "M"
                  (cons "N"
                   (cons "O"
                    (cons "P"
                     (cons "Q"
                      (cons "R"
                       (cons "S"
                        (cons "T"
                         (cons "U"
                          (cons "V"
                           (cons "W"
                            (cons "X"
                             (cons "Y"
                              (cons "Z" ())))))))))))))))))))))))))))))
  (lambda E false)))

(defun gensym (V4374)
 (concat V4374 (set shen-*gensym* (+ 1 (value shen-*gensym*)))))

(defun concat (V4375 V4376) (intern (cn (str V4375) (str V4376))))

(defun @p (V4377 V4378)
 (let Vector (absvector 3)
  (let Tag (address-> Vector 0 shen-tuple)
   (let Fst (address-> Vector 1 V4377)
    (let Snd (address-> Vector 2 V4378) Vector)))))

(defun fst (V4379) (<-address V4379 1))

(defun snd (V4380) (<-address V4380 2))

(defun tuple? (V4381)
 (trap-error (and (absvector? V4381) (= shen-tuple (<-address V4381 0)))
  (lambda E false)))

(defun append (V4382 V4383)
 (cond ((= () V4382) V4383)
  ((cons? V4382) (cons (hd V4382) (append (tl V4382) V4383)))
  (true (shen-sys-error append))))

(defun @v (V4384 V4385)
 (let Limit (limit V4385)
  (let NewVector (vector (+ Limit 1))
   (let X+NewVector (vector-> NewVector 1 V4384)
    (if (= Limit 0) X+NewVector
     (shen-@v-help V4385 1 Limit X+NewVector))))))

(defun shen-@v-help (V4386 V4387 V4388 V4389)
 (cond ((= V4388 V4387) (shen-copyfromvector V4386 V4389 V4388 (+ V4388 1)))
  (true
   (shen-@v-help V4386 (+ V4387 1) V4388
    (shen-copyfromvector V4386 V4389 V4387 (+ V4387 1))))))

(defun shen-copyfromvector (V4391 V4392 V4393 V4394)
 (trap-error (vector-> V4392 V4394 (<-vector V4391 V4393)) (lambda E V4392)))

(defun hdv (V4395)
 (trap-error (<-vector V4395 1)
  (lambda E
   (interror "hdv needs a non-empty vector as an argument; not ~S~%"
    (@p V4395 ())))))

(defun tlv (V4396)
 (let Limit (limit V4396)
  (if (= Limit 0)
   (interror "cannot take the tail of the empty vector~%" ())
   (if (= Limit 1) (vector 0)
    (let NewVector (vector (- Limit 1))
     (shen-tlv-help V4396 2 Limit (vector (- Limit 1))))))))

(defun shen-tlv-help (V4397 V4398 V4399 V4400)
 (cond ((= V4399 V4398) (shen-copyfromvector V4397 V4400 V4399 (- V4399 1)))
  (true
   (shen-tlv-help V4397 (+ V4398 1) V4399
    (shen-copyfromvector V4397 V4400 V4398 (- V4398 1))))))

(defun assoc (V4410 V4411)
 (cond ((= () V4411) ())
  ((and (cons? V4411) (and (cons? (hd V4411)) (= (hd (hd V4411)) V4410)))
   (hd V4411))
  ((cons? V4411) (assoc V4410 (tl V4411))) (true (shen-sys-error assoc))))

(defun boolean? (V4417)
 (cond ((= true V4417) true) ((= false V4417) true) (true false)))

(defun nl (V4418)
 (cond ((= 0 V4418) 0) (true (do (intoutput "~%" ()) (nl (- V4418 1))))))

(defun difference (V4421 V4422)
 (cond ((= () V4421) ())
  ((cons? V4421)
   (if (element? (hd V4421) V4422) (difference (tl V4421) V4422)
    (cons (hd V4421) (difference (tl V4421) V4422))))
  (true (shen-sys-error difference))))

(defun do (V4423 V4424) V4424)

(defun element? (V4433 V4434)
 (cond ((= () V4434) false)
  ((and (cons? V4434) (= (hd V4434) V4433)) true)
  ((cons? V4434) (element? V4433 (tl V4434)))
  (true (shen-sys-error element?))))

(defun empty? (V4440) (cond ((= () V4440) true) (true false)))

(defun fix (V4441 V4442) (shen-fix-help V4441 V4442 (V4441 V4442)))

(defun shen-fix-help (V4449 V4450 V4451)
 (cond ((= V4451 V4450) V4451)
  (true (shen-fix-help V4449 V4451 (V4449 V4451)))))

(defun put (V4453 V4454 V4455 V4456)
 (let N (hash V4453 (limit V4456))
  (let Entry (trap-error (<-vector V4456 N) (lambda E ()))
   (let Change
    (vector-> V4456 N (shen-change-pointer-value V4453 V4454 V4455 Entry))
    V4455))))

(defun shen-change-pointer-value (V4459 V4460 V4461 V4462)
 (cond ((= () V4462) (cons (cons (cons V4459 (cons V4460 ())) V4461) ()))
  ((and (cons? V4462)
    (and (cons? (hd V4462))
     (and (cons? (hd (hd V4462)))
      (and (cons? (tl (hd (hd V4462))))
       (and (= () (tl (tl (hd (hd V4462)))))
        (and (= (hd (tl (hd (hd V4462)))) V4460)
         (= (hd (hd (hd V4462))) V4459)))))))
   (cons (cons (hd (hd V4462)) V4461) (tl V4462)))
  ((cons? V4462)
   (cons (hd V4462) (shen-change-pointer-value V4459 V4460 V4461 (tl V4462))))
  (true (shen-sys-error shen-change-pointer-value))))

(defun get (V4465 V4466 V4467)
 (let N (hash V4465 (limit V4467))
  (let Entry
   (trap-error (<-vector V4467 N)
    (lambda E (interror "pointer not found~%" ())))
   (let Result (assoc (cons V4465 (cons V4466 ())) Entry)
    (if (empty? Result) (interror "value not found~%" ()) (tl Result))))))

(defun hash (V4468 V4469)
 (let Hash
  (shen-mod (sum (map (lambda V4470 (string->n V4470)) (explode V4468))) V4469)
  (if (= 0 Hash) 1 Hash)))

(defun shen-mod (V4471 V4472)
 (shen-modh V4471 (shen-multiples V4471 (cons V4472 ()))))

(defun shen-multiples (V4473 V4474)
 (cond ((and (cons? V4474) (> (hd V4474) V4473)) (tl V4474))
  ((cons? V4474) (shen-multiples V4473 (cons (* 2 (hd V4474)) V4474)))
  (true (shen-sys-error shen-multiples))))

(defun shen-modh (V4477 V4478)
 (cond ((= 0 V4477) 0) ((= () V4478) V4477)
  ((and (cons? V4478) (> (hd V4478) V4477))
   (if (empty? (tl V4478)) V4477 (shen-modh V4477 (tl V4478))))
  ((cons? V4478) (shen-modh (- V4477 (hd V4478)) V4478))
  (true (shen-sys-error shen-modh))))

(defun sum (V4479)
 (cond ((= () V4479) 0) ((cons? V4479) (+ (hd V4479) (sum (tl V4479))))
  (true (shen-sys-error sum))))

(defun head (V4486)
 (cond ((cons? V4486) (hd V4486))
  (true (interror "head expects a non-empty list" ()))))

(defun tail (V4493)
 (cond ((cons? V4493) (tl V4493))
  (true (interror "tail expects a non-empty list" ()))))

(defun hdstr (V4494) (pos V4494 0))

(defun intersection (V4497 V4498)
 (cond ((= () V4497) ())
  ((cons? V4497)
   (if (element? (hd V4497) V4498)
    (cons (hd V4497) (intersection (tl V4497) V4498))
    (intersection (tl V4497) V4498)))
  (true (shen-sys-error intersection))))

(defun reverse (V4499) (shen-reverse_help V4499 ()))

(defun shen-reverse_help (V4500 V4501)
 (cond ((= () V4500) V4501)
  ((cons? V4500) (shen-reverse_help (tl V4500) (cons (hd V4500) V4501)))
  (true (shen-sys-error shen-reverse_help))))

(defun union (V4502 V4503)
 (cond ((= () V4502) V4503)
  ((cons? V4502)
   (if (element? (hd V4502) V4503) (union (tl V4502) V4503)
    (cons (hd V4502) (union (tl V4502) V4503))))
  (true (shen-sys-error union))))

(defun y-or-n? (V4504)
 (let Message (intoutput V4504 ())
  (let Y-or-N (intoutput " (y/n) " ())
   (let Input (intmake-string "~S" (@p (input) ()))
    (if (= "y" Input) true
     (if (= "n" Input) false
      (do (intoutput "please answer y or n~%" ()) (y-or-n? V4504))))))))

(defun not (V4505) (if V4505 false true))

(defun subst (V4514 V4515 V4516)
 (cond ((= V4516 V4515) V4514)
  ((cons? V4516)
   (cons (subst V4514 V4515 (hd V4516)) (subst V4514 V4515 (tl V4516))))
  (true V4516)))

(defun cd (V4518)
 (set *home-directory*
  (if (= V4518 "") "" (intmake-string "~A/" (@p V4518 ())))))

(defun map (V4519 V4520) (shen-map-h V4519 V4520 ()))

(defun shen-map-h (V4523 V4524 V4525)
 (cond ((= () V4524) (reverse V4525))
  ((cons? V4524) (shen-map-h V4523 (tl V4524) (cons (V4523 (hd V4524)) V4525)))
  (true (shen-sys-error shen-map-h))))

(defun length (V4526) (shen-length-h V4526 0))

(defun shen-length-h (V4527 V4528)
 (cond ((= () V4527) V4528) (true (shen-length-h (tl V4527) (+ V4528 1)))))

(defun occurrences (V4537 V4538)
 (cond ((= V4538 V4537) 1)
  ((cons? V4538)
   (+ (occurrences V4537 (hd V4538)) (occurrences V4537 (tl V4538))))
  (true 0)))

(defun nth (V4546 V4547)
 (cond ((and (= 1 V4546) (cons? V4547)) (hd V4547))
  ((cons? V4547) (nth (- V4546 1) (tl V4547))) (true (shen-sys-error nth))))

(defun integer? (V4548)
 (and (number? V4548)
  (let Abs (shen-abs V4548) (shen-integer-test? Abs (shen-magless Abs 1)))))

(defun shen-abs (V4549) (if (> V4549 0) V4549 (- 0 V4549)))

(defun shen-magless (V4550 V4551)
 (let Nx2 (* V4551 2) (if (> Nx2 V4550) V4551 (shen-magless V4550 Nx2))))

(defun shen-integer-test? (V4555 V4556)
 (cond ((= 0 V4555) true) ((> 1 V4555) false)
  (true
   (let Abs-N (- V4555 V4556)
    (if (> 0 Abs-N) (integer? V4555) (shen-integer-test? Abs-N V4556))))))

(defun mapcan (V4559 V4560)
 (cond ((= () V4560) ())
  ((cons? V4560) (append (V4559 (hd V4560)) (mapcan V4559 (tl V4560))))
  (true (shen-sys-error mapcan))))

(defun read-file-as-bytelist (V4561)
 (let Stream (open file V4561 in)
  (let Byte (read-byte Stream)
   (let Bytes (shen-read-file-as-bytelist-help Stream Byte ())
    (let Close (close Stream) (reverse Bytes))))))

(defun shen-read-file-as-bytelist-help (V4562 V4563 V4564)
 (cond ((= -1 V4563) V4564)
  (true
   (shen-read-file-as-bytelist-help V4562 (read-byte V4562)
    (cons V4563 V4564)))))

(defun read-file-as-string (V4565)
 (let Stream (open file V4565 in) (shen-rfas-h Stream (read-byte Stream) "")))

(defun shen-rfas-h (V4566 V4567 V4568)
 (cond ((= -1 V4567) (do (close V4566) V4568))
  (true (shen-rfas-h V4566 (read-byte V4566) (cn V4568 (n->string V4567))))))

(defun == (V4577 V4578) (cond ((= V4578 V4577) true) (true false)))

(defun abort () (simple-error ""))

(defun read () (hd (lineread)))

(defun input () (eval (read)))

(defun input+ (V4584 V4585)
 (let Input (read)
  (let Check (shen-typecheck Input V4585)
   (if (= false Check)
    (do (intoutput "input is not of type ~R: please re-enter " (@p V4585 ()))
     (input+ : V4585))
    (eval Input)))))

(defun bound? (V4586)
 (and (symbol? V4586)
  (let Val (trap-error (value V4586) (lambda E shen-this-symbol-is-unbound))
   (if (= Val shen-this-symbol-is-unbound) false true))))

(defun shen-string->bytes (V4587)
 (cond ((= "" V4587) ())
  (true (cons (string->n (pos V4587 0)) (shen-string->bytes (tlstr V4587))))))

(defun maxinferences (V4588) (set shen-*maxinferences* V4588))

(defun inferences (V4593) (value shen-*infs*))

(defun shen-hush (V4598)
 (cond ((= + V4598) (set shen-*hush* shen-hushed))
  ((= - V4598) (set shen-*hush* shen-unhushed))
  (true (interror "'hush' expects a + or a -~%" ()))))

(defun protect (V4599) V4599)

