
"                                                   The License
 
 The user is free to produce commercial applications with the software, to distribute these applications in source or binary  form, and to charge monies for them as he sees fit and in concordance with the laws of the land subject to the following  license.
 
 1. The license applies to all the software and all derived software and must appear on such.
 2. It is illegal to distribute the software without this license attached to it and use of the software implies agreement 
    with the license as such. It is illegal for anyone who is not the copyright holder to tamper with or change the license.
 3. Neither the names of Lambda Associates or the copyright holder may be used to endorse or promote products built using
     the software without specific prior written permission from the copyright holder.
 4. That possession of this license does not confer on the copyright holder any special contractual obligation towards the    user. That in no event shall the copyright holder be liable for any direct, indirect, incidental, special, exemplary or   consequential damages (including but not limited to procurement of substitute goods or services, loss of use, data, or    profits; or business interruption), however caused and on any theory of liability, whether in contract, strict liability   or tort (including negligence) arising in any way out of the use of the software, even if advised of the possibility of   such damage. 
5. It is permitted for the user to change the software, for the purpose of improving performance, correcting an error, or    porting to a new platform, and distribute the modified version of Shen (hereafter the modified version) provided the     resulting program conforms in all respects to the Shen standard and is issued under that title. The user must make it clear   with his distribution that he/she is the author of the changes and what these changes are and why. 
6. Derived versions of this software in whatever form are subject to the same restrictions. In particular it is not          permitted to make derived copies of this software which do not conform to the Shen standard or appear under a different title.
7. It is permitted to distribute versions of Shen which incorporate libraries, graphics or other facilities which are not    part of the Shen standard.

For an explication of this license see http://www.lambdassociates.org/News/june11/license.htm which explains this license in full."

(defun thaw (V650) (V650))

(defun eval (V651)
 (let Macroexpand (shen-walk (lambda V652 (macroexpand V652)) V651)
  (if (shen-packaged? Macroexpand)
   (map (lambda V653 (shen-eval-without-macros V653))
    (shen-package-contents Macroexpand))
   (shen-eval-without-macros Macroexpand))))

(defun shen-eval-without-macros (V654)
 (eval-kl (shen-elim-define (shen-proc-input+ V654))))

(defun shen-proc-input+ (V655)
 (cond
  ((and (cons? V655)
    (and (= input+ (hd V655))
     (and (cons? (tl V655))
      (and (cons? (tl (tl V655))) (= () (tl (tl (tl V655))))))))
   (cons input+
    (cons (hd (tl V655)) (cons (shen-rcons_form (hd (tl (tl V655)))) ()))))
  ((cons? V655) (map (lambda V656 (shen-proc-input+ V656)) V655)) (true V655)))

(defun shen-elim-define (V657)
 (cond
  ((and (cons? V657) (and (= define (hd V657)) (cons? (tl V657))))
   (shen-shen->kl (hd (tl V657)) (tl (tl V657))))
  ((cons? V657) (map (lambda V658 (shen-elim-define V658)) V657)) (true V657)))

(defun shen-packaged? (V665)
 (cond
  ((and (cons? V665)
    (and (= package (hd V665))
     (and (cons? (tl V665)) (cons? (tl (tl V665))))))
   true)
  (true false)))

(defun external (V666)
 (trap-error (get V666 shen-external-symbols (value shen-*property-vector*))
  (lambda E (interror "package ~A has not been used.~" ()))))

(defun shen-package-contents (V669)
 (cond
  ((and (cons? V669)
    (and (= package (hd V669))
     (and (cons? (tl V669))
      (and (= null (hd (tl V669))) (cons? (tl (tl V669)))))))
   (tl (tl (tl V669))))
  ((and (cons? V669)
    (and (= package (hd V669))
     (and (cons? (tl V669)) (cons? (tl (tl V669))))))
   (shen-packageh (hd (tl V669)) (hd (tl (tl V669))) Code))
  (true (shen-sys-error shen-package-contents))))

(defun shen-walk (V670 V671)
 (cond ((cons? V671) (V670 (map (lambda Z (shen-walk V670 Z)) V671)))
  (true (V670 V671))))

(defun compile (V672 V673 V674)
 (let O (V672 (@p V673 ()))
  (if (or (= (fail) O) (not (empty? (fst O)))) (shen-compile-error O V674)
   (snd O))))

(defun shen-compile-error (V687 V688)
 (cond ((= () V688) (fail))
  ((and (tuple? V687) (cons? (fst V687))) (V688 (fst V687)))
  (true (interror "syntax error~%" ()))))

(defun <e> (V693)
 (cond ((tuple? V693) (@p (fst V693) ())) (true (shen-sys-error <e>))))

(defun fail-if (V694 V695) (if (V694 V695) (fail) V695))

(defun @s (V696 V697) (cn V696 V697))

(defun tc? (V702) (value shen-*tc*))

(defun ps (V703)
 (trap-error (get V703 shen-source (value shen-*property-vector*))
  (lambda E (interror "~A not found.~%" (@p V703 ())))))

(defun explode (V704)
 (if (string? V704) (shen-explode-string V704)
  (explode (intmake-string "~A" (@p V704 ())))))

(defun shen-explode-string (V705)
 (cond ((= "" V705) ())
  (true
   (let S (pos V705 0)
    (let Ss (tlstr V705)
     (if (= Ss shen-eos) () (cons S (shen-explode-string Ss))))))))

(defun stinput (V710) (value *stinput*))

(defun shen-+vector? (V711)
 (and (absvector? V711) (> (<-address V711 0) 0)))

(defun vector (V712)
 (let Vector (absvector (+ V712 1))
  (let ZeroStamp (address-> Vector 0 V712)
   (let Standard
    (if (= V712 0) ZeroStamp (shen-fillvector ZeroStamp 1 V712 (fail)))
    Standard))))

(defun shen-fillvector (V713 V714 V715 V716)
 (cond ((= V715 V714) (address-> V713 V715 V716))
  (true (shen-fillvector (address-> V713 V714 V716) (+ 1 V714) V715 V716))))

(defun vector? (V718)
 (and (absvector? V718)
  (trap-error (>= (<-address V718 0) 0) (lambda E false))))

(defun vector-> (V719 V720 V721)
 (if (= V720 0) (interror "cannot access 0th element of a vector~%" ())
  (address-> V719 V720 V721)))

(defun <-vector (V722 V723)
 (if (= V723 0) (interror "cannot access 0th element of a vector~%" ())
  (let VectorElement (<-address V722 V723)
   (if (= VectorElement (fail)) (interror "vector element not found~%" ())
    VectorElement))))

(defun shen-posint? (V724) (and (integer? V724) (>= V724 0)))

(defun limit (V725) (<-address V725 0))

(defun symbol? (V726)
 (cond ((or (boolean? V726) (number? V726)) false)
  (true
   (trap-error
    (let String (str V726)
     (let Unit (pos String 0)
      (element? Unit
       (cons "A"
        (cons "B"
         (cons "C"
          (cons "D"
           (cons "E"
            (cons "F"
             (cons "G"
              (cons "H"
               (cons "I"
                (cons "J"
                 (cons "K"
                  (cons "L"
                   (cons "M"
                    (cons "N"
                     (cons "O"
                      (cons "P"
                       (cons "Q"
                        (cons "R"
                         (cons "S"
                          (cons "T"
                           (cons "U"
                            (cons "V"
                             (cons "W"
                              (cons "X"
                               (cons "Y"
                                (cons "Z"
                                 (cons "a"
                                  (cons "b"
                                   (cons "c"
                                    (cons "d"
                                     (cons "e"
                                      (cons "f"
                                       (cons "g"
                                        (cons "h"
                                         (cons "i"
                                          (cons "j"
                                           (cons "k"
                                            (cons "l"
                                             (cons "m"
                                              (cons "n"
                                               (cons "o"
                                                (cons "p"
                                                 (cons "q"
                                                  (cons "r"
                                                   (cons "s"
                                                    (cons "t"
                                                     (cons "u"
                                                      (cons "v"
                                                       (cons "w"
                                                        (cons "x"
                                                         (cons "y"
                                                          (cons "z"
                                                           (cons "="
                                                            (cons "*"
                                                             (cons "/"
                                                              (cons "+"
                                                               (cons "-"
                                                                (cons "_"
                                                                 (cons "?"
                                                                  (cons "$"
                                                                   (cons "!"
                                                                    (cons "@"
                                                                     (cons "~"
                                                                      (cons ">"
                                                                       (cons
                                                                        "<"
                                                                        (cons
                                                                         "&"
                                                                         (cons
                                                                          "%"
                                                                          (cons
                                                                           "{"
                                                                           (cons
                                                                            "}"
                                                                            (cons
                                                                             ":"
                                                                             (cons
                                                                              ";"
                                                                              (cons
                                                                               "`"
                                                                               (cons
                                                                                "#"
                                                                                (cons
                                                                                 "'"
                                                                                 (cons
                                                                                  "."
                                                                                  ()))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
    (lambda E false)))))

(defun variable? (V727)
 (trap-error
  (let String (str V727)
   (let Unit (pos String 0)
    (element? Unit
     (cons "A"
      (cons "B"
       (cons "C"
        (cons "D"
         (cons "E"
          (cons "F"
           (cons "G"
            (cons "H"
             (cons "I"
              (cons "J"
               (cons "K"
                (cons "L"
                 (cons "M"
                  (cons "N"
                   (cons "O"
                    (cons "P"
                     (cons "Q"
                      (cons "R"
                       (cons "S"
                        (cons "T"
                         (cons "U"
                          (cons "V"
                           (cons "W"
                            (cons "X"
                             (cons "Y"
                              (cons "Z" ())))))))))))))))))))))))))))))
  (lambda E false)))

(defun gensym (V728)
 (concat V728 (set shen-*gensym* (+ 1 (value shen-*gensym*)))))

(defun concat (V729 V730) (intern (cn (str V729) (str V730))))

(defun @p (V731 V732)
 (let Vector (absvector 3)
  (let Tag (address-> Vector 0 shen-tuple)
   (let Fst (address-> Vector 1 V731)
    (let Snd (address-> Vector 2 V732) Vector)))))

(defun fst (V733) (<-address V733 1))

(defun snd (V734) (<-address V734 2))

(defun tuple? (V735)
 (trap-error (and (absvector? V735) (= shen-tuple (<-address V735 0)))
  (lambda E false)))

(defun append (V736 V737)
 (cond ((= () V736) V737)
  ((cons? V736) (cons (hd V736) (append (tl V736) V737)))
  (true (shen-sys-error append))))

(defun @v (V738 V739)
 (let Limit (limit V739)
  (let NewVector (vector (+ Limit 1))
   (let X+NewVector (vector-> NewVector 1 V738)
    (if (= Limit 0) X+NewVector (shen-@v-help V739 1 Limit X+NewVector))))))

(defun shen-@v-help (V740 V741 V742 V743)
 (cond ((= V742 V741) (shen-copyfromvector V740 V743 V742 (+ V742 1)))
  (true
   (shen-@v-help V740 (+ V741 1) V742
    (shen-copyfromvector V740 V743 V741 (+ V741 1))))))

(defun shen-copyfromvector (V745 V746 V747 V748)
 (trap-error (vector-> V746 V748 (<-vector V745 V747)) (lambda E V746)))

(defun hdv (V749)
 (trap-error (<-vector V749 1)
  (lambda E
   (interror "hdv needs a non-empty vector as an argument; not ~S~%"
    (@p V749 ())))))

(defun tlv (V750)
 (let Limit (limit V750)
  (if (= Limit 0)
   (interror "cannot take the tail of the empty vector~%" ())
   (if (= Limit 1) (vector 0)
    (let NewVector (vector (- Limit 1))
     (shen-tlv-help V750 2 Limit (vector (- Limit 1))))))))

(defun shen-tlv-help (V751 V752 V753 V754)
 (cond ((= V753 V752) (shen-copyfromvector V751 V754 V753 (- V753 1)))
  (true
   (shen-tlv-help V751 (+ V752 1) V753
    (shen-copyfromvector V751 V754 V752 (- V752 1))))))

(defun assoc (V764 V765)
 (cond ((= () V765) ())
  ((and (cons? V765) (and (cons? (hd V765)) (= (hd (hd V765)) V764)))
   (hd V765))
  ((cons? V765) (assoc V764 (tl V765))) (true (shen-sys-error assoc))))

(defun boolean? (V771)
 (cond ((= true V771) true) ((= false V771) true) (true false)))

(defun nl (V772)
 (cond ((= 0 V772) 0) (true (do (intoutput "~%" ()) (nl (- V772 1))))))

(defun difference (V775 V776)
 (cond ((= () V775) ())
  ((cons? V775)
   (if (element? (hd V775) V776) (difference (tl V775) V776)
    (cons (hd V775) (difference (tl V775) V776))))
  (true (shen-sys-error difference))))

(defun do (V777 V778) V778)

(defun element? (V787 V788)
 (cond ((= () V788) false) ((and (cons? V788) (= (hd V788) V787)) true)
  ((cons? V788) (element? V787 (tl V788))) (true (shen-sys-error element?))))

(defun empty? (V794) (cond ((= () V794) true) (true false)))

(defun fix (V795 V796) (shen-fix-help V795 V796 (V795 V796)))

(defun shen-fix-help (V803 V804 V805)
 (cond ((= V805 V804) V805) (true (shen-fix-help V803 V805 (V803 V805)))))

(defun put (V807 V808 V809 V810)
 (let N (hash V807 (limit V810))
  (let Entry (trap-error (<-vector V810 N) (lambda E ()))
   (let Change
    (vector-> V810 N (shen-change-pointer-value V807 V808 V809 Entry)) V809))))

(defun shen-change-pointer-value (V813 V814 V815 V816)
 (cond ((= () V816) (cons (cons (cons V813 (cons V814 ())) V815) ()))
  ((and (cons? V816)
    (and (cons? (hd V816))
     (and (cons? (hd (hd V816)))
      (and (cons? (tl (hd (hd V816))))
       (and (= () (tl (tl (hd (hd V816)))))
        (and (= (hd (tl (hd (hd V816)))) V814)
         (= (hd (hd (hd V816))) V813)))))))
   (cons (cons (hd (hd V816)) V815) (tl V816)))
  ((cons? V816)
   (cons (hd V816) (shen-change-pointer-value V813 V814 V815 (tl V816))))
  (true (shen-sys-error shen-change-pointer-value))))

(defun get (V819 V820 V821)
 (let N (hash V819 (limit V821))
  (let Entry
   (trap-error (<-vector V821 N)
    (lambda E (interror "pointer not found~%" ())))
   (let Result (assoc (cons V819 (cons V820 ())) Entry)
    (if (empty? Result) (interror "value not found~%" ()) (tl Result))))))

(defun hash (V822 V823)
 (let Hash
  (shen-mod (sum (map (lambda V824 (string->n V824)) (explode V822))) V823)
  (if (= 0 Hash) 1 Hash)))

(defun shen-mod (V825 V826)
 (shen-modh V825 (shen-multiples V825 (cons V826 ()))))

(defun shen-multiples (V827 V828)
 (cond ((and (cons? V828) (> (hd V828) V827)) (tl V828))
  ((cons? V828) (shen-multiples V827 (cons (* 2 (hd V828)) V828)))
  (true (shen-sys-error shen-multiples))))

(defun shen-modh (V831 V832)
 (cond ((= 0 V831) 0) ((= () V832) V831)
  ((and (cons? V832) (> (hd V832) V831))
   (if (empty? (tl V832)) V831 (shen-modh V831 (tl V832))))
  ((cons? V832) (shen-modh (- V831 (hd V832)) V832))
  (true (shen-sys-error shen-modh))))

(defun sum (V833)
 (cond ((= () V833) 0) ((cons? V833) (+ (hd V833) (sum (tl V833))))
  (true (shen-sys-error sum))))

(defun head (V840)
 (cond ((cons? V840) (hd V840))
  (true (interror "head expects a non-empty list" ()))))

(defun tail (V847)
 (cond ((cons? V847) (tl V847))
  (true (interror "tail expects a non-empty list" ()))))

(defun hdstr (V848) (pos V848 0))

(defun intersection (V851 V852)
 (cond ((= () V851) ())
  ((cons? V851)
   (if (element? (hd V851) V852) (cons (hd V851) (intersection (tl V851) V852))
    (intersection (tl V851) V852)))
  (true (shen-sys-error intersection))))

(defun reverse (V853) (shen-reverse_help V853 ()))

(defun shen-reverse_help (V854 V855)
 (cond ((= () V854) V855)
  ((cons? V854) (shen-reverse_help (tl V854) (cons (hd V854) V855)))
  (true (shen-sys-error shen-reverse_help))))

(defun union (V856 V857)
 (cond ((= () V856) V857)
  ((cons? V856)
   (if (element? (hd V856) V857) (union (tl V856) V857)
    (cons (hd V856) (union (tl V856) V857))))
  (true (shen-sys-error union))))

(defun y-or-n? (V858)
 (let Message (intoutput V858 ())
  (let Y-or-N (intoutput " (y/n) " ())
   (let Input (intmake-string "~S" (@p (input) ()))
    (if (= "y" Input) true
     (if (= "n" Input) false
      (do (intoutput "please answer y or n~%" ()) (y-or-n? V858))))))))

(defun not (V859) (if V859 false true))

(defun subst (V868 V869 V870)
 (cond ((= V870 V869) V868)
  ((cons? V870) (cons (subst V868 V869 (hd V870)) (subst V868 V869 (tl V870))))
  (true V870)))

(defun cd (V872)
 (set *home-directory*
  (if (= V872 "") "" (intmake-string "~A/" (@p V872 ())))))

(defun map (V873 V874) (shen-map-h V873 V874 ()))

(defun shen-map-h (V877 V878 V879)
 (cond ((= () V878) (reverse V879))
  ((cons? V878) (shen-map-h V877 (tl V878) (cons (V877 (hd V878)) V879)))
  (true (shen-sys-error shen-map-h))))

(defun length (V880) (shen-length-h V880 0))

(defun shen-length-h (V881 V882)
 (cond ((= () V881) V882) (true (shen-length-h (tl V881) (+ V882 1)))))

(defun occurrences (V891 V892)
 (cond ((= V892 V891) 1)
  ((cons? V892) (+ (occurrences V891 (hd V892)) (occurrences V891 (tl V892))))
  (true 0)))

(defun nth (V900 V901)
 (cond ((and (= 1 V900) (cons? V901)) (hd V901))
  ((cons? V901) (nth (- V900 1) (tl V901))) (true (shen-sys-error nth))))

(defun integer? (V902)
 (and (number? V902)
  (let Abs (shen-abs V902) (shen-integer-test? Abs (shen-magless Abs 1)))))

(defun shen-abs (V903) (if (> V903 0) V903 (- 0 V903)))

(defun shen-magless (V904 V905)
 (let Nx2 (* V905 2) (if (> Nx2 V904) V905 (shen-magless V904 Nx2))))

(defun shen-integer-test? (V909 V910)
 (cond ((= 0 V909) true) ((> 1 V909) false)
  (true
   (let Abs-N (- V909 V910)
    (if (> 0 Abs-N) (integer? V909) (shen-integer-test? Abs-N V910))))))

(defun mapcan (V913 V914)
 (cond ((= () V914) ())
  ((cons? V914) (append (V913 (hd V914)) (mapcan V913 (tl V914))))
  (true (shen-sys-error mapcan))))

(defun read-file-as-bytelist (V915)
 (let Stream (open file V915 in)
  (let Byte (read-byte Stream)
   (let Bytes (shen-read-file-as-bytelist-help Stream Byte ())
    (let Close (close Stream) (reverse Bytes))))))

(defun shen-read-file-as-bytelist-help (V916 V917 V918)
 (cond ((= -1 V917) V918)
  (true
   (shen-read-file-as-bytelist-help V916 (read-byte V916) (cons V917 V918)))))

(defun read-file-as-string (V919)
 (let Stream (open file V919 in) (shen-rfas-h Stream (read-byte Stream) "")))

(defun shen-rfas-h (V920 V921 V922)
 (cond ((= -1 V921) (do (close V920) V922))
  (true (shen-rfas-h V920 (read-byte V920) (cn V922 (n->string V921))))))

(defun == (V931 V932) (cond ((= V932 V931) true) (true false)))

(defun abort () (simple-error ""))

(defun read () (hd (lineread)))

(defun input () (eval (read)))

(defun input+ (V938 V939)
 (let Input (read)
  (let Check (shen-typecheck Input V939)
   (if (= false Check)
    (do (intoutput "input is not of type ~R: please re-enter " (@p V939 ()))
     (input+ : V939))
    (eval Input)))))

(defun bound? (V940)
 (and (symbol? V940)
  (let Val (trap-error (value V940) (lambda E shen-this-symbol-is-unbound))
   (if (= Val shen-this-symbol-is-unbound) false true))))

(defun shen-string->bytes (V941)
 (cond ((= "" V941) ())
  (true (cons (string->n (pos V941 0)) (shen-string->bytes (tlstr V941))))))

(defun maxinferences (V942) (set shen-*maxinferences* V942))

(defun inferences (V947) (value shen-*infs*))

(defun shen-hush (V952)
 (cond ((= + V952) (set shen-*hush* shen-hushed))
  ((= - V952) (set shen-*hush* shen-unhushed))
  (true (interror "'hush' expects a + or a -~%" ()))))

(defun protect (V953) V953)

(defun shen-stoutput (V958) (value *stoutput*))

